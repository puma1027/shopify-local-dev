import fs from 'fs';
import path from 'path';

type ScriptMetadata = {
  schemaVersions: {[ep: string]: SchemaVersion};
  flags: {[key: string]: any};
};

export function getMetadata(ep?: string, domain?: string): ScriptMetadata {
  if ((ep && !domain) || (domain && !ep)) {
    throw new Error('When working with domain packages, both --ep and --domain options are required');
  }

  const bounded = ep && domain;

  return {
    schemaVersions: bounded ? domainSchemaVersions({domain, ep} as DomainContext) : schemaVersions(),
    flags: {use_msgpack: true},
  };
}

type SchemaVersion =
  | {
      major: number;
      minor: number;
    }
  | {major: 'prerelease'};

const relativePathToShopifyNodeModules = path.join('.', 'node_modules', '@shopify');

const regexes = {
  legacy: new RegExp('extension-point-as-(.+)'),
  bounded: (domain: string) => new RegExp(`scripts-${domain}-apis`),
};

type DomainContext = {
  domain: string;
  ep: string;
};

function domainSchemaVersions(context: DomainContext): {[ep: string]: SchemaVersion} {
  const shopifyNodeModules = getShopifyNodeModules();
  const regex = regexes.bounded(context.domain);
  const epPackages = shopifyNodeModules.filter((dirent) => isEpPackage(dirent, regex)).map((dirent) => dirent.name);

  if (epPackages.length < 1) {
    throw new Error(`Expected to have @shopify/scripts-${context.domain}-apis installed`);
  }

  return epPackages.reduce((versions, epPackage) => {
    const epMetadata = JSON.parse(readMetadataJsonForEp(epPackage, context));
    const schemaVersion = epMetadata.schemaVersion;
    if (!schemaVersion) {
      throw new Error(`NPM package ${epPackage} does not have a schemaVersion defined`);
    }
    const epName = context.ep.replace(/-/g, '_');
    versions[epName] = schemaVersion;
    return versions;
  }, {} as {[ep: string]: SchemaVersion});
}

function schemaVersions(): {[ep: string]: SchemaVersion} {
  const shopifyNodeModules = getShopifyNodeModules();
  const epPackages = shopifyNodeModules
    .filter((dirent) => isEpPackage(dirent, regexes.legacy))
    .map((dirent) => dirent.name);

  if (epPackages.length < 1) {
    throw new Error('Expected to have at least one EP NPM package installed');
  }

  return epPackages.reduce((versions, epPackage) => {
    const epMetadata = JSON.parse(readMetadataJsonForEp(epPackage));
    const schemaVersion = epMetadata.schemaVersion;
    if (!schemaVersion) {
      throw new Error(`NPM package ${epPackage} does not have a schemaVersion defined`);
    }
    const epName = epPackageToEpName(epPackage, regexes.legacy);
    versions[epName] = schemaVersion;
    return versions;
  }, {} as {[ep: string]: SchemaVersion});
}

function getShopifyNodeModules(): fs.Dirent[] {
  return fs.readdirSync(relativePathToShopifyNodeModules, {withFileTypes: true});
}

function readMetadataJsonForEp(epPackage: string, context?: DomainContext): string {
  let metadataPath: string;
  if (context) {
    metadataPath = path.join(relativePathToShopifyNodeModules, epPackage, 'metadata', `${context.ep}.json`);
  } else {
    metadataPath = path.join(relativePathToShopifyNodeModules, epPackage, 'metadata.json');
  }

  if (!fs.existsSync(metadataPath)) {
    throw new Error(`NPM package ${epPackage} does not have metadata associated with it`);
  }
  return fs.readFileSync(metadataPath, {encoding: 'utf8'});
}

function isEpPackage(dirent: fs.Dirent, regex: RegExp): boolean {
  return (dirent.isDirectory() || dirent.isSymbolicLink()) && !!dirent.name.match(regex);
}

function epPackageToEpName(epPackage: string, regex: RegExp): string {
  return epPackage.match(regex)![1].replace(/-/g, '_');
}
