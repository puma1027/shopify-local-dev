import {strict as assert} from 'assert';
import {GSClassField} from './gs-class-field';
import {GSClassFieldEncoder} from './gs-class-field-encoder';
import {GSClassFieldDecoder} from './gs-class-field-decoder';
import {GSFieldWriter} from './gs-field-writer';

export class GSClassFieldSerializer {
  static build(field: GSClassField): string {
    if (field.isBox) {
      return new GSBoxFieldSerializer(field).build();
    } else {
      return new GSClassFieldSerializer(field).build();
    }
  }

  constructor(private readonly field: GSClassField) {}

  build(): string {
    const typeName = this.field.typeName;

    const allFieldsWithDefaultValue = this.field
      .getAllFields()
      .map((f) => {
        let s = `  ${f.name}: ${f.typeNameWithTypeArg}`;
        const defaultValue = f.getDefaultValue();
        if (defaultValue) {
          return `${s} = ${defaultValue};`;
        } else {
          return `${s};`;
        }
      })
      .join('\n');

    return `\
class ${typeName}Serializer {
${allFieldsWithDefaultValue}

  bufferLen(): u32 {
    const sizer = new Sizer();
    this.encode(sizer);
    return sizer.length;
  }

${GSClassFieldEncoder.build(this.field)}

${GSClassFieldDecoder.build(this.field)}
}
`;
  }
}

// This serializer specifically handles __Output type, which serializes the value of `inner` field
// directly, so that the serialization result is not wrapped with `{"inner": ... }`
export class GSOutputFieldSerializer {
  static build(field: GSClassField): string {
    return new GSOutputFieldSerializer(field).build();
  }

  constructor(private readonly field: GSClassField) {}

  private build(): string {
    const typeName = this.field.typeName;
    const fields = this.field.getAllFields();
    assert(fields.length == 1, 'Output type should only have one field');
    const inner = fields[0];

    let fieldWithDefaultValue = `  ${inner.name}: ${inner.typeNameWithTypeArg}`;
    const defaultValue = inner.getDefaultValue();
    if (defaultValue) {
      fieldWithDefaultValue = `${fieldWithDefaultValue} = ${defaultValue};`;
    }

    return `\
class ${typeName}Serializer {
${fieldWithDefaultValue}

  bufferLen(): u32 {
    const sizer = new Sizer();
    this.encode(sizer);
    return sizer.length;
  }

  encode(writer: Writer): void {
${GSFieldWriter.build(inner, 2, `this.${inner.name}`)}
  }
}
`;
  }
}

// This serializer specifically handles Box<T> SDK type (where T is primitive), which ignores the
// wrapper during serialization.
//
// Eg. const field: Box<i32> = new Box(42), will be serialized and deserialized as 42
class GSBoxFieldSerializer {
  static build(field: GSClassField): string {
    assert(field.isBox, 'GSBoxFieldSerializer only generates serializers for Box<T>');
    return new GSClassFieldSerializer(field).build();
  }

  constructor(private readonly field: GSClassField) {}

  build(): string {
    const allFields = this.field.getAllFields();
    assert(allFields.length == 1, 'Box<T> should only contain one field');
    const field = allFields[0];
    const fieldName = field.name;

    const encode = [];
    encode.push('  encode(writer: Writer): void {');
    encode.push(`    if (this.${fieldName} instanceof i8) {`);
    encode.push(`      writer.writeInt8(<i8>this.${fieldName});`);
    encode.push(`    } else if (this.${fieldName} instanceof i16) {`);
    encode.push(`      writer.writeInt16(<i16>this.${fieldName});`);
    encode.push(`    } else if (this.${fieldName} instanceof i32) {`);
    encode.push(`      writer.writeInt32(<i32>this.${fieldName});`);
    encode.push(`    } else if (this.${fieldName} instanceof i64) {`);
    encode.push(`      writer.writeInt64(<i64>this.${fieldName});`);
    encode.push(`    } else if (this.${fieldName} instanceof u8) {`);
    encode.push(`      writer.writeUInt8(<u8>this.${fieldName});`);
    encode.push(`    } else if (this.${fieldName} instanceof u16) {`);
    encode.push(`      writer.writeUInt16(<u16>this.${fieldName});`);
    encode.push(`    } else if (this.${fieldName} instanceof u32) {`);
    encode.push(`      writer.writeUInt32(<u32>this.${fieldName});`);
    encode.push(`    } else if (this.${fieldName} instanceof u64) {`);
    encode.push(`      writer.writeUInt64(<u64>this.${fieldName});`);
    encode.push(`    } else if (this.${fieldName} instanceof f32) {`);
    encode.push(`      writer.writeFloat32(<f32>this.${fieldName});`);
    encode.push(`    } else if (this.${fieldName} instanceof f64) {`);
    encode.push(`      writer.writeFloat64(<f64>this.${fieldName});`);
    encode.push(`    } else if (this.${fieldName} instanceof bool) {`);
    encode.push(`      writer.writeBool(<bool>this.${fieldName});`);
    encode.push('    } else {');
    encode.push(`      throw new Error('Unexpected field type for Box<T>');`);
    encode.push('    }');
    encode.push('  }');

    const decode = [];
    decode.push('  static decode<T>(__reader__: Decoder): BoxSerializer<T> {');
    decode.push(`    let ${fieldName}: T;`);
    decode.push('');
    decode.push(`    if (${fieldName} instanceof i8) {`);
    decode.push(`      ${fieldName} = __reader__.readInt8();`);
    decode.push(`    } else if (${fieldName} instanceof i16) {`);
    decode.push(`      ${fieldName} = __reader__.readInt16();`);
    decode.push(`    } else if (${fieldName} instanceof i32) {`);
    decode.push(`      ${fieldName} = __reader__.readInt32();`);
    decode.push(`    } else if (${fieldName} instanceof i64) {`);
    decode.push(`      ${fieldName} = __reader__.readInt64();`);
    decode.push(`    } else if (${fieldName} instanceof u8) {`);
    decode.push(`      ${fieldName} = __reader__.readUInt8();`);
    decode.push(`    } else if (${fieldName} instanceof u16) {`);
    decode.push(`      ${fieldName} = __reader__.readUInt16();`);
    decode.push(`    } else if (${fieldName} instanceof u32) {`);
    decode.push(`      ${fieldName} = __reader__.readUInt32();`);
    decode.push(`    } else if (${fieldName} instanceof u64) {`);
    decode.push(`      ${fieldName} = __reader__.readUInt64();`);
    decode.push(`    } else if (${fieldName} instanceof f32) {`);
    decode.push(`      ${fieldName} = __reader__.readFloat32();`);
    decode.push(`    } else if (${fieldName} instanceof f64) {`);
    decode.push(`      ${fieldName} = __reader__.readFloat64();`);
    decode.push(`    } else if (${fieldName} instanceof bool) {`);
    decode.push(`      ${fieldName} = __reader__.readBool();`);
    decode.push('    } else {');
    decode.push(`      throw new Error('Unexpected field type for Box<T>');`);
    decode.push('    }');
    decode.push(`    return {${fieldName}};`);
    decode.push('  }');

    return `\
class BoxSerializer<T> {
  ${fieldName}: T;

  bufferLen(): u32 {
    const sizer = new Sizer();
    this.encode(sizer);
    return sizer.length;
  }

${encode.join('\n')}

${decode.join('\n')}
}
`;
  }
}
