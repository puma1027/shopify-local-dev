import {Program} from 'assemblyscript';
import {GSIOWalker} from './gs-io-walker';
import {GSField} from './gs-field';
import {GSClassField} from './gs-class-field';

export class GSIOBuilder {
  static build(program: Program): string {
    const walker = new GSIOWalker(program);
    return new GSIOBuilder(walker.inputFields, walker.outputField!).build();
  }

  private constructor(private readonly inputFields: GSField[], private readonly outputField: GSField) {}

  private build(): string {
    const content = [];

    const referencedClassFields = this.referencedClassFields();
    content.push(this.buildImport(referencedClassFields));

    content.push('export class __Input {');
    content.push('  constructor(');
    const inputFieldList = this.inputFields.map((field) => `    public ${field.name}: ${field.typeNameWithTypeArg},`);
    content.push(inputFieldList.join('\n'));
    content.push('  ) {}');
    content.push('}');
    content.push('');
    content.push('export class __Output {');
    content.push('  constructor(');
    content.push(`    public inner: ${this.outputField.typeNameWithTypeArg},`);
    content.push('  ) {}');
    content.push('}');

    return content.join('\n');
  }

  private referencedClassFields(): GSClassField[] {
    const map = this.inputAndOutputClassFields().reduce((acc, field) => {
      field.referencedClassFields().forEach((field, name, _map) => {
        // The reason we `acc.has(name)` is that field.referencedClassFields is a deep and recursive
        // search on all referenced class fields, which makes it possible that two field reference
        // the same class field.
        if (!acc.has(name)) {
          acc.set(name, field);
        }
      });
      return acc;
    }, new Map() as Map<string, GSClassField>);

    return Array.from(map.values());
  }

  private inputAndOutputClassFields(): GSClassField[] {
    const classFields = this.inputFields.filter((f) => f.isClass).map((f) => f.asClassField()!);

    if (this.outputField.isClass) {
      classFields.push(this.outputField.asClassField()!);
    }

    return classFields;
  }

  private buildImport(fields: GSClassField[]): string {
    const entries = Array.from(buildSourceToClassnamesMap(fields).entries());
    return entries
      .map(([source, typeNames]) => {
        return `import {${typeNames.join(',')}} from "${source}";`;
      })
      .join('\n');
  }
}

function buildSourceToClassnamesMap(fields: GSClassField[]): Map<string, string[]> {
  const imports: Map<string, string[]> = new Map();
  fields.forEach((field) => {
    const source = field.source();
    const typeNames = imports.get(source) || [];
    typeNames.push(field.typeName);
    imports.set(source, typeNames);
  });
  return imports;
}
