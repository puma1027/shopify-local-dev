import {strict as assert} from 'assert';
import {
  Field,
  DecoratorNode,
  NodeKind,
  IdentifierExpression,
  LiteralKind,
  StringLiteralExpression,
} from 'assemblyscript';

export function getIndentSpaces(indent: number): string {
  if (indent <= 0) {
    return '';
  } else {
    let s = '';
    for (let i = 0; i < indent; i++) {
      s += '  ';
    }
    return s;
  }
}

export function toSnakeCase(str: string): string {
  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
}

// Parse '@shopify_rename' annotation
//
// Eg. return 'foo' for
//
// class A {
//   @shopify_rename("foo")
//   bar: string
// }
export function parseAlias(field: Field): string | null {
  if (field.decoratorNodes == null) {
    return null;
  }

  const decorators = field.decoratorNodes.find((decorator: DecoratorNode) => {
    return (
      decorator.name.kind == NodeKind.IDENTIFIER && (<IdentifierExpression>decorator.name).text == 'shopify_rename'
    );
  });
  if (decorators == null) {
    return null;
  }

  const args = decorators.args;
  assert(args && args.length == 1, 'shopify_rename has arity of 1');
  assert(args[0].isLiteralKind(LiteralKind.STRING), 'shopify_rename expects string literal');

  const alias: string = (<StringLiteralExpression>args[0]).value;
  return alias;
}

// Parse `@shopify_transient` annotation
//
// Eg. return 'true' for bar field
//
// class A {
//   @shopify_transient
//   bar: string;
// }
export function parseTransient(field: Field): boolean {
  if (field.decoratorNodes == null) {
    return false;
  }

  const decorators = field.decoratorNodes.find((decorator: DecoratorNode) => {
    return (
      decorator.name.kind == NodeKind.IDENTIFIER && (<IdentifierExpression>decorator.name).text == 'shopify_transient'
    );
  });
  if (decorators == null) {
    return false;
  }

  const args = decorators.args;
  assert(args == null || args.length == 0, 'shopify_transient has arity of 0');

  return true;
}
