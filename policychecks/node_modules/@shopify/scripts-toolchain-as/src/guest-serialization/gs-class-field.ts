import {strict as assert} from 'assert';
import {ElementKind, Field, Type, Class} from 'assemblyscript';
import * as path from 'path';
import {GSField} from './gs-field';
import {toSnakeCase, parseAlias, parseTransient} from './utility';

const STANDARD_LIB_TYPES: Array<string> = ['ArrayBuffer'];

export class GSClassField {
  // THIS IS A MASSIVE HACK, BUT WE NEED TO TELL THE CODE GENERATOR
  // WHERE THE SERIALIZER FILE IS LOCATED. THIS IS TO MAKE SURE THE PATHS ARE RELATIVE
  // TO THE SERIALIZER, NOT THE CWD.
  static serializerDir: string | undefined;

  readonly name: string;
  readonly alias: string | null;
  readonly type: Type;
  readonly reference: Class;

  constructor(name: string, type: Type, alias: string | null = null) {
    this.name = name;
    this.type = type;
    this.alias = alias;

    assert(type.isClass, 'GSClassField only takes type of class');
    this.reference = type.getClass()!;
  }

  get isNullableReference(): boolean {
    return this.type.isNullableReference;
  }

  get nameInSnakeCase(): string {
    const name = this.alias ? this.alias : this.name;
    return toSnakeCase(name);
  }

  get isString(): boolean {
    return this.typeName == 'String';
  }

  get isArrayLike(): boolean {
    return this.reference.isArrayLike;
  }

  get isArray(): boolean {
    return this.isArrayLike && this.typeName === 'Array';
  }

  get isExtendedArray(): boolean {
    return this.isArrayLike && this.baseClassName === 'Array';
  }

  get isSet(): boolean {
    return this.typeName == 'Set';
  }

  get isMap(): boolean {
    if (this.typeName !== 'Map') {
      return false;
    }

    const typeArguments = this.reference.typeArguments!;
    const keyArg = new GSField('', typeArguments[0]);
    if (keyArg.isClass && keyArg.asClassField()!.isString) {
      return true;
    } else {
      throw new Error(`Key type of Map ${this.name} is not String`);
    }
  }

  get isBox(): boolean {
    return this.reference.internalName.startsWith('~lib/@shopify/scripts-sdk-as/Box');
  }

  get boxOf(): string | null {
    if (!this.isBox) {
      return null;
    }

    return this.reference.internalName.replace('~lib/@shopify/scripts-sdk-as/Box/Box', '').replace(/[<>]/g, '');
  }

  get typeName(): string {
    return this.reference.prototype.name;
  }

  get typeNameWithTypeArg(): string {
    const nullableSuffix = this.isNullableReference ? ' | null' : '';
    const typeArguments = this.typeArgumentTypes();

    let name: string;
    if (this.isArray) {
      const typeArg = new GSField('', typeArguments[0]);
      name = `Array<${typeArg.typeNameWithTypeArg}>`;
    } else if (this.isSet) {
      const typeArg = new GSField('', typeArguments[0]);
      name = `Set<${typeArg.typeNameWithTypeArg}>`;
    } else if (this.isString) {
      name = 'String';
    } else if (this.isMap) {
      const keyArg = new GSField('', typeArguments[0]);
      const valueArg = new GSField('', typeArguments[1]);
      return `Map<${keyArg.typeNameWithTypeArg}, ${valueArg.typeNameWithTypeArg}>`;
    } else {
      if (typeArguments.length === 0) {
        name = this.typeName;
      } else if (typeArguments.length === 1) {
        const typeArg = new GSField('', typeArguments[0]);
        name = `${this.typeName}<${typeArg.typeNameWithTypeArg}>`;
      } else {
        throw new Error(`Class type with more than 2 type arguments is not supported: ${this.typeName}`);
      }
    }

    return `${name}${nullableSuffix}`;
  }

  get baseClassName(): string {
    const basePrototype = this.reference.prototype.basePrototype;
    if (!basePrototype) {
      return '';
    } else {
      return basePrototype.name;
    }
  }

  // The method calculates the import path of the referenced class.
  //
  // Note: I couldn't find a proper way but to parse from the internalName defined in "src/program.ts/Element"
  //
  // Example 1: given internalName for Console is "~lib/as-wasi/as-wasi/Console", the method returns
  // import {Console} from "as-wasi";
  //
  // Example 2: given internalName for Product is "src/product/Product", the method returns
  // import {Product} from "./product";
  //
  // Example 3: given internalName for Array<Field> is "~lib/array/Array<src/field/Field>", the method returns
  // import {Field} from "./field";
  source(): string {
    let currentType = this.type;

    while (true) {
      const field = new GSClassField('', currentType);
      if (field.isArray || field.isSet) {
        const typeArg = field.typeArgumentTypes()[0];
        if (!typeArg.isClass) {
          return '';
        }
        currentType = typeArg;
      } else if (field.isMap) {
        // keyArg (typeArgs[0]) is already asserted to be String
        const typeArg = field.typeArgumentTypes()[1];
        if (!typeArg.isClass) {
          return '';
        }
        currentType = typeArg;
      } else {
        break;
      }
    }

    const field = new GSClassField('', currentType);
    const internalName = field.reference.internalName;
    const parts = internalName.split('/');

    let typeName = parts.pop()!;
    let typeDeclaration = field.typeNameWithTypeArg;
    if (field.isNullableReference) {
      typeName = typeName + ' | null';
    }
    assert(
      typeName === typeDeclaration,
      `Cannot infer source for: typeName ${typeName} typeDdeclaration: ${typeDeclaration}`,
    );

    if (parts[0] == '~lib') {
      parts.pop(); // pop file name
      parts.shift(); // pop ~lib
      return parts.join('/');
    } else {
      const source = parts.join('/');
      const sourceFile = path.join(process.cwd(), source);

      const targetDir = GSClassField.serializerDir!;
      const prefix = './';
      return prefix + path.relative(targetDir, sourceFile);
    }
  }

  typeArgumentTypes(): Array<Type> {
    assert(!this.isExtendedArray, 'Types extend Array are not supported. Please use a wrapper type');

    if (!this.reference.typeArguments) {
      return [];
    }

    const typeArguments = this.reference.typeArguments!;
    if (this.isMap) {
      assert(typeArguments.length == 2, 'Two type args are required for Map<K,V>');
    } else {
      assert(typeArguments.length == 1, 'Only one type arg for Array<T> or custom class is supported');
    }
    return typeArguments;
  }

  serializerClassName(withGeneric: boolean = false): string {
    let s = `${this.typeName}Serializer`;
    if (withGeneric && this.isBox) {
      s = `${s}<${this.boxOf}>`;
    }

    return s;
  }

  getAllFields(): GSField[] {
    const gsFields: GSField[] = [];
    const uniqueNames: Array<string> = [];
    this.reference.members!.forEach((field, _name, _map) => {
      if (field.kind == ElementKind.FIELD) {
        // `field` is of generic type `DeclaredElement`. We have to cast to a specific
        // element type so that the `field.type` can work as expected.
        const f = <Field>field;
        const alias = parseAlias(f);
        const isTransient = parseTransient(f);
        const gsField = new GSField(f.name, f.type, alias, isTransient);
        const name = gsField.nameInSnakeCase;

        if (uniqueNames.includes(name)) {
          throw new Error(`Duplicated field name/alias '${name}' detected in ${this.typeName}`);
        } else {
          uniqueNames.push(name);
        }

        gsFields.push(gsField);
      }
    });
    return gsFields;
  }

  getNonTransientFields(): GSField[] {
    return this.getAllFields().filter((f) => !f.isTransient);
  }

  // It properly handles cyclic referenced types
  referencedClassFields(): Map<string, GSClassField> {
    const ret: Map<string, GSClassField> = new Map();

    if (STANDARD_LIB_TYPES.includes(this.typeName)) {
      return ret;
    } else if (this.isString) {
      return ret;
    } else if (this.isArray || this.isSet) {
      const argType = this.typeArgumentTypes()[0];
      if (argType.isClass) {
        return new GSClassField('', argType).referencedClassFields();
      }
      return ret;
    } else if (this.isMap) {
      // key type is already checked as string
      const argType = this.typeArgumentTypes()[1];
      if (argType.isClass) {
        return new GSClassField('', argType).referencedClassFields();
      }
      return ret;
    } else if (this.isExtendedArray) {
      throw new Error('Types extend Array are not supported. Please use a wrapper type');
    } else {
      const typeArguments = this.typeArgumentTypes();
      if (typeArguments.length === 1) {
        if (typeArguments[0].isClass) {
          throw new Error(`Class type argument is not supported: ${this.typeNameWithTypeArg}`);
        }
      } else if (typeArguments.length > 1) {
        throw new Error(`Class type argument is not supported: ${this.typeNameWithTypeArg}`);
      }
    }

    ret.set(this.typeName, this);

    this.getAllFields().forEach((f) => {
      if (!f.isClass) {
        return;
      }

      const field = f.asClassField()!;

      field.referencedClassFields().forEach((rf, _name, _map) => {
        if (!ret.has(rf.typeName)) {
          ret.set(rf.typeName, rf);
        }
      });
    });
    return ret;
  }

  getDefaultValue(): string {
    if (this.isNullableReference) {
      return 'null';
    } else if (this.isString) {
      return `''`;
    } else if (this.isArray) {
      return '[]';
    } else if (this.isSet) {
      return 'new Set()';
    } else if (this.isMap) {
      return `new Map()`;
    } else if (this.isBox) {
      return `changetype<${this.typeName}<${this.boxOf!}>>(new ${this.serializerClassName(true)}())`;
    } else {
      return `changetype<${this.typeName}>(new ${this.serializerClassName()}())`;
    }
  }

  toString(): string {
    return `
      GSClassField {
        name: ${this.typeName}
        type: ${this.type}
        reference: ${this.reference}
        typeName: ${this.typeName}
        source: ${this.source()}
      }
    `;
  }
}
