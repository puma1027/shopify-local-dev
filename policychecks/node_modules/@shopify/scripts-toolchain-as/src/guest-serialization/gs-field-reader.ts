import {strict as assert} from 'assert';
import {TypeKind} from 'assemblyscript';
import {GSField} from './gs-field';
import {GSClassField} from './gs-class-field';
import {getIndentSpaces} from './utility';

// This class genereates the specific reader block for a decoder
//
// eg. for a field of type: i8
//
// GSFieldReader.build(field, 0, "a =")     => "a = reader.readInt8();"
// GSFieldReader.build(field, 2, "return")  => "    return reader.readInt8();"
//
// eg. for a field of type Array<i8>: GSFieldReader.build(field, 0, "a =") =>
//
// a = reader.readArray((reader: Decoder): i32 => {
//   return reader.readInt8();
// });
//
// eg. for a field of type Map<i8, string>: GSFieldReader.build(field, 0, "a =") =>
//
// a = reader.readMap(
//  (reader: Decoder): i8 => {
//    return reader.readInt8();
//  },
//  (reader: Decoder): string => {
//    return reader.readString();
//  }
// );
//
// eg. for a field of type Foo, which extends Array<i8>: GSFieldReader.build(field, 0, "a =") =>
//
// a = Foo.from(reader.readArray((reader: Decoder): i32 => {
//   return reader.readInt8();
// }));
//
// eg. for a field of type Bar: GSFieldReader.build(field, 0, "a =") =>
//
// a = (function(reader: Decoder): Bar {
//   let v = new Bar();
//   const serializer = new BarSerializer(v);
//   serializer.decode(reader);
//   return v;
// })(reader);
//
// eg. for a field of type Bar | null: GSFieldReader.build(field, 0, "a =")
//
// => (quotes ignored)
//
// if (reader.isNextNil()) {
//   a = null;
// else {
//   a = (function(reader: Decoder): Bar {
//     let v = new Bar();
//     const serializer = new BarSerializer(v);
//     serializer.decode(reader);
//     return v;
//   })(reader);
// }
//
export class GSFieldReader {
  static build(field: GSField, indent: number, readToArg: string): string {
    return new GSFieldReader(field).build(indent, readToArg);
  }

  constructor(private readonly field: GSField) {}

  private build(indent: number, readToArg: string): string {
    if (this.field.isClass) {
      return this.buildClassField(indent, readToArg);
    } else {
      return this.buildBasicField(indent, readToArg);
    }
  }

  private buildClassField(ind: number, readToArg: string): string {
    const indent = getIndentSpaces(ind);
    const field = this.field.asClassField()!;
    const isNullableReference = this.field.isNullableReference;
    let ret: string[] = [];

    assert(!field.isExtendedArray, 'Types extend Array are not supported. Please use a wrapper type');
    if (field.isString) {
      ret.push(`${indent}${readToArg} __reader__.readString();`);
    } else if (field.isArray) {
      ret = ret.concat(buildArrayField(field, ind, readToArg));
    } else if (field.isSet) {
      ret = ret.concat(buildSetField(field, ind, readToArg));
    } else if (field.isMap) {
      ret = ret.concat(buildMapField(field, ind, readToArg));
    } else {
      ret = ret.concat(buildNormalClassField(field, ind, readToArg));
    }

    if (!isNullableReference) {
      return ret.join('\n');
    }

    let nullableCheck = [];
    nullableCheck.push(`${indent}if (__reader__.isNextNil()) {`);
    nullableCheck.push(`${indent}  ${readToArg} null;`);
    nullableCheck.push(`${indent}} else {`);
    nullableCheck = nullableCheck.concat(ret.map((line) => `  ${line}`));
    nullableCheck.push(`${indent}}`);

    return nullableCheck.join('\n');
  }

  private buildBasicField(ind: number, readToArg: string): string {
    const indent = getIndentSpaces(ind);
    const decodeFunction = this.getReaderFunction();
    return `${indent}${readToArg} __reader__.${decodeFunction}();`;
  }

  private getReaderFunction(): string {
    const kind = this.field.kind;
    switch (kind) {
      case TypeKind.I8:
        return `readInt8`;
      case TypeKind.I16:
        return `readInt16`;
      case TypeKind.I32:
        return `readInt32`;
      case TypeKind.I64:
        return `readInt64`;
      case TypeKind.ISIZE:
        return `readInt32`;
      case TypeKind.U8:
        return `readUInt8`;
      case TypeKind.U16:
        return `readUInt16`;
      case TypeKind.U32:
        return `readUInt32`;
      case TypeKind.U64:
        return `readUInt64`;
      case TypeKind.USIZE:
        return `readUInt32`;
      case TypeKind.BOOL:
        return `readBool`;
      case TypeKind.F32:
        return `readFloat32`;
      case TypeKind.F64:
        return `readFloat64`;
      // Note: Not needed now
      //
      // case TypeKind.V128: return "v128";
      // case TypeKind.FUNCREF: return "funcref";
      // case TypeKind.EXTERNREF: return "externref";
      // case TypeKind.EXNREF: return "exnref";
      // case TypeKind.ANYREF: return "anyref";
      // case TypeKind.VOID: return "void";
      default:
        throw new Error(`Unknown type kind: ${kind}`);
    }
  }
}

function buildArrayField(field: GSClassField, ind: number, readToArg: string): string[] {
  const ret = [];
  const indent = getIndentSpaces(ind);
  const typeArg = field.typeArgumentTypes()[0];
  const typeArgDeclarationName = new GSField('', typeArg).typeNameWithTypeArg;

  ret.push(`${indent}${readToArg} __reader__.readArray((__reader__: Decoder): ${typeArgDeclarationName} => {`);
  const gsField = new GSField('', typeArg);
  ret.push(GSFieldReader.build(gsField, ind + 1, 'return'));
  ret.push(`${indent}});`);
  return ret;
}

function buildSetField(field: GSClassField, ind: number, readToArg: string): string[] {
  const ret = [];
  const indent = getIndentSpaces(ind);
  const typeArg = field.typeArgumentTypes()[0];
  const typeArgDeclarationName = new GSField('', typeArg).typeNameWithTypeArg;

  ret.push(`${indent}${readToArg} ((__reader__: Decoder): ${field.typeNameWithTypeArg} => {`);
  ret.push(`${indent}  let _set: ${field.typeNameWithTypeArg} = new Set();`);
  ret.push(`${indent}  let _array = __reader__.readArray((__reader__: Decoder): ${typeArgDeclarationName} => {`);
  const gsField = new GSField('', typeArg);
  ret.push(GSFieldReader.build(gsField, ind + 2, 'return'));
  ret.push(`${indent}  });`);
  ret.push(`${indent}  for (let i = 0; i < _array.length; i++) {`);
  ret.push(`${indent}    _set.add(_array[i]);`);
  ret.push(`${indent}  }`);
  ret.push(`${indent}  return _set;`);
  ret.push(`${indent}})(__reader__);`);
  return ret;
}

function buildMapField(field: GSClassField, ind: number, readToArg: string): string[] {
  const ret = [];
  const indent = getIndentSpaces(ind);
  const typeArgumentTypes = field.typeArgumentTypes();

  ret.push(`${indent}${readToArg} __reader__.readMap(`);

  const keyArgType = typeArgumentTypes[0];
  const keyGSField = new GSField('', keyArgType);
  ret.push(`${indent}  (__reader__: Decoder): ${keyGSField.typeNameWithTypeArg} => {`);
  ret.push(GSFieldReader.build(keyGSField, ind + 2, 'return'));
  ret.push(`${indent}  },`);

  const valueArgType = typeArgumentTypes[1];
  const valueGSField = new GSField('', valueArgType);
  ret.push(`${indent}  (__reader__: Decoder): ${valueGSField.typeNameWithTypeArg} => {`);
  ret.push(GSFieldReader.build(valueGSField, ind + 2, 'return'));
  ret.push(`${indent}  },`);

  ret.push(`${indent});`);
  return ret;
}

function buildNormalClassField(field: GSClassField, ind: number, readToArg: string): string[] {
  const ret = [];
  const indent = getIndentSpaces(ind);
  const typeName = field.typeName;
  const serializerClassName = field.serializerClassName();
  const boxSuffix = field.isBox ? `<${field.boxOf!}>` : '';

  ret.push(
    `${indent}${readToArg} changetype<${typeName}${boxSuffix}>(${serializerClassName}.decode${boxSuffix}(__reader__));`,
  );
  return ret;
}
