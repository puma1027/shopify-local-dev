import {TypeKind} from 'assemblyscript';
import {GSField} from './gs-field';
import {getIndentSpaces} from './utility';

// This class genereates the specific writer block for an encoder
//
// eg. for a field of type: i8
//
// GSFieldWriter.build(field, 0, "a")   => "writer.writeInt8(a);"
// GSFieldWriter.build(field, 2, "foo") => "    writer.writeInt8(foo);"
//
// eg. for a field of type Array<i8>: GSFieldWriter.build(field, 0, "a") =>
//
// writer.writeArray(a, (writer: Writer, item: i8) => {
//   writer.writeInt8(a);
// });
//
// eg. for a field of type Map<i8, string>: GSFieldWriter.build(field, 0, "a") =>
//
// writer.writeMap(
//   a,
//   (writer: Writer, key: i8): void => {
//     writer.writeInt8(key);
//   },
//   (writer: Writer, value: string) => {
//     writer.writeString(value);
//   }
// );
//
// eg. for a field of type Foo which extends Array<i8>: GSFieldWriter.build(field, 0, "a") =>
//
// writer.writeArray(a, (writer: Writer, item: i8) => {
//   writer.writeInt8(a);
// });
//
// eg. for a field of type Bar: GSFieldWriter.build(field, 0, "a") =>
//
// (new BarSerializer(a)).encode(writer);
//
// eg. for a field of type Bar | null: GSFieldWriter.build(field, 0, "a") =>
//
// if (a === null) {
//   writer.writeNil();
// else {
//   (new BarSerializer(a)).encode(writer);
// }
export class GSFieldWriter {
  static build(field: GSField, indent: number, writeToArg: string): string {
    return new GSFieldWriter(field).build(indent, writeToArg);
  }

  constructor(private readonly field: GSField) {}

  private build(indent: number, writeToArg: string): string {
    if (this.field.isClass) {
      return this.buildClassField(indent, writeToArg);
    } else {
      return this.buildBasicField(indent, writeToArg);
    }
  }

  private buildClassField(ind: number, writeToArg: string): string {
    const indent = getIndentSpaces(ind);
    const field = this.field.asClassField()!;
    const isNullableReference = this.field.isNullableReference;
    const nullableSuffix = isNullableReference ? '!' : '';
    const ret = [];

    if (field.isString) {
      ret.push(`${indent}writer.writeString(${writeToArg}${nullableSuffix});`);
    } else if (field.isArray || field.isSet) {
      const typeArg = field.typeArgumentTypes()[0];
      const typeArgDeclarationName = new GSField('', typeArg).typeNameWithTypeArg;
      let argName = writeToArg;
      if (field.isSet) {
        argName = `${argName}.values()`;
      }

      ret.push(
        `${indent}writer.writeArray(${argName}${nullableSuffix}, (writer: Writer, item: ${typeArgDeclarationName}) => {`,
      );
      const gsField = new GSField('item', typeArg);
      ret.push(GSFieldWriter.build(gsField, ind + 1, 'item'));
      ret.push(`${indent}});`);
    } else if (field.isMap) {
      const typeArgs = field.typeArgumentTypes();
      const keyField = new GSField('', typeArgs[0]);
      const valueField = new GSField('', typeArgs[1]);

      ret.push(`${indent}writer.writeMap(`);
      ret.push(`${indent}  ${writeToArg},`);
      ret.push(`${indent}  (writer: Writer, key: ${keyField.typeNameWithTypeArg}): void => {`);
      ret.push(GSFieldWriter.build(keyField, ind + 2, 'key'));
      ret.push(`${indent}  },`);
      ret.push(`${indent}  (writer: Writer, value: ${valueField.typeNameWithTypeArg}): void => {`);
      ret.push(GSFieldWriter.build(valueField, ind + 2, 'value'));
      ret.push(`${indent}  }`);
      ret.push(`${indent});`);
    } else {
      ret.push(`${indent}changetype<${field.serializerClassName(true)}>(${writeToArg}).encode(writer);`);
    }

    if (!isNullableReference) {
      return ret.join('\n');
    }

    let nullable_check = [];
    nullable_check.push(`${indent}if (${writeToArg} === null) {`);
    nullable_check.push(`${indent}  writer.writeNil();`);
    nullable_check.push(`${indent}} else {`);
    nullable_check = nullable_check.concat(ret.map((line) => `  ${line}`));
    nullable_check.push(`${indent}}`);

    return nullable_check.join('\n');
  }

  private buildBasicField(ind: number, writeToArg: string): string {
    const indent = getIndentSpaces(ind);
    const writeFunction = this.getWriterFunction();
    return `${indent}writer.${writeFunction}(${writeToArg});`;
  }

  private getWriterFunction(): string {
    const kind = this.field.kind;
    switch (kind) {
      case TypeKind.I8:
        return `writeInt8`;
      case TypeKind.I16:
        return `writeInt16;`;
      case TypeKind.I32:
        return `writeInt32`;
      case TypeKind.I64:
        return `writeInt64`;
      case TypeKind.ISIZE:
        return `writeInt32`;
      case TypeKind.U8:
        return `writeUInt8`;
      case TypeKind.U16:
        return `writeUInt16`;
      case TypeKind.U32:
        return `writeUInt32`;
      case TypeKind.U64:
        return `writeUInt64`;
      case TypeKind.USIZE:
        return `writeUInt32`;
      case TypeKind.BOOL:
        return `writeBool`;
      case TypeKind.F32:
        return `writeFloat32`;
      case TypeKind.F64:
        return `writeFloat64`;
      // case TypeKind.V128: return "v128";
      // case TypeKind.FUNCREF: return "funcref";
      // case TypeKind.EXTERNREF: return "externref";
      // case TypeKind.EXNREF: return "exnref";
      // case TypeKind.ANYREF: return "anyref";
      // case TypeKind.VOID: return "void";
      default:
        throw new Error(`Unknown type kind: ${kind}`);
    }
  }
}
