import {strict as assert} from 'assert';
import {GSFieldReader} from './gs-field-reader';
import {GSClassField} from './gs-class-field';

export class GSClassFieldDecoder {
  static build(field: GSClassField): string {
    return new GSClassFieldDecoder(field).build();
  }

  constructor(private readonly field: GSClassField) {}

  private build(): string {
    const field = this.field;
    const ret: string[] = [];

    assert(!field.isExtendedArray, 'Types extend Array are not supported. Please use a wrapper type');

    const fields = field.getNonTransientFields();

    const allFields = field.getAllFields();
    const allFieldsWithDefaultValue = allFields
      .map((f) => {
        let s = `    let ${f.name}: ${f.typeNameWithTypeArg}`;
        const defaultValue = f.getDefaultValue();
        if (defaultValue) {
          return `${s} = ${defaultValue};`;
        } else {
          return `${s};`;
        }
      })
      .join('\n');

    const genericPrefix = this.field.typeArgumentTypes().length === 0 ? '' : '<T>';
    ret.push(`  static decode${genericPrefix}(__reader__: Decoder): ${this.field.serializerClassName()} {`);
    ret.push(`${allFieldsWithDefaultValue}\n`);
    ret.push(`    let __numFields__ = __reader__.readMapSize();`);
    ret.push(`    while (__numFields__ > 0) {`);
    ret.push(`      __numFields__--;`);
    ret.push(`      const __field__ = __reader__.readString();`);

    if (fields.length > 0) {
      fields.forEach((f, i) => {
        const fieldName = f.nameInSnakeCase;
        if (i === 0) {
          ret.push(`      if (__field__ == '${fieldName}') {`);
        } else {
          ret.push(`      } else if (__field__ == '${fieldName}') {`);
        }
        const indent = 4;
        ret.push(GSFieldReader.build(f, indent, `${f.name} =`));
      });

      ret.push(`      } else {`);
      ret.push(`        __reader__.skip();`);
      ret.push(`      }`);
    }
    ret.push(`    }`);
    ret.push(`    return {${allFields.map((f) => f.name).join(', ')}};`);
    ret.push(`  }`);

    return ret.join('\n');
  }
}
