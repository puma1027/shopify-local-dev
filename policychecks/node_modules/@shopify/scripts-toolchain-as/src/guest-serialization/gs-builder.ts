import {Program} from 'assemblyscript';
import {GSWalker} from './gs-walker';
import {GSClassField} from './gs-class-field';
import {GSClassFieldSerializer, GSOutputFieldSerializer} from './gs-class-field-serializer';

export class GSBuilder {
  static build(program: Program): string {
    const walker = new GSWalker(program);
    walker.walk();
    return new GSBuilder(walker.inputWrapper!, walker.outputWrapper!).build();
  }

  private constructor(private readonly inputWrapper: GSClassField, private readonly outputWrapper: GSClassField) {}

  private static readonly WARNING_HEADER = `\
// ===================================================================================
// THIS FILE IS GENERATED BY A CUSTOM CODE GENERATION TOOL. DO NOT MODIFY IT MANUALLY.
// TO UPDATE THIS FILE, RUN "npm run codegen"
// ===================================================================================
`;

  private build(): string {
    const content = [];
    const referencedClassFields = this.referencedClassFields();
    // console.log(`in GSBuilder#build(): referencedClassFields: ${referencedClassFields.map(f => f.typeName)}`);

    content.push(GSBuilder.WARNING_HEADER);

    // build import
    content.push(this.buildImport(referencedClassFields));

    // build entrypoint: wrapper()
    content.push(this.buildEntrypoint());

    // build Input, InputSerializer, Output and OutputSerializer
    content.push(this.buildIOWrapperAndSerializer());

    referencedClassFields.forEach((field) => {
      content.push('\n');
      content.push(GSClassFieldSerializer.build(field));
    });

    return content.join('');
  }

  private referencedClassFields(): GSClassField[] {
    const map = this.inputAndOutputClassFields().reduce((acc, field) => {
      field.referencedClassFields().forEach((field, name, _map) => {
        // The reason we `acc.has(name)` is that field.referencedClassFields is a deep and recursive
        // search on all referenced class fields, which makes it possible that two field reference
        // the same class field.
        if (!acc.has(name)) {
          acc.set(name, field);
        }
      });
      return acc;
    }, new Map() as Map<string, GSClassField>);

    return Array.from(map.values());
  }

  private inputAndOutputClassFields(): GSClassField[] {
    const classFields = this.inputWrapper
      .getNonTransientFields()
      .filter((f) => f.isClass)
      .map((f) => f.asClassField()!);

    const outputFields = this.outputWrapper.getNonTransientFields().filter((f) => f.isClass);
    if (outputFields.length == 0) {
      return classFields;
    } else if (outputFields.length > 1) {
      throw new Error('Output wrapper is not supposed to have more than one field');
    } else {
      const outputField = outputFields[0].asClassField()!;
      const typeNames = classFields.map((f) => f.typeNameWithTypeArg);
      if (!typeNames.includes(outputField.typeNameWithTypeArg)) {
        classFields.push(outputField);
      }
      return classFields;
    }
  }

  private buildImport(fields: GSClassField[]): string {
    return `\
import {Decoder, Encoder, Writer, Sizer} from '@shopify/scripts-sdk-as';
import {EPHandler} from './interface';
${this.buildImportForClassFields(fields)}
`;
  }

  // build import path for input and output classes
  private buildImportForClassFields(fields: GSClassField[]): string {
    const entries = Array.from(buildSourceToClassnamesMap(fields).entries());
    return entries
      .map(([source, typeNames]) => {
        return `import {${typeNames.join(', ')}} from '${source}';`;
      })
      .join('\n');
  }

  private buildEntrypoint(): string {
    const paramList = this.inputWrapper
      .getNonTransientFields()
      .map((field) => `input.${field.name}`)
      .join(', ');

    return `
export function wrapper(inputBuffer: ArrayBuffer): ArrayBuffer {
  const decoder = new Decoder(inputBuffer);
  const input = changetype<__Input>(__InputSerializer.decode(decoder));

  const ret = EPHandler(${paramList});
  const output = new __Output(ret);

  const serializer = changetype<${this.outputWrapper.serializerClassName()}>(output);
  const outputBufferLen = serializer.bufferLen();
  const outputBuffer = new ArrayBuffer(outputBufferLen);
  serializer.encode(new Encoder(outputBuffer));

  return outputBuffer;
}

`;
  }

  private buildIOWrapperAndSerializer(): string {
    const content = [];
    const inputWrapper = `class ${this.inputWrapper.typeName} {
${this.inputWrapper
  .getNonTransientFields()
  .map((field) => `  ${field.name}: ${field.typeNameWithTypeArg};`)
  .join('\n')}
}
`;
    content.push(inputWrapper);
    content.push(GSClassFieldSerializer.build(this.inputWrapper));

    const outputField = this.outputWrapper.getNonTransientFields()[0];
    const outputWrapper = `class ${this.outputWrapper.typeName} {
  ${outputField.name}: ${outputField.typeNameWithTypeArg};
  constructor(
    ${outputField.name}: ${outputField.typeNameWithTypeArg},
  ) {
    this.${outputField.name} = ${outputField.name};
  }
}
`;
    content.push(outputWrapper);
    content.push(GSOutputFieldSerializer.build(this.outputWrapper));
    return content.join('\n');
  }
}

function buildSourceToClassnamesMap(fields: GSClassField[]): Map<string, string[]> {
  const imports: Map<string, string[]> = new Map();
  fields.forEach((field) => {
    const source = field.source();
    const typeNames = imports.get(source) || [];
    typeNames.push(field.typeName);
    imports.set(source, typeNames);
  });
  return imports;
}
