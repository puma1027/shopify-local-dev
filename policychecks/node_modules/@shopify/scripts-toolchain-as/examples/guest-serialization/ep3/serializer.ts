// ===================================================================================
// THIS FILE IS GENERATED BY A CUSTOM CODE GENERATION TOOL. DO NOT MODIFY IT MANUALLY.
// TO UPDATE THIS FILE, RUN "npm run codegen"
// ===================================================================================
import {Decoder, Encoder, Writer, Sizer} from '@shopify/scripts-sdk-as';
import {EPHandler} from './interface';
import {Field, Tag, Fields} from './field';

export function wrapper(inputBuffer: ArrayBuffer): ArrayBuffer {
  const decoder = new Decoder(inputBuffer);
  const input = changetype<__Input>(__InputSerializer.decode(decoder));

  const ret = EPHandler(input.myField);
  const output = new __Output(ret);

  const serializer = changetype<__OutputSerializer>(output);
  const outputBufferLen = serializer.bufferLen();
  const outputBuffer = new ArrayBuffer(outputBufferLen);
  serializer.encode(new Encoder(outputBuffer));

  return outputBuffer;
}

class __Input {
  myField: Field;
}

class __InputSerializer {
  myField: Field = changetype<Field>(new FieldSerializer());

  bufferLen(): u32 {
    const sizer = new Sizer();
    this.encode(sizer);
    return sizer.length;
  }

  encode(writer: Writer): void {
    writer.writeMapSize(1);
    writer.writeString('my_field');
    changetype<FieldSerializer>(this.myField).encode(writer);
  }

  static decode(__reader__: Decoder): __InputSerializer {
    let myField: Field = changetype<Field>(new FieldSerializer());

    let __numFields__ = __reader__.readMapSize();
    while (__numFields__ > 0) {
      __numFields__--;
      const __field__ = __reader__.readString();
      if (__field__ == 'my_field') {
        myField = changetype<Field>(FieldSerializer.decode(__reader__));
      } else {
        __reader__.skip();
      }
    }
    return {myField};
  }
}

class __Output {
  inner: Fields;
  constructor(
    inner: Fields,
  ) {
    this.inner = inner;
  }
}

class __OutputSerializer {
  inner: Fields = changetype<Fields>(new FieldsSerializer());

  bufferLen(): u32 {
    const sizer = new Sizer();
    this.encode(sizer);
    return sizer.length;
  }

  encode(writer: Writer): void {
    changetype<FieldsSerializer>(this.inner).encode(writer);
  }
}

class FieldSerializer {
  num: i32;
  flag: bool;
  key: String = '';
  transientKey: String = '';
  listOfNum: Array<i32> = [];
  tag: Tag = changetype<Tag>(new TagSerializer());
  transientTag: Tag = changetype<Tag>(new TagSerializer());
  map: Map<String, i32> = new Map();
  mapOfArrayValue: Map<String, Array<i32>> = new Map();
  mapOfMapValue: Map<String, Map<String, i32>> = new Map();
  mapOfTag: Map<String, Tag> = new Map();
  numInt: i32;
  f: f32;

  bufferLen(): u32 {
    const sizer = new Sizer();
    this.encode(sizer);
    return sizer.length;
  }

  encode(writer: Writer): void {
    writer.writeMapSize(11);
    writer.writeString('num');
    writer.writeInt32(this.num);
    writer.writeString('flag');
    writer.writeBool(this.flag);
    writer.writeString('key');
    writer.writeString(this.key);
    writer.writeString('list_of_num');
    writer.writeArray(this.listOfNum, (writer: Writer, item: i32) => {
      writer.writeInt32(item);
    });
    writer.writeString('tag');
    changetype<TagSerializer>(this.tag).encode(writer);
    writer.writeString('map');
    writer.writeMap(
      this.map,
      (writer: Writer, key: String): void => {
        writer.writeString(key);
      },
      (writer: Writer, value: i32): void => {
        writer.writeInt32(value);
      }
    );
    writer.writeString('map_of_array_value');
    writer.writeMap(
      this.mapOfArrayValue,
      (writer: Writer, key: String): void => {
        writer.writeString(key);
      },
      (writer: Writer, value: Array<i32>): void => {
        writer.writeArray(value, (writer: Writer, item: i32) => {
          writer.writeInt32(item);
        });
      }
    );
    writer.writeString('map_of_map_value');
    writer.writeMap(
      this.mapOfMapValue,
      (writer: Writer, key: String): void => {
        writer.writeString(key);
      },
      (writer: Writer, value: Map<String, i32>): void => {
        writer.writeMap(
          value,
          (writer: Writer, key: String): void => {
            writer.writeString(key);
          },
          (writer: Writer, value: i32): void => {
            writer.writeInt32(value);
          }
        );
      }
    );
    writer.writeString('map_of_tag');
    writer.writeMap(
      this.mapOfTag,
      (writer: Writer, key: String): void => {
        writer.writeString(key);
      },
      (writer: Writer, value: Tag): void => {
        changetype<TagSerializer>(value).encode(writer);
      }
    );
    writer.writeString('num_int');
    writer.writeInt32(this.numInt);
    writer.writeString('f');
    writer.writeFloat32(this.f);
  }

  static decode(__reader__: Decoder): FieldSerializer {
    let num: i32;
    let flag: bool;
    let key: String = '';
    let transientKey: String = '';
    let listOfNum: Array<i32> = [];
    let tag: Tag = changetype<Tag>(new TagSerializer());
    let transientTag: Tag = changetype<Tag>(new TagSerializer());
    let map: Map<String, i32> = new Map();
    let mapOfArrayValue: Map<String, Array<i32>> = new Map();
    let mapOfMapValue: Map<String, Map<String, i32>> = new Map();
    let mapOfTag: Map<String, Tag> = new Map();
    let numInt: i32;
    let f: f32;

    let __numFields__ = __reader__.readMapSize();
    while (__numFields__ > 0) {
      __numFields__--;
      const __field__ = __reader__.readString();
      if (__field__ == 'num') {
        num = __reader__.readInt32();
      } else if (__field__ == 'flag') {
        flag = __reader__.readBool();
      } else if (__field__ == 'key') {
        key = __reader__.readString();
      } else if (__field__ == 'list_of_num') {
        listOfNum = __reader__.readArray((__reader__: Decoder): i32 => {
          return __reader__.readInt32();
        });
      } else if (__field__ == 'tag') {
        tag = changetype<Tag>(TagSerializer.decode(__reader__));
      } else if (__field__ == 'map') {
        map = __reader__.readMap(
          (__reader__: Decoder): String => {
            return __reader__.readString();
          },
          (__reader__: Decoder): i32 => {
            return __reader__.readInt32();
          },
        );
      } else if (__field__ == 'map_of_array_value') {
        mapOfArrayValue = __reader__.readMap(
          (__reader__: Decoder): String => {
            return __reader__.readString();
          },
          (__reader__: Decoder): Array<i32> => {
            return __reader__.readArray((__reader__: Decoder): i32 => {
              return __reader__.readInt32();
            });
          },
        );
      } else if (__field__ == 'map_of_map_value') {
        mapOfMapValue = __reader__.readMap(
          (__reader__: Decoder): String => {
            return __reader__.readString();
          },
          (__reader__: Decoder): Map<String, i32> => {
            return __reader__.readMap(
              (__reader__: Decoder): String => {
                return __reader__.readString();
              },
              (__reader__: Decoder): i32 => {
                return __reader__.readInt32();
              },
            );
          },
        );
      } else if (__field__ == 'map_of_tag') {
        mapOfTag = __reader__.readMap(
          (__reader__: Decoder): String => {
            return __reader__.readString();
          },
          (__reader__: Decoder): Tag => {
            return changetype<Tag>(TagSerializer.decode(__reader__));
          },
        );
      } else if (__field__ == 'num_int') {
        numInt = __reader__.readInt32();
      } else if (__field__ == 'f') {
        f = __reader__.readFloat32();
      } else {
        __reader__.skip();
      }
    }
    return {num, flag, key, transientKey, listOfNum, tag, transientTag, map, mapOfArrayValue, mapOfMapValue, mapOfTag, numInt, f};
  }
}

class TagSerializer {
  name: String = '';
  num: i32;

  bufferLen(): u32 {
    const sizer = new Sizer();
    this.encode(sizer);
    return sizer.length;
  }

  encode(writer: Writer): void {
    writer.writeMapSize(2);
    writer.writeString('name');
    writer.writeString(this.name);
    writer.writeString('num');
    writer.writeInt32(this.num);
  }

  static decode(__reader__: Decoder): TagSerializer {
    let name: String = '';
    let num: i32;

    let __numFields__ = __reader__.readMapSize();
    while (__numFields__ > 0) {
      __numFields__--;
      const __field__ = __reader__.readString();
      if (__field__ == 'name') {
        name = __reader__.readString();
      } else if (__field__ == 'num') {
        num = __reader__.readInt32();
      } else {
        __reader__.skip();
      }
    }
    return {name, num};
  }
}

class FieldsSerializer {
  fields: Array<Field> = [];

  bufferLen(): u32 {
    const sizer = new Sizer();
    this.encode(sizer);
    return sizer.length;
  }

  encode(writer: Writer): void {
    writer.writeMapSize(1);
    writer.writeString('fields');
    writer.writeArray(this.fields, (writer: Writer, item: Field) => {
      changetype<FieldSerializer>(item).encode(writer);
    });
  }

  static decode(__reader__: Decoder): FieldsSerializer {
    let fields: Array<Field> = [];

    let __numFields__ = __reader__.readMapSize();
    while (__numFields__ > 0) {
      __numFields__--;
      const __field__ = __reader__.readString();
      if (__field__ == 'fields') {
        fields = __reader__.readArray((__reader__: Decoder): Field => {
          return changetype<Field>(FieldSerializer.decode(__reader__));
        });
      } else {
        __reader__.skip();
      }
    }
    return {fields};
  }
}
