// ===================================================================================
// THIS FILE IS GENERATED BY A CUSTOM CODE GENERATION TOOL. DO NOT MODIFY IT MANUALLY.
// TO UPDATE THIS FILE, RUN "npm run codegen"
// ===================================================================================
import {Decoder, Encoder, Writer, Sizer} from '@shopify/scripts-sdk-as';
import {EPHandler} from './interface';
import {Key, Value} from './key';

export function wrapper(inputBuffer: ArrayBuffer): ArrayBuffer {
  const decoder = new Decoder(inputBuffer);
  const input = changetype<__Input>(__InputSerializer.decode(decoder));

  const ret = EPHandler(input.number, input.array, input.map, input.key, input.myMap, input.flag, input.setOfNumber, input.setOfKey);
  const output = new __Output(ret);

  const serializer = changetype<__OutputSerializer>(output);
  const outputBufferLen = serializer.bufferLen();
  const outputBuffer = new ArrayBuffer(outputBufferLen);
  serializer.encode(new Encoder(outputBuffer));

  return outputBuffer;
}

class __Input {
  number: i8;
  array: Array<Key>;
  map: Map<String, Value>;
  key: Key;
  myMap: Map<String, String>;
  flag: i32;
  setOfNumber: Set<i8>;
  setOfKey: Set<Key>;
}

class __InputSerializer {
  number: i8;
  array: Array<Key> = [];
  map: Map<String, Value> = new Map();
  key: Key = changetype<Key>(new KeySerializer());
  myMap: Map<String, String> = new Map();
  flag: i32;
  setOfNumber: Set<i8> = new Set();
  setOfKey: Set<Key> = new Set();

  bufferLen(): u32 {
    const sizer = new Sizer();
    this.encode(sizer);
    return sizer.length;
  }

  encode(writer: Writer): void {
    writer.writeMapSize(8);
    writer.writeString('number');
    writer.writeInt8(this.number);
    writer.writeString('array');
    writer.writeArray(this.array, (writer: Writer, item: Key) => {
      changetype<KeySerializer>(item).encode(writer);
    });
    writer.writeString('map');
    writer.writeMap(
      this.map,
      (writer: Writer, key: String): void => {
        writer.writeString(key);
      },
      (writer: Writer, value: Value): void => {
        changetype<ValueSerializer>(value).encode(writer);
      }
    );
    writer.writeString('key');
    changetype<KeySerializer>(this.key).encode(writer);
    writer.writeString('my_map');
    writer.writeMap(
      this.myMap,
      (writer: Writer, key: String): void => {
        writer.writeString(key);
      },
      (writer: Writer, value: String): void => {
        writer.writeString(value);
      }
    );
    writer.writeString('flag');
    writer.writeInt32(this.flag);
    writer.writeString('set_of_number');
    writer.writeArray(this.setOfNumber.values(), (writer: Writer, item: i8) => {
      writer.writeInt8(item);
    });
    writer.writeString('set_of_key');
    writer.writeArray(this.setOfKey.values(), (writer: Writer, item: Key) => {
      changetype<KeySerializer>(item).encode(writer);
    });
  }

  static decode(__reader__: Decoder): __InputSerializer {
    let number: i8;
    let array: Array<Key> = [];
    let map: Map<String, Value> = new Map();
    let key: Key = changetype<Key>(new KeySerializer());
    let myMap: Map<String, String> = new Map();
    let flag: i32;
    let setOfNumber: Set<i8> = new Set();
    let setOfKey: Set<Key> = new Set();

    let __numFields__ = __reader__.readMapSize();
    while (__numFields__ > 0) {
      __numFields__--;
      const __field__ = __reader__.readString();
      if (__field__ == 'number') {
        number = __reader__.readInt8();
      } else if (__field__ == 'array') {
        array = __reader__.readArray((__reader__: Decoder): Key => {
          return changetype<Key>(KeySerializer.decode(__reader__));
        });
      } else if (__field__ == 'map') {
        map = __reader__.readMap(
          (__reader__: Decoder): String => {
            return __reader__.readString();
          },
          (__reader__: Decoder): Value => {
            return changetype<Value>(ValueSerializer.decode(__reader__));
          },
        );
      } else if (__field__ == 'key') {
        key = changetype<Key>(KeySerializer.decode(__reader__));
      } else if (__field__ == 'my_map') {
        myMap = __reader__.readMap(
          (__reader__: Decoder): String => {
            return __reader__.readString();
          },
          (__reader__: Decoder): String => {
            return __reader__.readString();
          },
        );
      } else if (__field__ == 'flag') {
        flag = __reader__.readInt32();
      } else if (__field__ == 'set_of_number') {
        setOfNumber = ((__reader__: Decoder): Set<i8> => {
          let _set: Set<i8> = new Set();
          let _array = __reader__.readArray((__reader__: Decoder): i8 => {
            return __reader__.readInt8();
          });
          for (let i = 0; i < _array.length; i++) {
            _set.add(_array[i]);
          }
          return _set;
        })(__reader__);
      } else if (__field__ == 'set_of_key') {
        setOfKey = ((__reader__: Decoder): Set<Key> => {
          let _set: Set<Key> = new Set();
          let _array = __reader__.readArray((__reader__: Decoder): Key => {
            return changetype<Key>(KeySerializer.decode(__reader__));
          });
          for (let i = 0; i < _array.length; i++) {
            _set.add(_array[i]);
          }
          return _set;
        })(__reader__);
      } else {
        __reader__.skip();
      }
    }
    return {number, array, map, key, myMap, flag, setOfNumber, setOfKey};
  }
}

class __Output {
  inner: Set<Key>;
  constructor(
    inner: Set<Key>,
  ) {
    this.inner = inner;
  }
}

class __OutputSerializer {
  inner: Set<Key> = new Set();

  bufferLen(): u32 {
    const sizer = new Sizer();
    this.encode(sizer);
    return sizer.length;
  }

  encode(writer: Writer): void {
    writer.writeArray(this.inner.values(), (writer: Writer, item: Key) => {
      changetype<KeySerializer>(item).encode(writer);
    });
  }
}

class KeySerializer {
  name: String = '';
  transient: String = '';

  bufferLen(): u32 {
    const sizer = new Sizer();
    this.encode(sizer);
    return sizer.length;
  }

  encode(writer: Writer): void {
    writer.writeMapSize(1);
    writer.writeString('name');
    writer.writeString(this.name);
  }

  static decode(__reader__: Decoder): KeySerializer {
    let name: String = '';
    let transient: String = '';

    let __numFields__ = __reader__.readMapSize();
    while (__numFields__ > 0) {
      __numFields__--;
      const __field__ = __reader__.readString();
      if (__field__ == 'name') {
        name = __reader__.readString();
      } else {
        __reader__.skip();
      }
    }
    return {name, transient};
  }
}

class ValueSerializer {
  name: String = '';

  bufferLen(): u32 {
    const sizer = new Sizer();
    this.encode(sizer);
    return sizer.length;
  }

  encode(writer: Writer): void {
    writer.writeMapSize(1);
    writer.writeString('name');
    writer.writeString(this.name);
  }

  static decode(__reader__: Decoder): ValueSerializer {
    let name: String = '';

    let __numFields__ = __reader__.readMapSize();
    while (__numFields__ > 0) {
      __numFields__--;
      const __field__ = __reader__.readString();
      if (__field__ == 'name') {
        name = __reader__.readString();
      } else {
        __reader__.skip();
      }
    }
    return {name};
  }
}
