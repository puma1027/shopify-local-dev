// ===================================================================================
// THIS FILE IS GENERATED BY A CUSTOM CODE GENERATION TOOL. DO NOT MODIFY IT MANUALLY.
// TO UPDATE THIS FILE, RUN "npm run codegen"
// ===================================================================================
import {Decoder, Encoder, Writer, Sizer} from '@shopify/scripts-sdk-as';
import {EPHandler} from './interface';
import {Product, Variant, NestedValue} from './product';
import {LineItem} from './line_item';
import {Configuration} from './configuration';

export function wrapper(inputBuffer: ArrayBuffer): ArrayBuffer {
  const decoder = new Decoder(inputBuffer);
  const input = changetype<__Input>(__InputSerializer.decode(decoder));

  const ret = EPHandler(input.product, input.myConfig);
  const output = new __Output(ret);

  const serializer = changetype<__OutputSerializer>(output);
  const outputBufferLen = serializer.bufferLen();
  const outputBuffer = new ArrayBuffer(outputBufferLen);
  serializer.encode(new Encoder(outputBuffer));

  return outputBuffer;
}

class __Input {
  product: Product;
  myConfig: Configuration;
}

class __InputSerializer {
  product: Product = changetype<Product>(new ProductSerializer());
  myConfig: Configuration = changetype<Configuration>(new ConfigurationSerializer());

  bufferLen(): u32 {
    const sizer = new Sizer();
    this.encode(sizer);
    return sizer.length;
  }

  encode(writer: Writer): void {
    writer.writeMapSize(2);
    writer.writeString('product');
    changetype<ProductSerializer>(this.product).encode(writer);
    writer.writeString('my_config');
    changetype<ConfigurationSerializer>(this.myConfig).encode(writer);
  }

  static decode(__reader__: Decoder): __InputSerializer {
    let product: Product = changetype<Product>(new ProductSerializer());
    let myConfig: Configuration = changetype<Configuration>(new ConfigurationSerializer());

    let __numFields__ = __reader__.readMapSize();
    while (__numFields__ > 0) {
      __numFields__--;
      const __field__ = __reader__.readString();
      if (__field__ == 'product') {
        product = changetype<Product>(ProductSerializer.decode(__reader__));
      } else if (__field__ == 'my_config') {
        myConfig = changetype<Configuration>(ConfigurationSerializer.decode(__reader__));
      } else {
        __reader__.skip();
      }
    }
    return {product, myConfig};
  }
}

class __Output {
  inner: Product;
  constructor(
    inner: Product,
  ) {
    this.inner = inner;
  }
}

class __OutputSerializer {
  inner: Product = changetype<Product>(new ProductSerializer());

  bufferLen(): u32 {
    const sizer = new Sizer();
    this.encode(sizer);
    return sizer.length;
  }

  encode(writer: Writer): void {
    changetype<ProductSerializer>(this.inner).encode(writer);
  }
}

class ProductSerializer {
  implicitPublicField: i32;
  explicitPublicField: i32;
  privateField: i32;
  transientField: i32;
  i8: i8;
  i32: i32;
  i64: i64;
  isize: isize;
  u8: u8;
  u32: u32;
  u64: u64;
  usize: usize;
  bool: bool;
  f64: f64;
  str: String = '';
  variant: Variant = changetype<Variant>(new VariantSerializer());
  nestedValue: NestedValue = changetype<NestedValue>(new NestedValueSerializer());
  nullableField: Variant | null = null;
  arrayOfi32: Array<i32> = [];
  arrayOfString: Array<String> = [];
  arrayOfVariant: Array<Variant> = [];
  arrayOfLineItem: Array<LineItem> = [];
  arrayOfArrayOfVariant: Array<Array<Variant>> = [];
  arrayOfNullableVariant: Array<Variant | null> = [];

  bufferLen(): u32 {
    const sizer = new Sizer();
    this.encode(sizer);
    return sizer.length;
  }

  encode(writer: Writer): void {
    writer.writeMapSize(23);
    writer.writeString('implicit_public_field');
    writer.writeInt32(this.implicitPublicField);
    writer.writeString('explicit_public_field');
    writer.writeInt32(this.explicitPublicField);
    writer.writeString('private_field');
    writer.writeInt32(this.privateField);
    writer.writeString('i8');
    writer.writeInt8(this.i8);
    writer.writeString('i32');
    writer.writeInt32(this.i32);
    writer.writeString('i64');
    writer.writeInt64(this.i64);
    writer.writeString('isize');
    writer.writeInt32(this.isize);
    writer.writeString('u8');
    writer.writeUInt8(this.u8);
    writer.writeString('u32');
    writer.writeUInt32(this.u32);
    writer.writeString('u64');
    writer.writeUInt64(this.u64);
    writer.writeString('usize');
    writer.writeUInt32(this.usize);
    writer.writeString('bool');
    writer.writeBool(this.bool);
    writer.writeString('f64');
    writer.writeFloat64(this.f64);
    writer.writeString('str');
    writer.writeString(this.str);
    writer.writeString('variant');
    changetype<VariantSerializer>(this.variant).encode(writer);
    writer.writeString('nested_value');
    changetype<NestedValueSerializer>(this.nestedValue).encode(writer);
    writer.writeString('nullable_field');
    if (this.nullableField === null) {
      writer.writeNil();
    } else {
      changetype<VariantSerializer>(this.nullableField).encode(writer);
    }
    writer.writeString('array_ofi32');
    writer.writeArray(this.arrayOfi32, (writer: Writer, item: i32) => {
      writer.writeInt32(item);
    });
    writer.writeString('array_of_string');
    writer.writeArray(this.arrayOfString, (writer: Writer, item: String) => {
      writer.writeString(item);
    });
    writer.writeString('array_of_variant');
    writer.writeArray(this.arrayOfVariant, (writer: Writer, item: Variant) => {
      changetype<VariantSerializer>(item).encode(writer);
    });
    writer.writeString('array_of_line_item');
    writer.writeArray(this.arrayOfLineItem, (writer: Writer, item: LineItem) => {
      changetype<LineItemSerializer>(item).encode(writer);
    });
    writer.writeString('array_of_array_of_variant');
    writer.writeArray(this.arrayOfArrayOfVariant, (writer: Writer, item: Array<Variant>) => {
      writer.writeArray(item, (writer: Writer, item: Variant) => {
        changetype<VariantSerializer>(item).encode(writer);
      });
    });
    writer.writeString('array_of_nullable_variant');
    writer.writeArray(this.arrayOfNullableVariant, (writer: Writer, item: Variant | null) => {
      if (item === null) {
        writer.writeNil();
      } else {
        changetype<VariantSerializer>(item).encode(writer);
      }
    });
  }

  static decode(__reader__: Decoder): ProductSerializer {
    let implicitPublicField: i32;
    let explicitPublicField: i32;
    let privateField: i32;
    let transientField: i32;
    let i8: i8;
    let i32: i32;
    let i64: i64;
    let isize: isize;
    let u8: u8;
    let u32: u32;
    let u64: u64;
    let usize: usize;
    let bool: bool;
    let f64: f64;
    let str: String = '';
    let variant: Variant = changetype<Variant>(new VariantSerializer());
    let nestedValue: NestedValue = changetype<NestedValue>(new NestedValueSerializer());
    let nullableField: Variant | null = null;
    let arrayOfi32: Array<i32> = [];
    let arrayOfString: Array<String> = [];
    let arrayOfVariant: Array<Variant> = [];
    let arrayOfLineItem: Array<LineItem> = [];
    let arrayOfArrayOfVariant: Array<Array<Variant>> = [];
    let arrayOfNullableVariant: Array<Variant | null> = [];

    let __numFields__ = __reader__.readMapSize();
    while (__numFields__ > 0) {
      __numFields__--;
      const __field__ = __reader__.readString();
      if (__field__ == 'implicit_public_field') {
        implicitPublicField = __reader__.readInt32();
      } else if (__field__ == 'explicit_public_field') {
        explicitPublicField = __reader__.readInt32();
      } else if (__field__ == 'private_field') {
        privateField = __reader__.readInt32();
      } else if (__field__ == 'i8') {
        i8 = __reader__.readInt8();
      } else if (__field__ == 'i32') {
        i32 = __reader__.readInt32();
      } else if (__field__ == 'i64') {
        i64 = __reader__.readInt64();
      } else if (__field__ == 'isize') {
        isize = __reader__.readInt32();
      } else if (__field__ == 'u8') {
        u8 = __reader__.readUInt8();
      } else if (__field__ == 'u32') {
        u32 = __reader__.readUInt32();
      } else if (__field__ == 'u64') {
        u64 = __reader__.readUInt64();
      } else if (__field__ == 'usize') {
        usize = __reader__.readUInt32();
      } else if (__field__ == 'bool') {
        bool = __reader__.readBool();
      } else if (__field__ == 'f64') {
        f64 = __reader__.readFloat64();
      } else if (__field__ == 'str') {
        str = __reader__.readString();
      } else if (__field__ == 'variant') {
        variant = changetype<Variant>(VariantSerializer.decode(__reader__));
      } else if (__field__ == 'nested_value') {
        nestedValue = changetype<NestedValue>(NestedValueSerializer.decode(__reader__));
      } else if (__field__ == 'nullable_field') {
        if (__reader__.isNextNil()) {
          nullableField = null;
        } else {
          nullableField = changetype<Variant>(VariantSerializer.decode(__reader__));
        }
      } else if (__field__ == 'array_ofi32') {
        arrayOfi32 = __reader__.readArray((__reader__: Decoder): i32 => {
          return __reader__.readInt32();
        });
      } else if (__field__ == 'array_of_string') {
        arrayOfString = __reader__.readArray((__reader__: Decoder): String => {
          return __reader__.readString();
        });
      } else if (__field__ == 'array_of_variant') {
        arrayOfVariant = __reader__.readArray((__reader__: Decoder): Variant => {
          return changetype<Variant>(VariantSerializer.decode(__reader__));
        });
      } else if (__field__ == 'array_of_line_item') {
        arrayOfLineItem = __reader__.readArray((__reader__: Decoder): LineItem => {
          return changetype<LineItem>(LineItemSerializer.decode(__reader__));
        });
      } else if (__field__ == 'array_of_array_of_variant') {
        arrayOfArrayOfVariant = __reader__.readArray((__reader__: Decoder): Array<Variant> => {
          return __reader__.readArray((__reader__: Decoder): Variant => {
            return changetype<Variant>(VariantSerializer.decode(__reader__));
          });
        });
      } else if (__field__ == 'array_of_nullable_variant') {
        arrayOfNullableVariant = __reader__.readArray((__reader__: Decoder): Variant | null => {
          if (__reader__.isNextNil()) {
            return null;
          } else {
            return changetype<Variant>(VariantSerializer.decode(__reader__));
          }
        });
      } else {
        __reader__.skip();
      }
    }
    return {implicitPublicField, explicitPublicField, privateField, transientField, i8, i32, i64, isize, u8, u32, u64, usize, bool, f64, str, variant, nestedValue, nullableField, arrayOfi32, arrayOfString, arrayOfVariant, arrayOfLineItem, arrayOfArrayOfVariant, arrayOfNullableVariant};
  }
}

class VariantSerializer {
  i8: i8;
  u32: u32;
  bool: bool;
  f64: f64;
  lineItem: LineItem = changetype<LineItem>(new LineItemSerializer());

  bufferLen(): u32 {
    const sizer = new Sizer();
    this.encode(sizer);
    return sizer.length;
  }

  encode(writer: Writer): void {
    writer.writeMapSize(5);
    writer.writeString('i8');
    writer.writeInt8(this.i8);
    writer.writeString('u32');
    writer.writeUInt32(this.u32);
    writer.writeString('bool');
    writer.writeBool(this.bool);
    writer.writeString('f64');
    writer.writeFloat64(this.f64);
    writer.writeString('line_item');
    changetype<LineItemSerializer>(this.lineItem).encode(writer);
  }

  static decode(__reader__: Decoder): VariantSerializer {
    let i8: i8;
    let u32: u32;
    let bool: bool;
    let f64: f64;
    let lineItem: LineItem = changetype<LineItem>(new LineItemSerializer());

    let __numFields__ = __reader__.readMapSize();
    while (__numFields__ > 0) {
      __numFields__--;
      const __field__ = __reader__.readString();
      if (__field__ == 'i8') {
        i8 = __reader__.readInt8();
      } else if (__field__ == 'u32') {
        u32 = __reader__.readUInt32();
      } else if (__field__ == 'bool') {
        bool = __reader__.readBool();
      } else if (__field__ == 'f64') {
        f64 = __reader__.readFloat64();
      } else if (__field__ == 'line_item') {
        lineItem = changetype<LineItem>(LineItemSerializer.decode(__reader__));
      } else {
        __reader__.skip();
      }
    }
    return {i8, u32, bool, f64, lineItem};
  }
}

class LineItemSerializer {
  i8: i8;

  bufferLen(): u32 {
    const sizer = new Sizer();
    this.encode(sizer);
    return sizer.length;
  }

  encode(writer: Writer): void {
    writer.writeMapSize(1);
    writer.writeString('i8');
    writer.writeInt8(this.i8);
  }

  static decode(__reader__: Decoder): LineItemSerializer {
    let i8: i8;

    let __numFields__ = __reader__.readMapSize();
    while (__numFields__ > 0) {
      __numFields__--;
      const __field__ = __reader__.readString();
      if (__field__ == 'i8') {
        i8 = __reader__.readInt8();
      } else {
        __reader__.skip();
      }
    }
    return {i8};
  }
}

class NestedValueSerializer {
  inner: i8;

  bufferLen(): u32 {
    const sizer = new Sizer();
    this.encode(sizer);
    return sizer.length;
  }

  encode(writer: Writer): void {
    writer.writeMapSize(1);
    writer.writeString('inner');
    writer.writeInt8(this.inner);
  }

  static decode(__reader__: Decoder): NestedValueSerializer {
    let inner: i8;

    let __numFields__ = __reader__.readMapSize();
    while (__numFields__ > 0) {
      __numFields__--;
      const __field__ = __reader__.readString();
      if (__field__ == 'inner') {
        inner = __reader__.readInt8();
      } else {
        __reader__.skip();
      }
    }
    return {inner};
  }
}

class ConfigurationSerializer {
  key: String = '';
  value: String = '';

  bufferLen(): u32 {
    const sizer = new Sizer();
    this.encode(sizer);
    return sizer.length;
  }

  encode(writer: Writer): void {
    writer.writeMapSize(2);
    writer.writeString('key');
    writer.writeString(this.key);
    writer.writeString('value');
    writer.writeString(this.value);
  }

  static decode(__reader__: Decoder): ConfigurationSerializer {
    let key: String = '';
    let value: String = '';

    let __numFields__ = __reader__.readMapSize();
    while (__numFields__ > 0) {
      __numFields__--;
      const __field__ = __reader__.readString();
      if (__field__ == 'key') {
        key = __reader__.readString();
      } else if (__field__ == 'value') {
        value = __reader__.readString();
      } else {
        __reader__.skip();
      }
    }
    return {key, value};
  }
}
