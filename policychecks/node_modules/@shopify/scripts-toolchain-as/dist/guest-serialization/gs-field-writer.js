"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GSFieldWriter = void 0;
const gs_field_1 = require("./gs-field");
const utility_1 = require("./utility");
// This class genereates the specific writer block for an encoder
//
// eg. for a field of type: i8
//
// GSFieldWriter.build(field, 0, "a")   => "writer.writeInt8(a);"
// GSFieldWriter.build(field, 2, "foo") => "    writer.writeInt8(foo);"
//
// eg. for a field of type Array<i8>: GSFieldWriter.build(field, 0, "a") =>
//
// writer.writeArray(a, (writer: Writer, item: i8) => {
//   writer.writeInt8(a);
// });
//
// eg. for a field of type Map<i8, string>: GSFieldWriter.build(field, 0, "a") =>
//
// writer.writeMap(
//   a,
//   (writer: Writer, key: i8): void => {
//     writer.writeInt8(key);
//   },
//   (writer: Writer, value: string) => {
//     writer.writeString(value);
//   }
// );
//
// eg. for a field of type Foo which extends Array<i8>: GSFieldWriter.build(field, 0, "a") =>
//
// writer.writeArray(a, (writer: Writer, item: i8) => {
//   writer.writeInt8(a);
// });
//
// eg. for a field of type Bar: GSFieldWriter.build(field, 0, "a") =>
//
// (new BarSerializer(a)).encode(writer);
//
// eg. for a field of type Bar | null: GSFieldWriter.build(field, 0, "a") =>
//
// if (a === null) {
//   writer.writeNil();
// else {
//   (new BarSerializer(a)).encode(writer);
// }
class GSFieldWriter {
    constructor(field) {
        this.field = field;
    }
    static build(field, indent, writeToArg) {
        return new GSFieldWriter(field).build(indent, writeToArg);
    }
    build(indent, writeToArg) {
        if (this.field.isClass) {
            return this.buildClassField(indent, writeToArg);
        }
        else {
            return this.buildBasicField(indent, writeToArg);
        }
    }
    buildClassField(ind, writeToArg) {
        const indent = utility_1.getIndentSpaces(ind);
        const field = this.field.asClassField();
        const isNullableReference = this.field.isNullableReference;
        const nullableSuffix = isNullableReference ? '!' : '';
        const ret = [];
        if (field.isString) {
            ret.push(`${indent}writer.writeString(${writeToArg}${nullableSuffix});`);
        }
        else if (field.isArray || field.isSet) {
            const typeArg = field.typeArgumentTypes()[0];
            const typeArgDeclarationName = new gs_field_1.GSField('', typeArg).typeNameWithTypeArg;
            let argName = writeToArg;
            if (field.isSet) {
                argName = `${argName}.values()`;
            }
            ret.push(`${indent}writer.writeArray(${argName}${nullableSuffix}, (writer: Writer, item: ${typeArgDeclarationName}) => {`);
            const gsField = new gs_field_1.GSField('item', typeArg);
            ret.push(GSFieldWriter.build(gsField, ind + 1, 'item'));
            ret.push(`${indent}});`);
        }
        else if (field.isMap) {
            const typeArgs = field.typeArgumentTypes();
            const keyField = new gs_field_1.GSField('', typeArgs[0]);
            const valueField = new gs_field_1.GSField('', typeArgs[1]);
            ret.push(`${indent}writer.writeMap(`);
            ret.push(`${indent}  ${writeToArg},`);
            ret.push(`${indent}  (writer: Writer, key: ${keyField.typeNameWithTypeArg}): void => {`);
            ret.push(GSFieldWriter.build(keyField, ind + 2, 'key'));
            ret.push(`${indent}  },`);
            ret.push(`${indent}  (writer: Writer, value: ${valueField.typeNameWithTypeArg}): void => {`);
            ret.push(GSFieldWriter.build(valueField, ind + 2, 'value'));
            ret.push(`${indent}  }`);
            ret.push(`${indent});`);
        }
        else {
            ret.push(`${indent}changetype<${field.serializerClassName(true)}>(${writeToArg}).encode(writer);`);
        }
        if (!isNullableReference) {
            return ret.join('\n');
        }
        let nullable_check = [];
        nullable_check.push(`${indent}if (${writeToArg} === null) {`);
        nullable_check.push(`${indent}  writer.writeNil();`);
        nullable_check.push(`${indent}} else {`);
        nullable_check = nullable_check.concat(ret.map((line) => `  ${line}`));
        nullable_check.push(`${indent}}`);
        return nullable_check.join('\n');
    }
    buildBasicField(ind, writeToArg) {
        const indent = utility_1.getIndentSpaces(ind);
        const writeFunction = this.getWriterFunction();
        return `${indent}writer.${writeFunction}(${writeToArg});`;
    }
    getWriterFunction() {
        const kind = this.field.kind;
        switch (kind) {
            case 0 /* I8 */:
                return `writeInt8`;
            case 1 /* I16 */:
                return `writeInt16;`;
            case 2 /* I32 */:
                return `writeInt32`;
            case 3 /* I64 */:
                return `writeInt64`;
            case 4 /* ISIZE */:
                return `writeInt32`;
            case 5 /* U8 */:
                return `writeUInt8`;
            case 6 /* U16 */:
                return `writeUInt16`;
            case 7 /* U32 */:
                return `writeUInt32`;
            case 8 /* U64 */:
                return `writeUInt64`;
            case 9 /* USIZE */:
                return `writeUInt32`;
            case 10 /* BOOL */:
                return `writeBool`;
            case 11 /* F32 */:
                return `writeFloat32`;
            case 12 /* F64 */:
                return `writeFloat64`;
            // case TypeKind.V128: return "v128";
            // case TypeKind.FUNCREF: return "funcref";
            // case TypeKind.EXTERNREF: return "externref";
            // case TypeKind.EXNREF: return "exnref";
            // case TypeKind.ANYREF: return "anyref";
            // case TypeKind.VOID: return "void";
            default:
                throw new Error(`Unknown type kind: ${kind}`);
        }
    }
}
exports.GSFieldWriter = GSFieldWriter;
//# sourceMappingURL=gs-field-writer.js.map