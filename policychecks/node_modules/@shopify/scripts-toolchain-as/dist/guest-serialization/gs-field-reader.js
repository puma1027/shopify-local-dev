"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GSFieldReader = void 0;
const assert_1 = require("assert");
const gs_field_1 = require("./gs-field");
const utility_1 = require("./utility");
// This class genereates the specific reader block for a decoder
//
// eg. for a field of type: i8
//
// GSFieldReader.build(field, 0, "a =")     => "a = reader.readInt8();"
// GSFieldReader.build(field, 2, "return")  => "    return reader.readInt8();"
//
// eg. for a field of type Array<i8>: GSFieldReader.build(field, 0, "a =") =>
//
// a = reader.readArray((reader: Decoder): i32 => {
//   return reader.readInt8();
// });
//
// eg. for a field of type Map<i8, string>: GSFieldReader.build(field, 0, "a =") =>
//
// a = reader.readMap(
//  (reader: Decoder): i8 => {
//    return reader.readInt8();
//  },
//  (reader: Decoder): string => {
//    return reader.readString();
//  }
// );
//
// eg. for a field of type Foo, which extends Array<i8>: GSFieldReader.build(field, 0, "a =") =>
//
// a = Foo.from(reader.readArray((reader: Decoder): i32 => {
//   return reader.readInt8();
// }));
//
// eg. for a field of type Bar: GSFieldReader.build(field, 0, "a =") =>
//
// a = (function(reader: Decoder): Bar {
//   let v = new Bar();
//   const serializer = new BarSerializer(v);
//   serializer.decode(reader);
//   return v;
// })(reader);
//
// eg. for a field of type Bar | null: GSFieldReader.build(field, 0, "a =")
//
// => (quotes ignored)
//
// if (reader.isNextNil()) {
//   a = null;
// else {
//   a = (function(reader: Decoder): Bar {
//     let v = new Bar();
//     const serializer = new BarSerializer(v);
//     serializer.decode(reader);
//     return v;
//   })(reader);
// }
//
class GSFieldReader {
    constructor(field) {
        this.field = field;
    }
    static build(field, indent, readToArg) {
        return new GSFieldReader(field).build(indent, readToArg);
    }
    build(indent, readToArg) {
        if (this.field.isClass) {
            return this.buildClassField(indent, readToArg);
        }
        else {
            return this.buildBasicField(indent, readToArg);
        }
    }
    buildClassField(ind, readToArg) {
        const indent = utility_1.getIndentSpaces(ind);
        const field = this.field.asClassField();
        const isNullableReference = this.field.isNullableReference;
        let ret = [];
        assert_1.strict(!field.isExtendedArray, 'Types extend Array are not supported. Please use a wrapper type');
        if (field.isString) {
            ret.push(`${indent}${readToArg} __reader__.readString();`);
        }
        else if (field.isArray) {
            ret = ret.concat(buildArrayField(field, ind, readToArg));
        }
        else if (field.isSet) {
            ret = ret.concat(buildSetField(field, ind, readToArg));
        }
        else if (field.isMap) {
            ret = ret.concat(buildMapField(field, ind, readToArg));
        }
        else {
            ret = ret.concat(buildNormalClassField(field, ind, readToArg));
        }
        if (!isNullableReference) {
            return ret.join('\n');
        }
        let nullableCheck = [];
        nullableCheck.push(`${indent}if (__reader__.isNextNil()) {`);
        nullableCheck.push(`${indent}  ${readToArg} null;`);
        nullableCheck.push(`${indent}} else {`);
        nullableCheck = nullableCheck.concat(ret.map((line) => `  ${line}`));
        nullableCheck.push(`${indent}}`);
        return nullableCheck.join('\n');
    }
    buildBasicField(ind, readToArg) {
        const indent = utility_1.getIndentSpaces(ind);
        const decodeFunction = this.getReaderFunction();
        return `${indent}${readToArg} __reader__.${decodeFunction}();`;
    }
    getReaderFunction() {
        const kind = this.field.kind;
        switch (kind) {
            case 0 /* I8 */:
                return `readInt8`;
            case 1 /* I16 */:
                return `readInt16`;
            case 2 /* I32 */:
                return `readInt32`;
            case 3 /* I64 */:
                return `readInt64`;
            case 4 /* ISIZE */:
                return `readInt32`;
            case 5 /* U8 */:
                return `readUInt8`;
            case 6 /* U16 */:
                return `readUInt16`;
            case 7 /* U32 */:
                return `readUInt32`;
            case 8 /* U64 */:
                return `readUInt64`;
            case 9 /* USIZE */:
                return `readUInt32`;
            case 10 /* BOOL */:
                return `readBool`;
            case 11 /* F32 */:
                return `readFloat32`;
            case 12 /* F64 */:
                return `readFloat64`;
            // Note: Not needed now
            //
            // case TypeKind.V128: return "v128";
            // case TypeKind.FUNCREF: return "funcref";
            // case TypeKind.EXTERNREF: return "externref";
            // case TypeKind.EXNREF: return "exnref";
            // case TypeKind.ANYREF: return "anyref";
            // case TypeKind.VOID: return "void";
            default:
                throw new Error(`Unknown type kind: ${kind}`);
        }
    }
}
exports.GSFieldReader = GSFieldReader;
function buildArrayField(field, ind, readToArg) {
    const ret = [];
    const indent = utility_1.getIndentSpaces(ind);
    const typeArg = field.typeArgumentTypes()[0];
    const typeArgDeclarationName = new gs_field_1.GSField('', typeArg).typeNameWithTypeArg;
    ret.push(`${indent}${readToArg} __reader__.readArray((__reader__: Decoder): ${typeArgDeclarationName} => {`);
    const gsField = new gs_field_1.GSField('', typeArg);
    ret.push(GSFieldReader.build(gsField, ind + 1, 'return'));
    ret.push(`${indent}});`);
    return ret;
}
function buildSetField(field, ind, readToArg) {
    const ret = [];
    const indent = utility_1.getIndentSpaces(ind);
    const typeArg = field.typeArgumentTypes()[0];
    const typeArgDeclarationName = new gs_field_1.GSField('', typeArg).typeNameWithTypeArg;
    ret.push(`${indent}${readToArg} ((__reader__: Decoder): ${field.typeNameWithTypeArg} => {`);
    ret.push(`${indent}  let _set: ${field.typeNameWithTypeArg} = new Set();`);
    ret.push(`${indent}  let _array = __reader__.readArray((__reader__: Decoder): ${typeArgDeclarationName} => {`);
    const gsField = new gs_field_1.GSField('', typeArg);
    ret.push(GSFieldReader.build(gsField, ind + 2, 'return'));
    ret.push(`${indent}  });`);
    ret.push(`${indent}  for (let i = 0; i < _array.length; i++) {`);
    ret.push(`${indent}    _set.add(_array[i]);`);
    ret.push(`${indent}  }`);
    ret.push(`${indent}  return _set;`);
    ret.push(`${indent}})(__reader__);`);
    return ret;
}
function buildMapField(field, ind, readToArg) {
    const ret = [];
    const indent = utility_1.getIndentSpaces(ind);
    const typeArgumentTypes = field.typeArgumentTypes();
    ret.push(`${indent}${readToArg} __reader__.readMap(`);
    const keyArgType = typeArgumentTypes[0];
    const keyGSField = new gs_field_1.GSField('', keyArgType);
    ret.push(`${indent}  (__reader__: Decoder): ${keyGSField.typeNameWithTypeArg} => {`);
    ret.push(GSFieldReader.build(keyGSField, ind + 2, 'return'));
    ret.push(`${indent}  },`);
    const valueArgType = typeArgumentTypes[1];
    const valueGSField = new gs_field_1.GSField('', valueArgType);
    ret.push(`${indent}  (__reader__: Decoder): ${valueGSField.typeNameWithTypeArg} => {`);
    ret.push(GSFieldReader.build(valueGSField, ind + 2, 'return'));
    ret.push(`${indent}  },`);
    ret.push(`${indent});`);
    return ret;
}
function buildNormalClassField(field, ind, readToArg) {
    const ret = [];
    const indent = utility_1.getIndentSpaces(ind);
    const typeName = field.typeName;
    const serializerClassName = field.serializerClassName();
    const boxSuffix = field.isBox ? `<${field.boxOf}>` : '';
    ret.push(`${indent}${readToArg} changetype<${typeName}${boxSuffix}>(${serializerClassName}.decode${boxSuffix}(__reader__));`);
    return ret;
}
//# sourceMappingURL=gs-field-reader.js.map