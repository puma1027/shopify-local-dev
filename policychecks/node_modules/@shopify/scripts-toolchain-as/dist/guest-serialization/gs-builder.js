"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GSBuilder = void 0;
const gs_walker_1 = require("./gs-walker");
const gs_class_field_serializer_1 = require("./gs-class-field-serializer");
let GSBuilder = /** @class */ (() => {
    class GSBuilder {
        constructor(inputWrapper, outputWrapper) {
            this.inputWrapper = inputWrapper;
            this.outputWrapper = outputWrapper;
        }
        static build(program) {
            const walker = new gs_walker_1.GSWalker(program);
            walker.walk();
            return new GSBuilder(walker.inputWrapper, walker.outputWrapper).build();
        }
        build() {
            const content = [];
            const referencedClassFields = this.referencedClassFields();
            // console.log(`in GSBuilder#build(): referencedClassFields: ${referencedClassFields.map(f => f.typeName)}`);
            content.push(GSBuilder.WARNING_HEADER);
            // build import
            content.push(this.buildImport(referencedClassFields));
            // build entrypoint: wrapper()
            content.push(this.buildEntrypoint());
            // build Input, InputSerializer, Output and OutputSerializer
            content.push(this.buildIOWrapperAndSerializer());
            referencedClassFields.forEach((field) => {
                content.push('\n');
                content.push(gs_class_field_serializer_1.GSClassFieldSerializer.build(field));
            });
            return content.join('');
        }
        referencedClassFields() {
            const map = this.inputAndOutputClassFields().reduce((acc, field) => {
                field.referencedClassFields().forEach((field, name, _map) => {
                    // The reason we `acc.has(name)` is that field.referencedClassFields is a deep and recursive
                    // search on all referenced class fields, which makes it possible that two field reference
                    // the same class field.
                    if (!acc.has(name)) {
                        acc.set(name, field);
                    }
                });
                return acc;
            }, new Map());
            return Array.from(map.values());
        }
        inputAndOutputClassFields() {
            const classFields = this.inputWrapper
                .getNonTransientFields()
                .filter((f) => f.isClass)
                .map((f) => f.asClassField());
            const outputFields = this.outputWrapper.getNonTransientFields().filter((f) => f.isClass);
            if (outputFields.length == 0) {
                return classFields;
            }
            else if (outputFields.length > 1) {
                throw new Error('Output wrapper is not supposed to have more than one field');
            }
            else {
                const outputField = outputFields[0].asClassField();
                const typeNames = classFields.map((f) => f.typeNameWithTypeArg);
                if (!typeNames.includes(outputField.typeNameWithTypeArg)) {
                    classFields.push(outputField);
                }
                return classFields;
            }
        }
        buildImport(fields) {
            return `\
import {Decoder, Encoder, Writer, Sizer} from '@shopify/scripts-sdk-as';
import {EPHandler} from './interface';
${this.buildImportForClassFields(fields)}
`;
        }
        // build import path for input and output classes
        buildImportForClassFields(fields) {
            const entries = Array.from(buildSourceToClassnamesMap(fields).entries());
            return entries
                .map(([source, typeNames]) => {
                return `import {${typeNames.join(', ')}} from '${source}';`;
            })
                .join('\n');
        }
        buildEntrypoint() {
            const paramList = this.inputWrapper
                .getNonTransientFields()
                .map((field) => `input.${field.name}`)
                .join(', ');
            return `
export function wrapper(inputBuffer: ArrayBuffer): ArrayBuffer {
  const decoder = new Decoder(inputBuffer);
  const input = changetype<__Input>(__InputSerializer.decode(decoder));

  const ret = EPHandler(${paramList});
  const output = new __Output(ret);

  const serializer = changetype<${this.outputWrapper.serializerClassName()}>(output);
  const outputBufferLen = serializer.bufferLen();
  const outputBuffer = new ArrayBuffer(outputBufferLen);
  serializer.encode(new Encoder(outputBuffer));

  return outputBuffer;
}

`;
        }
        buildIOWrapperAndSerializer() {
            const content = [];
            const inputWrapper = `class ${this.inputWrapper.typeName} {
${this.inputWrapper
                .getNonTransientFields()
                .map((field) => `  ${field.name}: ${field.typeNameWithTypeArg};`)
                .join('\n')}
}
`;
            content.push(inputWrapper);
            content.push(gs_class_field_serializer_1.GSClassFieldSerializer.build(this.inputWrapper));
            const outputField = this.outputWrapper.getNonTransientFields()[0];
            const outputWrapper = `class ${this.outputWrapper.typeName} {
  ${outputField.name}: ${outputField.typeNameWithTypeArg};
  constructor(
    ${outputField.name}: ${outputField.typeNameWithTypeArg},
  ) {
    this.${outputField.name} = ${outputField.name};
  }
}
`;
            content.push(outputWrapper);
            content.push(gs_class_field_serializer_1.GSOutputFieldSerializer.build(this.outputWrapper));
            return content.join('\n');
        }
    }
    GSBuilder.WARNING_HEADER = `\
// ===================================================================================
// THIS FILE IS GENERATED BY A CUSTOM CODE GENERATION TOOL. DO NOT MODIFY IT MANUALLY.
// TO UPDATE THIS FILE, RUN "npm run codegen"
// ===================================================================================
`;
    return GSBuilder;
})();
exports.GSBuilder = GSBuilder;
function buildSourceToClassnamesMap(fields) {
    const imports = new Map();
    fields.forEach((field) => {
        const source = field.source();
        const typeNames = imports.get(source) || [];
        typeNames.push(field.typeName);
        imports.set(source, typeNames);
    });
    return imports;
}
//# sourceMappingURL=gs-builder.js.map