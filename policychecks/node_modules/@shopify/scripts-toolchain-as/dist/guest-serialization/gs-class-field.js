"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GSClassField = void 0;
const assert_1 = require("assert");
const assemblyscript_1 = require("assemblyscript");
const path = __importStar(require("path"));
const gs_field_1 = require("./gs-field");
const utility_1 = require("./utility");
const STANDARD_LIB_TYPES = ['ArrayBuffer'];
class GSClassField {
    constructor(name, type, alias = null) {
        this.name = name;
        this.type = type;
        this.alias = alias;
        assert_1.strict(type.isClass, 'GSClassField only takes type of class');
        this.reference = type.getClass();
    }
    get isNullableReference() {
        return this.type.isNullableReference;
    }
    get nameInSnakeCase() {
        const name = this.alias ? this.alias : this.name;
        return utility_1.toSnakeCase(name);
    }
    get isString() {
        return this.typeName == 'String';
    }
    get isArrayLike() {
        return this.reference.isArrayLike;
    }
    get isArray() {
        return this.isArrayLike && this.typeName === 'Array';
    }
    get isExtendedArray() {
        return this.isArrayLike && this.baseClassName === 'Array';
    }
    get isSet() {
        return this.typeName == 'Set';
    }
    get isMap() {
        if (this.typeName !== 'Map') {
            return false;
        }
        const typeArguments = this.reference.typeArguments;
        const keyArg = new gs_field_1.GSField('', typeArguments[0]);
        if (keyArg.isClass && keyArg.asClassField().isString) {
            return true;
        }
        else {
            throw new Error(`Key type of Map ${this.name} is not String`);
        }
    }
    get isBox() {
        return this.reference.internalName.startsWith('~lib/@shopify/scripts-sdk-as/Box');
    }
    get boxOf() {
        if (!this.isBox) {
            return null;
        }
        return this.reference.internalName.replace('~lib/@shopify/scripts-sdk-as/Box/Box', '').replace(/[<>]/g, '');
    }
    get typeName() {
        return this.reference.prototype.name;
    }
    get typeNameWithTypeArg() {
        const nullableSuffix = this.isNullableReference ? ' | null' : '';
        const typeArguments = this.typeArgumentTypes();
        let name;
        if (this.isArray) {
            const typeArg = new gs_field_1.GSField('', typeArguments[0]);
            name = `Array<${typeArg.typeNameWithTypeArg}>`;
        }
        else if (this.isSet) {
            const typeArg = new gs_field_1.GSField('', typeArguments[0]);
            name = `Set<${typeArg.typeNameWithTypeArg}>`;
        }
        else if (this.isString) {
            name = 'String';
        }
        else if (this.isMap) {
            const keyArg = new gs_field_1.GSField('', typeArguments[0]);
            const valueArg = new gs_field_1.GSField('', typeArguments[1]);
            return `Map<${keyArg.typeNameWithTypeArg}, ${valueArg.typeNameWithTypeArg}>`;
        }
        else {
            if (typeArguments.length === 0) {
                name = this.typeName;
            }
            else if (typeArguments.length === 1) {
                const typeArg = new gs_field_1.GSField('', typeArguments[0]);
                name = `${this.typeName}<${typeArg.typeNameWithTypeArg}>`;
            }
            else {
                throw new Error(`Class type with more than 2 type arguments is not supported: ${this.typeName}`);
            }
        }
        return `${name}${nullableSuffix}`;
    }
    get baseClassName() {
        const basePrototype = this.reference.prototype.basePrototype;
        if (!basePrototype) {
            return '';
        }
        else {
            return basePrototype.name;
        }
    }
    // The method calculates the import path of the referenced class.
    //
    // Note: I couldn't find a proper way but to parse from the internalName defined in "src/program.ts/Element"
    //
    // Example 1: given internalName for Console is "~lib/as-wasi/as-wasi/Console", the method returns
    // import {Console} from "as-wasi";
    //
    // Example 2: given internalName for Product is "src/product/Product", the method returns
    // import {Product} from "./product";
    //
    // Example 3: given internalName for Array<Field> is "~lib/array/Array<src/field/Field>", the method returns
    // import {Field} from "./field";
    source() {
        let currentType = this.type;
        while (true) {
            const field = new GSClassField('', currentType);
            if (field.isArray || field.isSet) {
                const typeArg = field.typeArgumentTypes()[0];
                if (!typeArg.isClass) {
                    return '';
                }
                currentType = typeArg;
            }
            else if (field.isMap) {
                // keyArg (typeArgs[0]) is already asserted to be String
                const typeArg = field.typeArgumentTypes()[1];
                if (!typeArg.isClass) {
                    return '';
                }
                currentType = typeArg;
            }
            else {
                break;
            }
        }
        const field = new GSClassField('', currentType);
        const internalName = field.reference.internalName;
        const parts = internalName.split('/');
        let typeName = parts.pop();
        let typeDeclaration = field.typeNameWithTypeArg;
        if (field.isNullableReference) {
            typeName = typeName + ' | null';
        }
        assert_1.strict(typeName === typeDeclaration, `Cannot infer source for: typeName ${typeName} typeDdeclaration: ${typeDeclaration}`);
        if (parts[0] == '~lib') {
            parts.pop(); // pop file name
            parts.shift(); // pop ~lib
            return parts.join('/');
        }
        else {
            const source = parts.join('/');
            const sourceFile = path.join(process.cwd(), source);
            const targetDir = GSClassField.serializerDir;
            const prefix = './';
            return prefix + path.relative(targetDir, sourceFile);
        }
    }
    typeArgumentTypes() {
        assert_1.strict(!this.isExtendedArray, 'Types extend Array are not supported. Please use a wrapper type');
        if (!this.reference.typeArguments) {
            return [];
        }
        const typeArguments = this.reference.typeArguments;
        if (this.isMap) {
            assert_1.strict(typeArguments.length == 2, 'Two type args are required for Map<K,V>');
        }
        else {
            assert_1.strict(typeArguments.length == 1, 'Only one type arg for Array<T> or custom class is supported');
        }
        return typeArguments;
    }
    serializerClassName(withGeneric = false) {
        let s = `${this.typeName}Serializer`;
        if (withGeneric && this.isBox) {
            s = `${s}<${this.boxOf}>`;
        }
        return s;
    }
    getAllFields() {
        const gsFields = [];
        const uniqueNames = [];
        this.reference.members.forEach((field, _name, _map) => {
            if (field.kind == assemblyscript_1.ElementKind.FIELD) {
                // `field` is of generic type `DeclaredElement`. We have to cast to a specific
                // element type so that the `field.type` can work as expected.
                const f = field;
                const alias = utility_1.parseAlias(f);
                const isTransient = utility_1.parseTransient(f);
                const gsField = new gs_field_1.GSField(f.name, f.type, alias, isTransient);
                const name = gsField.nameInSnakeCase;
                if (uniqueNames.includes(name)) {
                    throw new Error(`Duplicated field name/alias '${name}' detected in ${this.typeName}`);
                }
                else {
                    uniqueNames.push(name);
                }
                gsFields.push(gsField);
            }
        });
        return gsFields;
    }
    getNonTransientFields() {
        return this.getAllFields().filter((f) => !f.isTransient);
    }
    // It properly handles cyclic referenced types
    referencedClassFields() {
        const ret = new Map();
        if (STANDARD_LIB_TYPES.includes(this.typeName)) {
            return ret;
        }
        else if (this.isString) {
            return ret;
        }
        else if (this.isArray || this.isSet) {
            const argType = this.typeArgumentTypes()[0];
            if (argType.isClass) {
                return new GSClassField('', argType).referencedClassFields();
            }
            return ret;
        }
        else if (this.isMap) {
            // key type is already checked as string
            const argType = this.typeArgumentTypes()[1];
            if (argType.isClass) {
                return new GSClassField('', argType).referencedClassFields();
            }
            return ret;
        }
        else if (this.isExtendedArray) {
            throw new Error('Types extend Array are not supported. Please use a wrapper type');
        }
        else {
            const typeArguments = this.typeArgumentTypes();
            if (typeArguments.length === 1) {
                if (typeArguments[0].isClass) {
                    throw new Error(`Class type argument is not supported: ${this.typeNameWithTypeArg}`);
                }
            }
            else if (typeArguments.length > 1) {
                throw new Error(`Class type argument is not supported: ${this.typeNameWithTypeArg}`);
            }
        }
        ret.set(this.typeName, this);
        this.getAllFields().forEach((f) => {
            if (!f.isClass) {
                return;
            }
            const field = f.asClassField();
            field.referencedClassFields().forEach((rf, _name, _map) => {
                if (!ret.has(rf.typeName)) {
                    ret.set(rf.typeName, rf);
                }
            });
        });
        return ret;
    }
    getDefaultValue() {
        if (this.isNullableReference) {
            return 'null';
        }
        else if (this.isString) {
            return `''`;
        }
        else if (this.isArray) {
            return '[]';
        }
        else if (this.isSet) {
            return 'new Set()';
        }
        else if (this.isMap) {
            return `new Map()`;
        }
        else if (this.isBox) {
            return `changetype<${this.typeName}<${this.boxOf}>>(new ${this.serializerClassName(true)}())`;
        }
        else {
            return `changetype<${this.typeName}>(new ${this.serializerClassName()}())`;
        }
    }
    toString() {
        return `
      GSClassField {
        name: ${this.typeName}
        type: ${this.type}
        reference: ${this.reference}
        typeName: ${this.typeName}
        source: ${this.source()}
      }
    `;
    }
}
exports.GSClassField = GSClassField;
//# sourceMappingURL=gs-class-field.js.map