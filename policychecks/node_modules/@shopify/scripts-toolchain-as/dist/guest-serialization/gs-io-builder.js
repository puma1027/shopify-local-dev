"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GSIOBuilder = void 0;
const gs_io_walker_1 = require("./gs-io-walker");
class GSIOBuilder {
    constructor(inputFields, outputField) {
        this.inputFields = inputFields;
        this.outputField = outputField;
    }
    static build(program) {
        const walker = new gs_io_walker_1.GSIOWalker(program);
        return new GSIOBuilder(walker.inputFields, walker.outputField).build();
    }
    build() {
        const content = [];
        const referencedClassFields = this.referencedClassFields();
        content.push(this.buildImport(referencedClassFields));
        content.push('export class __Input {');
        content.push('  constructor(');
        const inputFieldList = this.inputFields.map((field) => `    public ${field.name}: ${field.typeNameWithTypeArg},`);
        content.push(inputFieldList.join('\n'));
        content.push('  ) {}');
        content.push('}');
        content.push('');
        content.push('export class __Output {');
        content.push('  constructor(');
        content.push(`    public inner: ${this.outputField.typeNameWithTypeArg},`);
        content.push('  ) {}');
        content.push('}');
        return content.join('\n');
    }
    referencedClassFields() {
        const map = this.inputAndOutputClassFields().reduce((acc, field) => {
            field.referencedClassFields().forEach((field, name, _map) => {
                // The reason we `acc.has(name)` is that field.referencedClassFields is a deep and recursive
                // search on all referenced class fields, which makes it possible that two field reference
                // the same class field.
                if (!acc.has(name)) {
                    acc.set(name, field);
                }
            });
            return acc;
        }, new Map());
        return Array.from(map.values());
    }
    inputAndOutputClassFields() {
        const classFields = this.inputFields.filter((f) => f.isClass).map((f) => f.asClassField());
        if (this.outputField.isClass) {
            classFields.push(this.outputField.asClassField());
        }
        return classFields;
    }
    buildImport(fields) {
        const entries = Array.from(buildSourceToClassnamesMap(fields).entries());
        return entries
            .map(([source, typeNames]) => {
            return `import {${typeNames.join(',')}} from "${source}";`;
        })
            .join('\n');
    }
}
exports.GSIOBuilder = GSIOBuilder;
function buildSourceToClassnamesMap(fields) {
    const imports = new Map();
    fields.forEach((field) => {
        const source = field.source();
        const typeNames = imports.get(source) || [];
        typeNames.push(field.typeName);
        imports.set(source, typeNames);
    });
    return imports;
}
//# sourceMappingURL=gs-io-builder.js.map