"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GSOutputFieldSerializer = exports.GSClassFieldSerializer = void 0;
const assert_1 = require("assert");
const gs_class_field_encoder_1 = require("./gs-class-field-encoder");
const gs_class_field_decoder_1 = require("./gs-class-field-decoder");
const gs_field_writer_1 = require("./gs-field-writer");
class GSClassFieldSerializer {
    constructor(field) {
        this.field = field;
    }
    static build(field) {
        if (field.isBox) {
            return new GSBoxFieldSerializer(field).build();
        }
        else {
            return new GSClassFieldSerializer(field).build();
        }
    }
    build() {
        const typeName = this.field.typeName;
        const allFieldsWithDefaultValue = this.field
            .getAllFields()
            .map((f) => {
            let s = `  ${f.name}: ${f.typeNameWithTypeArg}`;
            const defaultValue = f.getDefaultValue();
            if (defaultValue) {
                return `${s} = ${defaultValue};`;
            }
            else {
                return `${s};`;
            }
        })
            .join('\n');
        return `\
class ${typeName}Serializer {
${allFieldsWithDefaultValue}

  bufferLen(): u32 {
    const sizer = new Sizer();
    this.encode(sizer);
    return sizer.length;
  }

${gs_class_field_encoder_1.GSClassFieldEncoder.build(this.field)}

${gs_class_field_decoder_1.GSClassFieldDecoder.build(this.field)}
}
`;
    }
}
exports.GSClassFieldSerializer = GSClassFieldSerializer;
// This serializer specifically handles __Output type, which serializes the value of `inner` field
// directly, so that the serialization result is not wrapped with `{"inner": ... }`
class GSOutputFieldSerializer {
    constructor(field) {
        this.field = field;
    }
    static build(field) {
        return new GSOutputFieldSerializer(field).build();
    }
    build() {
        const typeName = this.field.typeName;
        const fields = this.field.getAllFields();
        assert_1.strict(fields.length == 1, 'Output type should only have one field');
        const inner = fields[0];
        let fieldWithDefaultValue = `  ${inner.name}: ${inner.typeNameWithTypeArg}`;
        const defaultValue = inner.getDefaultValue();
        if (defaultValue) {
            fieldWithDefaultValue = `${fieldWithDefaultValue} = ${defaultValue};`;
        }
        return `\
class ${typeName}Serializer {
${fieldWithDefaultValue}

  bufferLen(): u32 {
    const sizer = new Sizer();
    this.encode(sizer);
    return sizer.length;
  }

  encode(writer: Writer): void {
${gs_field_writer_1.GSFieldWriter.build(inner, 2, `this.${inner.name}`)}
  }
}
`;
    }
}
exports.GSOutputFieldSerializer = GSOutputFieldSerializer;
// This serializer specifically handles Box<T> SDK type (where T is primitive), which ignores the
// wrapper during serialization.
//
// Eg. const field: Box<i32> = new Box(42), will be serialized and deserialized as 42
class GSBoxFieldSerializer {
    constructor(field) {
        this.field = field;
    }
    static build(field) {
        assert_1.strict(field.isBox, 'GSBoxFieldSerializer only generates serializers for Box<T>');
        return new GSClassFieldSerializer(field).build();
    }
    build() {
        const allFields = this.field.getAllFields();
        assert_1.strict(allFields.length == 1, 'Box<T> should only contain one field');
        const field = allFields[0];
        const fieldName = field.name;
        const encode = [];
        encode.push('  encode(writer: Writer): void {');
        encode.push(`    if (this.${fieldName} instanceof i8) {`);
        encode.push(`      writer.writeInt8(<i8>this.${fieldName});`);
        encode.push(`    } else if (this.${fieldName} instanceof i16) {`);
        encode.push(`      writer.writeInt16(<i16>this.${fieldName});`);
        encode.push(`    } else if (this.${fieldName} instanceof i32) {`);
        encode.push(`      writer.writeInt32(<i32>this.${fieldName});`);
        encode.push(`    } else if (this.${fieldName} instanceof i64) {`);
        encode.push(`      writer.writeInt64(<i64>this.${fieldName});`);
        encode.push(`    } else if (this.${fieldName} instanceof u8) {`);
        encode.push(`      writer.writeUInt8(<u8>this.${fieldName});`);
        encode.push(`    } else if (this.${fieldName} instanceof u16) {`);
        encode.push(`      writer.writeUInt16(<u16>this.${fieldName});`);
        encode.push(`    } else if (this.${fieldName} instanceof u32) {`);
        encode.push(`      writer.writeUInt32(<u32>this.${fieldName});`);
        encode.push(`    } else if (this.${fieldName} instanceof u64) {`);
        encode.push(`      writer.writeUInt64(<u64>this.${fieldName});`);
        encode.push(`    } else if (this.${fieldName} instanceof f32) {`);
        encode.push(`      writer.writeFloat32(<f32>this.${fieldName});`);
        encode.push(`    } else if (this.${fieldName} instanceof f64) {`);
        encode.push(`      writer.writeFloat64(<f64>this.${fieldName});`);
        encode.push(`    } else if (this.${fieldName} instanceof bool) {`);
        encode.push(`      writer.writeBool(<bool>this.${fieldName});`);
        encode.push('    } else {');
        encode.push(`      throw new Error('Unexpected field type for Box<T>');`);
        encode.push('    }');
        encode.push('  }');
        const decode = [];
        decode.push('  static decode<T>(__reader__: Decoder): BoxSerializer<T> {');
        decode.push(`    let ${fieldName}: T;`);
        decode.push('');
        decode.push(`    if (${fieldName} instanceof i8) {`);
        decode.push(`      ${fieldName} = __reader__.readInt8();`);
        decode.push(`    } else if (${fieldName} instanceof i16) {`);
        decode.push(`      ${fieldName} = __reader__.readInt16();`);
        decode.push(`    } else if (${fieldName} instanceof i32) {`);
        decode.push(`      ${fieldName} = __reader__.readInt32();`);
        decode.push(`    } else if (${fieldName} instanceof i64) {`);
        decode.push(`      ${fieldName} = __reader__.readInt64();`);
        decode.push(`    } else if (${fieldName} instanceof u8) {`);
        decode.push(`      ${fieldName} = __reader__.readUInt8();`);
        decode.push(`    } else if (${fieldName} instanceof u16) {`);
        decode.push(`      ${fieldName} = __reader__.readUInt16();`);
        decode.push(`    } else if (${fieldName} instanceof u32) {`);
        decode.push(`      ${fieldName} = __reader__.readUInt32();`);
        decode.push(`    } else if (${fieldName} instanceof u64) {`);
        decode.push(`      ${fieldName} = __reader__.readUInt64();`);
        decode.push(`    } else if (${fieldName} instanceof f32) {`);
        decode.push(`      ${fieldName} = __reader__.readFloat32();`);
        decode.push(`    } else if (${fieldName} instanceof f64) {`);
        decode.push(`      ${fieldName} = __reader__.readFloat64();`);
        decode.push(`    } else if (${fieldName} instanceof bool) {`);
        decode.push(`      ${fieldName} = __reader__.readBool();`);
        decode.push('    } else {');
        decode.push(`      throw new Error('Unexpected field type for Box<T>');`);
        decode.push('    }');
        decode.push(`    return {${fieldName}};`);
        decode.push('  }');
        return `\
class BoxSerializer<T> {
  ${fieldName}: T;

  bufferLen(): u32 {
    const sizer = new Sizer();
    this.encode(sizer);
    return sizer.length;
  }

${encode.join('\n')}

${decode.join('\n')}
}
`;
    }
}
//# sourceMappingURL=gs-class-field-serializer.js.map