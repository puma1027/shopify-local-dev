"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getMetadata = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
function getMetadata(ep, domain) {
    if ((ep && !domain) || (domain && !ep)) {
        throw new Error('When working with domain packages, both --ep and --domain options are required');
    }
    const bounded = ep && domain;
    return {
        schemaVersions: bounded ? domainSchemaVersions({ domain, ep }) : schemaVersions(),
        flags: { use_msgpack: true },
    };
}
exports.getMetadata = getMetadata;
const relativePathToShopifyNodeModules = path_1.default.join('.', 'node_modules', '@shopify');
const regexes = {
    legacy: new RegExp('extension-point-as-(.+)'),
    bounded: (domain) => new RegExp(`scripts-${domain}-apis`),
};
function domainSchemaVersions(context) {
    const shopifyNodeModules = getShopifyNodeModules();
    const regex = regexes.bounded(context.domain);
    const epPackages = shopifyNodeModules.filter((dirent) => isEpPackage(dirent, regex)).map((dirent) => dirent.name);
    if (epPackages.length < 1) {
        throw new Error(`Expected to have @shopify/scripts-${context.domain}-apis installed`);
    }
    return epPackages.reduce((versions, epPackage) => {
        const epMetadata = JSON.parse(readMetadataJsonForEp(epPackage, context));
        const schemaVersion = epMetadata.schemaVersion;
        if (!schemaVersion) {
            throw new Error(`NPM package ${epPackage} does not have a schemaVersion defined`);
        }
        const epName = context.ep.replace(/-/g, '_');
        versions[epName] = schemaVersion;
        return versions;
    }, {});
}
function schemaVersions() {
    const shopifyNodeModules = getShopifyNodeModules();
    const epPackages = shopifyNodeModules
        .filter((dirent) => isEpPackage(dirent, regexes.legacy))
        .map((dirent) => dirent.name);
    if (epPackages.length < 1) {
        throw new Error('Expected to have at least one EP NPM package installed');
    }
    return epPackages.reduce((versions, epPackage) => {
        const epMetadata = JSON.parse(readMetadataJsonForEp(epPackage));
        const schemaVersion = epMetadata.schemaVersion;
        if (!schemaVersion) {
            throw new Error(`NPM package ${epPackage} does not have a schemaVersion defined`);
        }
        const epName = epPackageToEpName(epPackage, regexes.legacy);
        versions[epName] = schemaVersion;
        return versions;
    }, {});
}
function getShopifyNodeModules() {
    return fs_1.default.readdirSync(relativePathToShopifyNodeModules, { withFileTypes: true });
}
function readMetadataJsonForEp(epPackage, context) {
    let metadataPath;
    if (context) {
        metadataPath = path_1.default.join(relativePathToShopifyNodeModules, epPackage, 'metadata', `${context.ep}.json`);
    }
    else {
        metadataPath = path_1.default.join(relativePathToShopifyNodeModules, epPackage, 'metadata.json');
    }
    if (!fs_1.default.existsSync(metadataPath)) {
        throw new Error(`NPM package ${epPackage} does not have metadata associated with it`);
    }
    return fs_1.default.readFileSync(metadataPath, { encoding: 'utf8' });
}
function isEpPackage(dirent, regex) {
    return (dirent.isDirectory() || dirent.isSymbolicLink()) && !!dirent.name.match(regex);
}
function epPackageToEpName(epPackage, regex) {
    return epPackage.match(regex)[1].replace(/-/g, '_');
}
//# sourceMappingURL=metadata.js.map