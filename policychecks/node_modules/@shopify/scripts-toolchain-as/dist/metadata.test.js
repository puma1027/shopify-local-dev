"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const metadata_1 = require("./metadata");
jest.mock('fs');
const mockedFs = fs_1.default;
describe('getMetadata', () => {
    describe('setting schemaVersions for legacy eps', () => {
        it('should error if there are no modules', () => {
            stubFetchingModules([]);
            expect(() => metadata_1.getMetadata()).toThrow('Expected to have at least one EP NPM package installed');
        });
        it('should set versions for all ep modules', () => {
            stubFetchingModules([createDirectory('extension-point-as-foo'), createDirectory('extension-point-as-bar')]);
            stubMetadataJson({
                foo: JSON.stringify({ schemaVersion: { major: 1, minor: 0 } }),
                bar: JSON.stringify({ schemaVersion: { major: 2, minor: 1 } }),
            });
            const metadata = metadata_1.getMetadata();
            expect(metadata.schemaVersions).toStrictEqual({
                foo: { major: 1, minor: 0 },
                bar: { major: 2, minor: 1 },
            });
            expect(metadata.flags).toStrictEqual({ use_msgpack: true });
        });
        it('should include symlinks when getting ep modules', () => {
            stubFetchingModules([createSymlink('extension-point-as-foo')]);
            stubDefaultMetadataJson();
            const metadata = metadata_1.getMetadata();
            expect(metadata.schemaVersions.foo).toBeTruthy();
        });
        it('should not include files in @shopify directory', () => {
            stubFetchingModules([createFile('extension-point-as-foo'), createDirectory('extension-point-as-bar')]);
            stubDefaultMetadataJson();
            const metadata = metadata_1.getMetadata();
            expect(metadata.schemaVersions.foo).toBeUndefined();
        });
        it('should not include packages that are not EPs', () => {
            stubFetchingModules([createDirectory('extension-point-as-foo'), createDirectory('bar')]);
            stubDefaultMetadataJson();
            const metadata = metadata_1.getMetadata();
            expect(Object.keys(metadata.schemaVersions)).toEqual(['foo']);
        });
        it('should convert dashes to underscores in package names', () => {
            stubFetchingModules([createDirectory('extension-point-as-foo-bar-baz')]);
            stubDefaultMetadataJson();
            const metadata = metadata_1.getMetadata();
            expect(Object.keys(metadata.schemaVersions)).toEqual(['foo_bar_baz']);
        });
        it('should error if missing metadata files', () => {
            stubFetchingModules([createDirectory('extension-point-as-foo')]);
            stubMissingMetadata();
            expect(() => metadata_1.getMetadata()).toThrow('NPM package extension-point-as-foo does not have metadata associated with it');
        });
        it('should error if metadata file is missing schemaVersion property', () => {
            stubFetchingModules([createDirectory('extension-point-as-foo')]);
            stubMetadataJson({
                foo: JSON.stringify({}),
            });
            expect(() => metadata_1.getMetadata()).toThrow('NPM package extension-point-as-foo does not have a schemaVersion defined');
        });
    });
    describe('setting schemaVersions for domain eps', () => {
        it('should throw an error if there are no modules', () => {
            stubFetchingModules([]);
            expect(() => metadata_1.getMetadata('payment-methods', 'checkout')).toThrow('Expected to have @shopify/scripts-checkout-apis installed');
        });
        it('should throw an error if only the ep option is set', () => {
            stubFetchingModules([]);
            expect(() => metadata_1.getMetadata('payment-methods')).toThrow('When working with domain packages, both --ep and --domain options are required');
        });
        it('should throw an error if only the domain option is set', () => {
            stubFetchingModules([]);
            expect(() => metadata_1.getMetadata(undefined, 'checkout')).toThrow('When working with domain packages, both --ep and --domain options are required');
        });
        it('should set the version for the specified ep', () => {
            stubFetchingModules([createDirectory('scripts-checkout-apis')]);
            stubMetadataJson({
                foo: JSON.stringify({ schemaVersion: { major: 1, minor: 0 } }),
            }, 'foo', 'checkout');
            const metadata = metadata_1.getMetadata('foo', 'checkout');
            expect(mockedFs.existsSync).toHaveBeenCalledWith('node_modules/@shopify/scripts-checkout-apis/metadata/foo.json');
            expect(metadata.schemaVersions).toStrictEqual({
                foo: { major: 1, minor: 0 },
            });
            expect(metadata.flags).toStrictEqual({ use_msgpack: true });
        });
        it('should not include packages that are not EPs', () => {
            stubFetchingModules([createDirectory('scripts-checkout-apis'), createDirectory('bar')]);
            stubDefaultMetadataJson();
            const metadata = metadata_1.getMetadata('foo', 'checkout');
            expect(Object.keys(metadata.schemaVersions)).toEqual(['foo']);
        });
        it('should convert dashes to underscores in package names', () => {
            stubFetchingModules([createDirectory('scripts-checkout-apis')]);
            stubDefaultMetadataJson();
            const metadata = metadata_1.getMetadata('foo-bar-baz', 'checkout');
            expect(Object.keys(metadata.schemaVersions)).toEqual(['foo_bar_baz']);
        });
    });
});
function stubFetchingModules(entries) {
    mockedFs.readdirSync.mockReturnValue(entries);
}
function stubMetadataJson(values, ep, domain) {
    const bounded = ep && domain;
    mockedFs.existsSync.mockReturnValue(true);
    mockedFs.readFileSync.mockImplementation((path) => {
        if (typeof path !== 'string') {
            throw new Error('Unsupported type used for path');
        }
        let extensionPoint;
        if (bounded) {
            extensionPoint = ep;
        }
        else {
            extensionPoint = path.match(/\/extension-point-as-(.+)\//)[1];
        }
        const json = values[extensionPoint];
        if (!json) {
            throw new Error(`${ep} not found in ${values}`);
        }
        return json;
    });
}
function stubDefaultMetadataJson() {
    mockedFs.existsSync.mockReturnValue(true);
    mockedFs.readFileSync.mockReturnValue(JSON.stringify({ schemaVersion: { major: 1, minor: 0 } }));
}
function stubMissingMetadata() {
    mockedFs.existsSync.mockReturnValue(false);
}
function createDirectory(name) {
    return createDirent({ name, isDirectory: true, isSymlink: false });
}
function createSymlink(name) {
    return createDirent({ name, isDirectory: false, isSymlink: true });
}
function createFile(name) {
    return createDirent({ name, isDirectory: false, isSymlink: false });
}
function createDirent({ name, isDirectory, isSymlink }) {
    return {
        name,
        isDirectory() {
            return isDirectory;
        },
        isSymbolicLink() {
            return isSymlink;
        },
    };
}
//# sourceMappingURL=metadata.test.js.map