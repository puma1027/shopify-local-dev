import {OverflowableInteger} from '../assembly/internal-types';

describe('OverflowableInteger', () => {
  describe('i64', () => {
    it('works with expectations', () => {
      let v1 = OverflowableInteger.build<i64>(42);
      let v2 = OverflowableInteger.build<i64>(42);
      let v3 = OverflowableInteger.build<i64>(-42);
      expect<OverflowableInteger>(v1).toStrictEqual(v2);
      expect<OverflowableInteger>(v1).not.toStrictEqual(v3);
    });

    it('.value are comparable', () => {
      let v1 = OverflowableInteger.build<i64>(42);
      let v2 = OverflowableInteger.build<i64>(42);
      let v3 = OverflowableInteger.build<i64>(-42);
      expect<i64>(v1.value<i64>()).toStrictEqual(v2.value<i64>());
      expect<i64>(v1.value<i64>()).not.toStrictEqual(v3.value<i64>());
    });

    it('.value() supports i32 correctly', () => {
      let v1 = OverflowableInteger.build<i64>(42);
      expect<i64>(v1.value<i64>()).toBe(42);
      let v2 = OverflowableInteger.build<i64>(-42);
      expect<i64>(v2.value<i64>()).toBe(-42);
      let v3 = OverflowableInteger.build<i64>(0);
      expect<i64>(v3.value<i64>()).toBe(0);
    });

    it('.value() supports i64 correctly', () => {
      let v1 = OverflowableInteger.build<i64>(I64.MIN_VALUE);
      expect<i64>(v1.value<i64>()).toBe(I64.MIN_VALUE);
      let v2 = OverflowableInteger.build<i64>(I64.MAX_VALUE);
      expect<i64>(v2.value<i64>()).toBe(I64.MAX_VALUE);
    });
  });

  describe('u64', () => {
    it('works with expectations', () => {
      let v1 = OverflowableInteger.build<u64>(42);
      let v2 = OverflowableInteger.build<u64>(42);
      expect<OverflowableInteger>(v1).toStrictEqual(v2);
    });

    it('.value() are comparable', () => {
      let v1 = OverflowableInteger.build<u64>(42);
      let v2 = OverflowableInteger.build<u64>(42);
      expect<u64>(v1.value<u64>()).toStrictEqual(v2.value<u64>());
    });

    it('.value() supports i32 values correctly', () => {
      let v1 = OverflowableInteger.build<u64>(42);
      expect<u64>(v1.value<u64>()).toBe(42);
      let v2 = OverflowableInteger.build<u64>(0);
      expect<u64>(v2.value<u64>()).toBe(0);
    });

    it('.value() supports u64 values correctly', () => {
      let v2 = OverflowableInteger.build<u64>(U64.MAX_VALUE);
      expect<u64>(v2.value<u64>()).toBe(U64.MAX_VALUE);
    });
  });

  describe('type check', () => {
    it('allows u64 on instantiation', () => {
      expect(() => {
        OverflowableInteger.build<u64>(1);
      }).not.toThrow();
    });

    it('allows i64 on instantiation', () => {
      expect(() => {
        OverflowableInteger.build<i64>(1);
      }).not.toThrow();
    });

    it('does not allow other types on instantiation', () => {
      expect(() => {
        OverflowableInteger.build<f64>(1);
      }).toThrow();
      expect(() => {
        OverflowableInteger.build<bool>(1);
      }).toThrow();
    });
  });
});
