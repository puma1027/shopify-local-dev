import {Money, Currencies} from '../assembly';
import {RoundingMode} from '../assembly/Money/RoundingMode';

describe('Money', () => {
  describe('operator overrides', () => {
    it('can == compare Money with same currency', () => {
      const m1 = Money.fromAmount(1, Currencies.CAD);
      const m2 = Money.fromAmount(1, Currencies.CAD);

      expect(m1 == m2).toBe(true);
    });

    it('allows multiplying', () => {
      const expected = Money.fromAmount(2, Currencies.CAD);
      const actual = Money.fromAmount(4, Currencies.CAD);

      // @ts-ignore: operator overloaded
      expect(actual * 0.5).toStrictEqual(expected);
    });

    it('does not round on intermediate multiplication operations', () => {
      const initial = Money.fromAmount(10, Currencies.CAD);
      // @ts-ignore: operator overloaded
      const actual: Money = (initial / 3) * 3;
      expect(actual).toStrictEqual(initial);
    });

    it('allows dividing', () => {
      const expected = Money.fromAmount(2, Currencies.CAD);
      const actual = Money.fromAmount(4, Currencies.CAD);

      // @ts-ignore: operator overloaded
      expect(actual / 2).toStrictEqual(expected);
    });

    it('allows adding with the same currency', () => {
      const m1 = Money.fromAmount(1, Currencies.CAD);
      const m2 = Money.fromAmount(2, Currencies.CAD);
      const expected = Money.fromAmount(3, Currencies.CAD);

      // @ts-ignore: operator overloaded
      expect(m1 + m2).toStrictEqual(expected);
    });

    it('allows subtracting with the same currency', () => {
      const m1 = Money.fromAmount(3, Currencies.CAD);
      const m2 = Money.fromAmount(2, Currencies.CAD);
      const expected = Money.fromAmount(1, Currencies.CAD);

      // @ts-ignore: operator overloaded
      expect(m1 - m2).toStrictEqual(expected);
    });

    it('can != compare Money with same currency', () => {
      const m1 = Money.fromAmount(1, Currencies.CAD);
      const m2 = Money.fromAmount(2, Currencies.CAD);

      expect(m1 != m2).toBe(true);
    });

    it('can > compare Money with same currency', () => {
      const m1 = Money.fromAmount(2, Currencies.CAD);
      const m2 = Money.fromAmount(1, Currencies.CAD);

      expect(m1 > m2).toBe(true);
    });

    it('can >= compare Money with same currency', () => {
      const m1 = Money.fromAmount(2, Currencies.CAD);
      const m2 = Money.fromAmount(1, Currencies.CAD);

      expect(m1 >= m2).toBe(true);
    });

    it('can < compare Money with same currency', () => {
      const m1 = Money.fromAmount(1, Currencies.CAD);
      const m2 = Money.fromAmount(2, Currencies.CAD);

      expect(m1 < m2).toBe(true);
    });

    it('can <= compare Money with same currency', () => {
      const m1 = Money.fromAmount(1, Currencies.CAD);
      const m2 = Money.fromAmount(2, Currencies.CAD);

      expect(m1 <= m2).toBe(true);
    });

    it('throws if you try to == with a different currency', () => {
      expect(() => {
        const cad = Money.fromAmount(1, Currencies.CAD);
        const usd = Money.fromAmount(1, Currencies.USD);
        cad == usd;
      }).toThrow();
    });

    it('throws if you try to divide non-zero value by 0', () => {
      expect(() => {
        const money = Money.fromAmount(10, Currencies.CAD);
        money.currency;
        // @ts-ignore: operator overloaded
        money / 0;
      }).toThrow();
    });

    it('throws if you try to divide zero value by 0', () => {
      expect(() => {
        const money = Money.fromAmount(0, Currencies.CAD);
        // @ts-ignore: operator overloaded
        money / 0;
      }).toThrow();
    });
  });

  describe('toString', () => {
    it('prints value and currency', () => {
      const money = Money.fromAmount(123.45, Currencies.CAD);
      expect(money.toString()).toStrictEqual('123.45 units of CAD');
    });
  });

  describe('constructor', () => {
    it('can be created from a decimal amount', () => {
      Money.fromAmount(1.25, Currencies.CAD);
    });

    it('can be created from a decimal amount if currency exponent is 0', () => {
      Money.fromAmount(1.1, Currencies.JPY);
    });

    it('throws if you try to create Money with NaN', () => {
      expect(() => {
        Money.fromAmount(NaN, Currencies.CAD);
      }).toThrow();
    });

    it('throws if you try to create Money with Infinity', () => {
      expect(() => {
        Money.fromAmount(Infinity, Currencies.CAD);
      }).toThrow();
    });

    it('throws if you try to create Money with -Infinity', () => {
      expect(() => {
        Money.fromAmount(-Infinity, Currencies.CAD);
      }).toThrow();
    });
  });

  describe('#round', () => {
    it('throws if step is < 0', () => {
      expect(() => {
        Money.fromAmount(1, Currencies.CAD).round(-1, RoundingMode.UP);
      }).toThrow();
    });

    it('throws if step == 0', () => {
      expect(() => {
        Money.fromAmount(1, Currencies.CAD).round(0, RoundingMode.UP);
      }).toThrow();
    });

    describe('up', () => {
      it('rounds up to the next step', () => {
        const money = Money.fromAmount(1.11, Currencies.CAD);
        const expected = Money.fromAmount(1.15, Currencies.CAD);
        expect<Money>(money.round(0.05, RoundingMode.UP)).toStrictEqual(expected);
      });

      it('rounds up to the next dollar', () => {
        const money = Money.fromAmount(1.11, Currencies.CAD);
        const expected = Money.fromAmount(2, Currencies.CAD);
        expect<Money>(money.round(1, RoundingMode.UP)).toStrictEqual(expected);
      });

      it('does not round if value is on a step', () => {
        const money = Money.fromAmount(1.15, Currencies.CAD);
        const expected = Money.fromAmount(1.15, Currencies.CAD);
        expect<Money>(money.round(0.05, RoundingMode.UP)).toStrictEqual(expected);
      });

      it('rounds properly with step larger than value', () => {
        const money = Money.fromAmount(0.15, Currencies.CAD);
        const expected = Money.fromAmount(0.25, Currencies.CAD);
        expect<Money>(money.round(0.25, RoundingMode.UP)).toStrictEqual(expected);
      });

      it('rounds up for a currency with no subunit', () => {
        const money = Money.fromAmount(102, Currencies.JPY);
        const expected = Money.fromAmount(125, Currencies.JPY);
        expect<Money>(money.round(25, RoundingMode.UP)).toStrictEqual(expected);
      });

      it('rounds towards +Infinity for negative value', () => {
        const money = Money.fromAmount(-1.04, Currencies.CAD);
        const expected = Money.fromAmount(-1, Currencies.CAD);
        expect<Money>(money.round(0.05, RoundingMode.UP)).toStrictEqual(expected);
      });
    });

    describe('down', () => {
      it('rounds down to the previous step', () => {
        const money = Money.fromAmount(1.13, Currencies.CAD);
        const expected = Money.fromAmount(1.1, Currencies.CAD);
        expect<Money>(money.round(0.05, RoundingMode.DOWN)).toStrictEqual(expected);
      });

      it('rounds down to the previous dollar', () => {
        const money = Money.fromAmount(1.13, Currencies.CAD);
        const expected = Money.fromAmount(1, Currencies.CAD);
        expect<Money>(money.round(1, RoundingMode.DOWN)).toStrictEqual(expected);
      });

      it('does not round if value is on a step', () => {
        const money = Money.fromAmount(1.15, Currencies.CAD);
        const expected = Money.fromAmount(1.15, Currencies.CAD);
        expect<Money>(money.round(0.05, RoundingMode.DOWN)).toStrictEqual(expected);
      });

      it('rounds properly with step larger than value', () => {
        const money = Money.fromAmount(0.15, Currencies.CAD);
        const expected = Money.fromAmount(0, Currencies.CAD);
        expect<Money>(money.round(0.25, RoundingMode.DOWN)).toStrictEqual(expected);
      });

      it('rounds up for a currency with no subunit', () => {
        const money = Money.fromAmount(124, Currencies.JPY);
        const expected = Money.fromAmount(100, Currencies.JPY);
        expect<Money>(money.round(25, RoundingMode.DOWN)).toStrictEqual(expected);
      });

      it('rounds towards -Infinity for negative value', () => {
        const money = Money.fromAmount(-1.04, Currencies.CAD);
        const expected = Money.fromAmount(-1.05, Currencies.CAD);
        expect<Money>(money.round(0.05, RoundingMode.DOWN)).toStrictEqual(expected);
      });
    });

    describe('nearest', () => {
      it('rounds up to the next step', () => {
        const money = Money.fromAmount(1.13, Currencies.CAD);
        const expected = Money.fromAmount(1.15, Currencies.CAD);
        expect<Money>(money.round(0.05, RoundingMode.NEAREST)).toStrictEqual(expected);
      });

      it('rounds down to the previous step', () => {
        const money = Money.fromAmount(1.12, Currencies.CAD);
        const expected = Money.fromAmount(1, Currencies.CAD);
        expect<Money>(money.round(1, RoundingMode.NEAREST)).toStrictEqual(expected);
      });

      it('does not round if value is on a step', () => {
        const money = Money.fromAmount(1.15, Currencies.CAD);
        const expected = Money.fromAmount(1.15, Currencies.CAD);
        expect<Money>(money.round(0.05, RoundingMode.NEAREST)).toStrictEqual(expected);
      });

      it('rounds properly with step larger than value', () => {
        const money = Money.fromAmount(0.15, Currencies.CAD);
        const expected = Money.fromAmount(0.25, Currencies.CAD);
        expect<Money>(money.round(0.25, RoundingMode.NEAREST)).toStrictEqual(expected);
      });

      it('rounds up for a currency with no subunit', () => {
        const money = Money.fromAmount(124, Currencies.JPY);
        const expected = Money.fromAmount(125, Currencies.JPY);
        expect<Money>(money.round(25, RoundingMode.NEAREST)).toStrictEqual(expected);
      });

      it('rounds up if value is between steps', () => {
        const money = Money.fromAmount(2.5, Currencies.CAD);
        const expected = Money.fromAmount(3, Currencies.CAD);
        expect<Money>(money.round(1, RoundingMode.NEAREST)).toStrictEqual(expected);
      });

      it('rounds away from zero if value is negative and between steps', () => {
        const money = Money.fromAmount(-1.5, Currencies.CAD);
        const expected = Money.fromAmount(-2, Currencies.CAD);
        expect<Money>(money.round(1, RoundingMode.NEAREST)).toStrictEqual(expected);
      });

      it('rounds down if step is closer', () => {
        const money = Money.fromAmount(-1.6, Currencies.CAD);
        const expected = Money.fromAmount(-2, Currencies.CAD);
        expect<Money>(money.round(1, RoundingMode.NEAREST)).toStrictEqual(expected);
      });

      it('rounds up if step is closer', () => {
        const money = Money.fromAmount(-1.4, Currencies.CAD);
        const expected = Money.fromAmount(-1, Currencies.CAD);
        expect<Money>(money.round(1, RoundingMode.NEAREST)).toStrictEqual(expected);
      });
    });
  });
});
