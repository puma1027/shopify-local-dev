export type Int = i32;
export type Float = f64;

/**
 * This method checks the type of T and throws if the type is not valid. This runtime check is
 * used because we can't restrict the bounds of T at compile time due to current AS limitations.
 */
function assertValidType<T>(): void {
  let dummy: T;
  // @ts-ignore
  // prettier-ignore
  if (!(dummy instanceof i64 || dummy instanceof u64)) { // eslint-disable-line no-undef
    throw new Error('Cannot create OverflowableInteger where T is not u64 or i64');
  }
}

/**
 * This type is an adapter type around u64 and i64 as understood in AssemblyScript.
 * The goal is for it to encapsulate how this gets represented "over the wire".
 *
 * As of now we use GraphQL, which only gives us `Int`, or a 32 bit wide signed integer.
 * This implementation will fallback to a string representation of the value if it would overflow the i32.
 *
 * These types are intended only for that very purpose. As such they don't have any operator overloads or any other
 * additional support than a constructor and a matching getter `#value` to retrieve the primitive type.
 * We expect users to not rely on these adapter types for anything else than transferring data in and
 * out of the AssemblyScript runtime.
 *
 * Note: Values passed to this that are out of bounds for the given type T will result in undefined behaviour.
 * For example, passing a negative number to OverflowableInteger<u64>.
 */
export class OverflowableInteger {
  @shopify_rename('value') // eslint-disable-line no-undef
  protected readonly _value: Int;
  protected readonly valueOverflow: string | null;

  constructor(value: Int, valueOverflow: string | null) {
    this._value = value;
    this.valueOverflow = valueOverflow;
  }

  static build<T>(value: T): OverflowableInteger {
    assertValidType<T>();

    let _value = 0;
    let _valueOverflow: string | null = null;

    // @ts-ignore: cast
    if (value < <T>I32.MAX_VALUE && value > <T>I32.MIN_VALUE) {
      // @ts-ignore: cast
      _value = <i32>value;
    } else {
      // @ts-ignore: type
      _valueOverflow = value.toString();
    }
    return new OverflowableInteger(_value, _valueOverflow);
  }

  value<T>(): T {
    assertValidType<T>();

    if (this.valueOverflow !== null && this.valueOverflow!.length > 0) {
      const unsignedValue = U64.parseInt(this.valueOverflow!.toString());
      // @ts-ignore: cast
      return <T>unsignedValue;
    } else {
      // @ts-ignore: cast
      return <T>this._value;
    }
  }

  toString(): string {
    const valueOverflow = this.valueOverflow === null ? 'null' : this.valueOverflow!;
    return 'value' + this._value.toString() + ' valueOverflow:' + valueOverflow;
  }

  @operator('==')
  private __eq(other: OverflowableInteger | null): bool {
    if (!other) return false;
    return this.toString() == other.toString();
  }

  @operator('!=')
  private __ne(other: OverflowableInteger | null): bool {
    return !this.__eq(other);
  }
}
