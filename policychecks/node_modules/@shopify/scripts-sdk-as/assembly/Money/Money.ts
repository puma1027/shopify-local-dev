import {Box} from '../Box';
import {Currencies, Currency} from './Currency';
import {OverflowableInteger} from '../internal-types';
import {RoundingMode} from './RoundingMode';
import {roundTowardsInfinity, roundTowardsNegativeInfinity, roundNearestAwayFromZero} from './utils';

/**
 *
 * @internal
 */
function assertValidFloatValue(value: f64, message: string): void {
  if (!isFinite(value)) {
    throw new Error('Invalid operation: ' + message);
  }
}

/**
 * A `Money` represents an amount of money in a given currency.
 *
 * `Money` exposes a set of math and comparison operators that can be used to
 * interact with it. The intermediate results of these operations follow f64's
 * behaviour. If `Money` is included as part of a script's output, then the value
 * is converted to an integer amount of subunits before it is returned from
 * the script.
 *
 * The following operators are supported by this class:
 *   `*`
 *   `/`
 *   `==`
 *   `!=`
 *   `+`
 *   `-`
 *   `>`
 *   `>=`
 *   `<`
 *   `<=`
 *  */
export class Money {
  private readonly subunits: OverflowableInteger;
  @shopify_rename('currency') // eslint-disable-line no-undef
  private readonly _currency: string;

  /**
   * This represents the unit value as a float internally. This field should NOT
   * be used by the server. It should continue to use the integer subunits value.
   *
   * In order to get better precision on math operations, we lazily convert
   * integer subunits to float units when an operation happens and store the
   * value for subsequent calculations. In order to do this, we need to be able
   * to detect whether we've computed the float value or not.
   *
   * Using a non-finite value here would work as an indicator since that should
   * never be a valid value. The problem is that JSON does not support NaN or
   * Infinity as valid numerical values. The alternative would be to use a null,
   * but nullable primitives are not supported in AS.
   *
   * To work around this, we use the `Box` class, which boxes a primitive in
   * a class to allow it to be nullable.
   */
  @shopify_transient // eslint-disable-line no-undef, @shopify/assemblyscript/camelcase
  private __units: Box<f64> | null = null;

  private constructor(amount: f64, currency: Currency) {
    assertValidFloatValue(amount, 'Cannot create Money with invalid amount: ' + amount.toString());

    this._currency = currency.code;
    this.__units = new Box(amount);
    this.subunits = OverflowableInteger.build<i64>(currency.unitsToSubunits(amount));
  }

  /**
   * Get the `Currency` value of this `Money`
   * @returns The `Currency` value of this `Money`
   */
  get currency(): Currency {
    return Currencies.fromCode(this._currency);
  }

  /**
   * Create a `Money` instance from an amount and currency
   * @param amount The unit amount the `Money` should represent (For example, $5.25 USD would have amount `5.25`)
   * @param currency The currency that the `Money` should be in (For example, USD would be `Currencies.USD`)
   * @returns A new `Money` instance
   */
  static fromAmount(amount: f64, currency: Currency): Money {
    return new Money(amount, currency);
  }

  /**
   * Rounds the value of a `Money` to a `step` value. The rounding behaviour is
   * defined by the `mode` parameter.
   *
   * Examples:
   * - Round up to the dollar: `(USD$1.05).round(1, RoundingMode.UP) => USD$2.00`
   * - Round down to the dollar: `(USD$1.05).round(1, RoundingMode.DOWN) => USD$1.00`
   * - Round to the nearest dollar: `(USD$1.05).round(1, RoundingMode.NEAREST) => USD$1.00`
   * - Round to the nearest dollar: `(USD$1.50).round(1, RoundingMode.NEAREST) => USD$2.00`
   * - Round to the nearest nickel: `(USD$1.88).round(0.05, RoundingMode.NEAREST) => USD$1.90`
   * - Round up to $10: `(USD$3.50).round(10, RoundingMode.UP) => USD$10.00`
   *
   * @param step The positive step value to round to. The `Money` will be
   * rounded to a multiple of this value.
   * @param mode The rounding mode to use.
   * @returns A new `Money` instance with the rounded value
   */
  round(step: f64, mode: RoundingMode): Money {
    if (step <= 0) {
      throw new Error('Cannot round `Money` with non-positive `step` value: ' + step.toString());
    }

    const subunits = this.subunits.value<i64>();
    const stepSubunits = this.currency.unitsToSubunits(step);

    let rounded: i64;
    switch (mode) {
      case RoundingMode.UP:
        rounded = roundTowardsInfinity(subunits, stepSubunits);
        break;
      case RoundingMode.DOWN:
        rounded = roundTowardsNegativeInfinity(subunits, stepSubunits);
        break;
      case RoundingMode.NEAREST:
        rounded = roundNearestAwayFromZero(subunits, stepSubunits);
        break;
    }

    return Money.fromAmount(this.currency.subunitsToUnits(rounded), this.currency);
  }

  private get units(): f64 {
    this.initializeUnitsIfUnset();
    return this.__units!.value;
  }

  // Relative operations can only be performed on scalar values
  @operator('*')
  private __multiply(factor: f64): Money {
    return Money.fromAmount(this.units * factor, this.currency);
  }

  // Relative operations can only be performed on scalar values
  @operator('/')
  private __divide(divisor: f64): Money {
    const units = this.units;
    const result = units / divisor;

    assertValidFloatValue(result, units.toString() + ' / ' + divisor.toString());

    return Money.fromAmount(result, this.currency);
  }

  @operator('==')
  private __equals(other: Money): bool {
    if (this.units == 0 && other.units == 0) return true;
    return this.units == Money.convertUnits(other, this.currency);
  }

  @operator('!=')
  private __nequals(other: Money): bool {
    return !this.__equals(other);
  }

  // Normalizes to and takes the currency of the left operand
  @operator('+')
  private __add(other: Money): Money {
    return Money.fromAmount(this.units + Money.convertUnits(other, this.currency), this.currency);
  }

  // Normalizes to and takes the currency of the left operand
  @operator('-')
  private __subtract(other: Money): Money {
    return Money.fromAmount(this.units - Money.convertUnits(other, this.currency), this.currency);
  }

  @operator('>')
  private __gt(other: Money): bool {
    const normalizedUnits = Money.convertUnits(other, this.currency);
    return this.units > normalizedUnits;
  }

  @operator('>=')
  private __gte(other: Money): bool {
    const normalizedUnits = Money.convertUnits(other, this.currency);
    return this.units >= normalizedUnits;
  }

  @operator('<')
  private __lt(other: Money): bool {
    const normalizedUnits = Money.convertUnits(other, this.currency);
    return this.units < normalizedUnits;
  }

  @operator('<=')
  private __lte(other: Money): bool {
    const normalizedUnits = Money.convertUnits(other, this.currency);
    return this.units <= normalizedUnits;
  }

  private static convertUnits(from: Money, toCurrency: Currency): f64 {
    // TODO: Eventually we should support converting currency. This could
    // potentially be done by injected a conversion table or making a hostcall.
    if (from.currency != toCurrency) {
      throw new Error(
        'Currency conversion is not currently supported. Attempted to convert "' +
          from.currency.toString() +
          '" to "' +
          toCurrency.toString() +
          '"',
      );
    }

    return from.units;
  }

  private initializeUnitsIfUnset(): void {
    if (!this.__units) {
      this.__units = new Box(this.currency.subunitsToUnits(this.subunits.value<i64>()));
    }
  }

  public toString(): string {
    // TODO: need formatter
    // TODO: i18n
    return this.units.toString() + ' units of ' + this.currency.toString();
  }
}
