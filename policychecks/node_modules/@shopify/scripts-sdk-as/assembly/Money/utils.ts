/**
 * Rounds `subunits` to a multiple of `step` by rounding up towards infinity. If
 * `subunits` is already on a `step` multiple, then it will not be rounded.
 * @param subunits
 * @param step
 * @internal
 */
export function roundTowardsInfinity(subunits: i64, step: i64): i64 {
  const mod: i64 = subunits % step;
  if (mod == 0) return subunits;

  if (subunits < 0) {
    return subunits - mod;
  }

  return subunits + step - mod;
}

/**
 * Rounds `subunits` to a multiple of `step` by rounding down towards negative
 * infinity. If `subunits` is already on a `step` multiple, then it will not be
 * rounded.
 * @param subunits
 * @param step
 * @internal
 */
export function roundTowardsNegativeInfinity(subunits: i64, step: i64): i64 {
  const mod: i64 = subunits % step;
  if (mod == 0) return subunits;

  if (subunits < 0) {
    return subunits - (step + mod);
  }

  return subunits - mod;
}

/**
 * Rounds `subunits` to a multiple of `step` by rounding away from zero. If
 * `subunits` is positive, it will be rounded up towards infinity. If `subunits`
 * is negative, it will be rounded down towards negative infinity. If `subunits`
 * is already on a `step` multiple, it will not be rounded.
 * @param subunits
 * @param step
 * @internal
 */
export function roundNearestAwayFromZero(subunits: i64, step: i64): i64 {
  const mod: i64 = subunits % step;
  if (mod == 0) return subunits;

  const halfStep = <f64>step / 2;
  if (Math.abs(<f64>mod) < halfStep) {
    return subunits < 0 ? roundTowardsInfinity(subunits, step) : roundTowardsNegativeInfinity(subunits, step);
  } else {
    return subunits < 0 ? roundTowardsNegativeInfinity(subunits, step) : roundTowardsInfinity(subunits, step);
  }
}
