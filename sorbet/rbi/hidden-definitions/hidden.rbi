# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

module ANSI::Code
  include ::ANSI::Constants
  def [](*codes); end

  def ansi(*codes); end

  def back(spaces=T.unsafe(nil)); end

  def black_on_black(string=T.unsafe(nil)); end

  def black_on_blue(string=T.unsafe(nil)); end

  def black_on_cyan(string=T.unsafe(nil)); end

  def black_on_green(string=T.unsafe(nil)); end

  def black_on_magenta(string=T.unsafe(nil)); end

  def black_on_red(string=T.unsafe(nil)); end

  def black_on_white(string=T.unsafe(nil)); end

  def black_on_yellow(string=T.unsafe(nil)); end

  def blue_on_black(string=T.unsafe(nil)); end

  def blue_on_blue(string=T.unsafe(nil)); end

  def blue_on_cyan(string=T.unsafe(nil)); end

  def blue_on_green(string=T.unsafe(nil)); end

  def blue_on_magenta(string=T.unsafe(nil)); end

  def blue_on_red(string=T.unsafe(nil)); end

  def blue_on_white(string=T.unsafe(nil)); end

  def blue_on_yellow(string=T.unsafe(nil)); end

  def code(*codes); end

  def color(*codes); end

  def cyan_on_black(string=T.unsafe(nil)); end

  def cyan_on_blue(string=T.unsafe(nil)); end

  def cyan_on_cyan(string=T.unsafe(nil)); end

  def cyan_on_green(string=T.unsafe(nil)); end

  def cyan_on_magenta(string=T.unsafe(nil)); end

  def cyan_on_red(string=T.unsafe(nil)); end

  def cyan_on_white(string=T.unsafe(nil)); end

  def cyan_on_yellow(string=T.unsafe(nil)); end

  def display(line, column=T.unsafe(nil)); end

  def down(spaces=T.unsafe(nil)); end

  def forward(spaces=T.unsafe(nil)); end

  def green_on_black(string=T.unsafe(nil)); end

  def green_on_blue(string=T.unsafe(nil)); end

  def green_on_cyan(string=T.unsafe(nil)); end

  def green_on_green(string=T.unsafe(nil)); end

  def green_on_magenta(string=T.unsafe(nil)); end

  def green_on_red(string=T.unsafe(nil)); end

  def green_on_white(string=T.unsafe(nil)); end

  def green_on_yellow(string=T.unsafe(nil)); end

  def hex_code(string, background=T.unsafe(nil)); end

  def left(spaces=T.unsafe(nil)); end

  def magenta_on_black(string=T.unsafe(nil)); end

  def magenta_on_blue(string=T.unsafe(nil)); end

  def magenta_on_cyan(string=T.unsafe(nil)); end

  def magenta_on_green(string=T.unsafe(nil)); end

  def magenta_on_magenta(string=T.unsafe(nil)); end

  def magenta_on_red(string=T.unsafe(nil)); end

  def magenta_on_white(string=T.unsafe(nil)); end

  def magenta_on_yellow(string=T.unsafe(nil)); end

  def method_missing(code, *args, &blk); end

  def move(line, column=T.unsafe(nil)); end

  def random(background=T.unsafe(nil)); end

  def red_on_black(string=T.unsafe(nil)); end

  def red_on_blue(string=T.unsafe(nil)); end

  def red_on_cyan(string=T.unsafe(nil)); end

  def red_on_green(string=T.unsafe(nil)); end

  def red_on_magenta(string=T.unsafe(nil)); end

  def red_on_red(string=T.unsafe(nil)); end

  def red_on_white(string=T.unsafe(nil)); end

  def red_on_yellow(string=T.unsafe(nil)); end

  def rgb(*args); end

  def rgb_256(r, g, b); end

  def rgb_code(red, green, blue, background=T.unsafe(nil)); end

  def right(spaces=T.unsafe(nil)); end

  def style(*codes); end

  def unansi(string=T.unsafe(nil)); end

  def uncolor(string=T.unsafe(nil)); end

  def unstyle(string=T.unsafe(nil)); end

  def up(spaces=T.unsafe(nil)); end

  def white_on_black(string=T.unsafe(nil)); end

  def white_on_blue(string=T.unsafe(nil)); end

  def white_on_cyan(string=T.unsafe(nil)); end

  def white_on_green(string=T.unsafe(nil)); end

  def white_on_magenta(string=T.unsafe(nil)); end

  def white_on_red(string=T.unsafe(nil)); end

  def white_on_white(string=T.unsafe(nil)); end

  def white_on_yellow(string=T.unsafe(nil)); end

  def yellow_on_black(string=T.unsafe(nil)); end

  def yellow_on_blue(string=T.unsafe(nil)); end

  def yellow_on_cyan(string=T.unsafe(nil)); end

  def yellow_on_green(string=T.unsafe(nil)); end

  def yellow_on_magenta(string=T.unsafe(nil)); end

  def yellow_on_red(string=T.unsafe(nil)); end

  def yellow_on_white(string=T.unsafe(nil)); end

  def yellow_on_yellow(string=T.unsafe(nil)); end
  ENDCODE = ::T.let(nil, ::T.untyped)
  PATTERN = ::T.let(nil, ::T.untyped)
end

module ANSI::Code
  extend ::ANSI::Code
  extend ::ANSI::Constants
  def self.colors(); end

  def self.styles(); end
end

module ANSI::Constants
  BLACK = ::T.let(nil, ::T.untyped)
  BLINK = ::T.let(nil, ::T.untyped)
  BLINK_OFF = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  BOLD_OFF = ::T.let(nil, ::T.untyped)
  BRIGHT = ::T.let(nil, ::T.untyped)
  BRIGHT_OFF = ::T.let(nil, ::T.untyped)
  CLEAN = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CLEAR_EOL = ::T.let(nil, ::T.untyped)
  CLEAR_LEFT = ::T.let(nil, ::T.untyped)
  CLEAR_LINE = ::T.let(nil, ::T.untyped)
  CLEAR_RIGHT = ::T.let(nil, ::T.untyped)
  CLEAR_SCREEN = ::T.let(nil, ::T.untyped)
  CLR = ::T.let(nil, ::T.untyped)
  CLS = ::T.let(nil, ::T.untyped)
  CONCEAL = ::T.let(nil, ::T.untyped)
  CONCEALED = ::T.let(nil, ::T.untyped)
  CONCEAL_OFF = ::T.let(nil, ::T.untyped)
  CROSSED_OFF = ::T.let(nil, ::T.untyped)
  CROSSED_OUT_OFF = ::T.let(nil, ::T.untyped)
  CURSOR_HIDE = ::T.let(nil, ::T.untyped)
  CURSOR_SHOW = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  DARK = ::T.let(nil, ::T.untyped)
  DEFAULT_FONT = ::T.let(nil, ::T.untyped)
  DOUBLE_UNDERLINE = ::T.let(nil, ::T.untyped)
  ENCIRCLE = ::T.let(nil, ::T.untyped)
  ENCIRCLE_OFF = ::T.let(nil, ::T.untyped)
  FAINT = ::T.let(nil, ::T.untyped)
  FONT0 = ::T.let(nil, ::T.untyped)
  FONT1 = ::T.let(nil, ::T.untyped)
  FONT2 = ::T.let(nil, ::T.untyped)
  FONT3 = ::T.let(nil, ::T.untyped)
  FONT4 = ::T.let(nil, ::T.untyped)
  FONT5 = ::T.let(nil, ::T.untyped)
  FONT6 = ::T.let(nil, ::T.untyped)
  FONT7 = ::T.let(nil, ::T.untyped)
  FONT8 = ::T.let(nil, ::T.untyped)
  FONT9 = ::T.let(nil, ::T.untyped)
  FONT_DEFAULT = ::T.let(nil, ::T.untyped)
  FRAKTUR = ::T.let(nil, ::T.untyped)
  FRAKTUR_OFF = ::T.let(nil, ::T.untyped)
  FRAME = ::T.let(nil, ::T.untyped)
  FRAME_OFF = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  HIDE = ::T.let(nil, ::T.untyped)
  INVERSE = ::T.let(nil, ::T.untyped)
  INVERSE_OFF = ::T.let(nil, ::T.untyped)
  INVERT = ::T.let(nil, ::T.untyped)
  ITALIC = ::T.let(nil, ::T.untyped)
  ITALIC_OFF = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  NEGATIVE = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  OVERLINE = ::T.let(nil, ::T.untyped)
  OVERLINE_OFF = ::T.let(nil, ::T.untyped)
  POSITIVE = ::T.let(nil, ::T.untyped)
  RAPID = ::T.let(nil, ::T.untyped)
  RAPID_BLINK = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  RESET = ::T.let(nil, ::T.untyped)
  RESTORE = ::T.let(nil, ::T.untyped)
  REVEAL = ::T.let(nil, ::T.untyped)
  REVERSE = ::T.let(nil, ::T.untyped)
  SAVE = ::T.let(nil, ::T.untyped)
  SHOW = ::T.let(nil, ::T.untyped)
  SLOW_BLINK = ::T.let(nil, ::T.untyped)
  STRIKE = ::T.let(nil, ::T.untyped)
  SWAP = ::T.let(nil, ::T.untyped)
  UNDERLINE = ::T.let(nil, ::T.untyped)
  UNDERLINE_OFF = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

module ANSI::Constants
end

module AST
end

class AST::Node
  def +(array); end

  def <<(element); end

  def ==(other); end

  def append(element); end

  def assign_properties(properties); end

  def children(); end

  def clone(); end

  def concat(array); end

  def deconstruct(); end

  def eql?(other); end

  def fancy_type(); end

  def initialize(type, children=T.unsafe(nil), properties=T.unsafe(nil)); end

  def inspect(indent=T.unsafe(nil)); end

  def to_a(); end

  def to_ast(); end

  def to_s(indent=T.unsafe(nil)); end

  def to_sexp(indent=T.unsafe(nil)); end

  def to_sexp_array(); end

  def type(); end

  def updated(type=T.unsafe(nil), children=T.unsafe(nil), properties=T.unsafe(nil)); end
end

class AST::Node
end

class AST::Processor
  include ::AST::Processor::Mixin
end

module AST::Processor::Mixin
  def handler_missing(node); end

  def process(node); end

  def process_all(nodes); end
end

module AST::Processor::Mixin
end

class AST::Processor
end

module AST::Sexp
  def s(type, *children); end
end

module AST::Sexp
end

module AST
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def abbrev(pattern=T.unsafe(nil)); end

  def deconstruct(); end

  def shelljoin(); end

  def to_h(); end

  def to_liquid(); end
end

class Array
  def self.try_convert(arg); end
end

class BasicObject
  def __binding__(); end
end

BasicObject::BasicObject = BasicObject

class Benchmark::Job
  def initialize(width); end
end

class Benchmark::Report
  def initialize(width=T.unsafe(nil), format=T.unsafe(nil)); end
end

class Benchmark::Tms
  def to_a(); end
end

class BigDecimal
  def clone(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.interpret_loosely(arg); end
end

class Binding
  def clone(); end

  def irb(); end
end

module Bugsnag
  INTEGRATIONS = ::T.let(nil, ::T.untyped)
  LOCK = ::T.let(nil, ::T.untyped)
  NIL_EXCEPTION_DESCRIPTION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Bugsnag::BreadcrumbType
  ERROR = ::T.let(nil, ::T.untyped)
  LOG = ::T.let(nil, ::T.untyped)
  MANUAL = ::T.let(nil, ::T.untyped)
  NAVIGATION = ::T.let(nil, ::T.untyped)
  PROCESS = ::T.let(nil, ::T.untyped)
  REQUEST = ::T.let(nil, ::T.untyped)
  STATE = ::T.let(nil, ::T.untyped)
  USER = ::T.let(nil, ::T.untyped)
end

module Bugsnag::BreadcrumbType
end

module Bugsnag::Breadcrumbs
  ERROR_BREADCRUMB_TYPE = ::T.let(nil, ::T.untyped)
  LOG_BREADCRUMB_TYPE = ::T.let(nil, ::T.untyped)
  MANUAL_BREADCRUMB_TYPE = ::T.let(nil, ::T.untyped)
  NAVIGATION_BREADCRUMB_TYPE = ::T.let(nil, ::T.untyped)
  PROCESS_BREADCRUMB_TYPE = ::T.let(nil, ::T.untyped)
  REQUEST_BREADCRUMB_TYPE = ::T.let(nil, ::T.untyped)
  STATE_BREADCRUMB_TYPE = ::T.let(nil, ::T.untyped)
  USER_BREADCRUMB_TYPE = ::T.let(nil, ::T.untyped)
  VALID_BREADCRUMB_TYPES = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Breadcrumbs::Breadcrumb
  def auto(); end

  def ignore!(); end

  def ignore?(); end

  def initialize(name, type, meta_data, auto); end

  def message(); end

  def message=(message); end

  def meta_data(); end

  def meta_data=(meta_data); end

  def metadata(); end

  def metadata=(metadata); end

  def name(); end

  def name=(name); end

  def timestamp(); end

  def to_h(); end

  def type(); end

  def type=(type); end
end

class Bugsnag::Breadcrumbs::Breadcrumb
end

class Bugsnag::Breadcrumbs::OnBreadcrumbCallbackList
  def add(callback); end

  def call(breadcrumb); end

  def initialize(configuration); end

  def remove(callback); end
end

class Bugsnag::Breadcrumbs::OnBreadcrumbCallbackList
end

class Bugsnag::Breadcrumbs::Validator
  def initialize(configuration); end

  def validate(breadcrumb); end
end

class Bugsnag::Breadcrumbs::Validator
end

module Bugsnag::Breadcrumbs
end

class Bugsnag::Cleaner
  def clean_object(object); end

  def clean_url(url); end

  def initialize(configuration); end
  FILTERED = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  OBJECT_WITH_ID_AND_CLASS = ::T.let(nil, ::T.untyped)
  RAISED = ::T.let(nil, ::T.untyped)
  RECURSION = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Cleaner
end

class Bugsnag::CodeExtractor
  def add_file(path, trace); end

  def extract!(); end

  def initialize(configuration); end
  MAXIMUM_LINES_TO_KEEP = ::T.let(nil, ::T.untyped)
end

class Bugsnag::CodeExtractor
end

class Bugsnag::Configuration
  def add_on_breadcrumb(callback); end

  def add_on_error(callback); end

  def api_key(); end

  def api_key=(api_key); end

  def app_type(); end

  def app_type=(app_type); end

  def app_version(); end

  def app_version=(app_version); end

  def auto_capture_sessions(); end

  def auto_capture_sessions=(auto_capture_sessions); end

  def auto_notify(); end

  def auto_notify=(auto_notify); end

  def auto_track_sessions(); end

  def auto_track_sessions=(track_sessions); end

  def before_breadcrumb_callbacks(); end

  def before_breadcrumb_callbacks=(before_breadcrumb_callbacks); end

  def breadcrumbs(); end

  def ca_file(); end

  def ca_file=(ca_file); end

  def clear_request_data(); end

  def context(); end

  def context=(context); end

  def context_set?(); end

  def debug(message); end

  def default_delivery_method=(delivery_method); end

  def delivery_method(); end

  def delivery_method=(delivery_method); end

  def detected_app_type(); end

  def detected_app_type=(app_type); end

  def disable_sessions(); end

  def discard_classes(); end

  def discard_classes=(discard_classes); end

  def enable_sessions(); end

  def enabled_automatic_breadcrumb_types(); end

  def enabled_automatic_breadcrumb_types=(enabled_automatic_breadcrumb_types); end

  def enabled_breadcrumb_types(); end

  def enabled_breadcrumb_types=(breadcrumb_types); end

  def enabled_release_stages(); end

  def enabled_release_stages=(release_stages); end

  def endpoint(); end

  def endpoint=(new_notify_endpoint); end

  def error(message); end

  def hostname(); end

  def hostname=(hostname); end

  def ignore_classes(); end

  def ignore_classes=(ignore_classes); end

  def info(message); end

  def internal_middleware(); end

  def internal_middleware=(internal_middleware); end

  def logger(); end

  def logger=(logger); end

  def max_breadcrumbs(); end

  def max_breadcrumbs=(new_max_breadcrumbs); end

  def meta_data_filters(); end

  def meta_data_filters=(meta_data_filters); end

  def middleware(); end

  def middleware=(middleware); end

  def notify_endpoint(); end

  def notify_release_stages(); end

  def notify_release_stages=(notify_release_stages); end

  def on_breadcrumb_callbacks(); end

  def parse_proxy(uri); end

  def project_root(); end

  def project_root=(project_root); end

  def proxy_host(); end

  def proxy_host=(proxy_host); end

  def proxy_password(); end

  def proxy_password=(proxy_password); end

  def proxy_port(); end

  def proxy_port=(proxy_port); end

  def proxy_user(); end

  def proxy_user=(proxy_user); end

  def release_stage(); end

  def release_stage=(release_stage); end

  def remove_on_breadcrumb(callback); end

  def remove_on_error(callback); end

  def request_data(); end

  def runtime_versions(); end

  def runtime_versions=(runtime_versions); end

  def scopes_to_filter(); end

  def send_code(); end

  def send_code=(send_code); end

  def send_environment(); end

  def send_environment=(send_environment); end

  def session_endpoint(); end

  def session_endpoint=(new_session_endpoint); end

  def set_endpoints(new_notify_endpoint, new_session_endpoint); end

  def set_request_data(key, value); end

  def should_notify_release_stage?(); end

  def timeout(); end

  def timeout=(timeout); end

  def track_sessions(); end

  def track_sessions=(track_sessions); end

  def unset_request_data(key, value); end

  def valid_api_key?(); end

  def vendor_path(); end

  def vendor_path=(vendor_path); end

  def warn(message); end
  API_KEY_REGEX = ::T.let(nil, ::T.untyped)
  DEFAULT_ENDPOINT = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_BREADCRUMBS = ::T.let(nil, ::T.untyped)
  DEFAULT_META_DATA_FILTERS = ::T.let(nil, ::T.untyped)
  DEFAULT_NOTIFY_ENDPOINT = ::T.let(nil, ::T.untyped)
  DEFAULT_SCOPES_TO_FILTER = ::T.let(nil, ::T.untyped)
  DEFAULT_SESSION_ENDPOINT = ::T.let(nil, ::T.untyped)
  DEFAULT_VENDOR_PATH = ::T.let(nil, ::T.untyped)
  PROG_NAME = ::T.let(nil, ::T.untyped)
  THREAD_LOCAL_NAME = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Configuration
end

module Bugsnag::Delivery
end

class Bugsnag::Delivery::Synchronous
end

class Bugsnag::Delivery::Synchronous
  def self.deliver(url, body, configuration, options=T.unsafe(nil)); end
end

class Bugsnag::Delivery::ThreadQueue
  MAX_OUTSTANDING_REQUESTS = ::T.let(nil, ::T.untyped)
  MUTEX = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Delivery::ThreadQueue
  def self.serialize_and_deliver(url, get_payload, configuration, options=T.unsafe(nil)); end
end

module Bugsnag::Delivery
  def self.[](name); end

  def self.register(name, delivery_method); end
end

class Bugsnag::Error
  def error_class(); end

  def error_class=(error_class); end

  def error_message(); end

  def error_message=(error_message); end

  def initialize(error_class, error_message, stacktrace); end

  def stacktrace(); end

  def type(); end

  def type=(type); end
  TYPE = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Error
end

Bugsnag::Event = Bugsnag::Report

module Bugsnag::Helpers
  MAX_ARRAY_LENGTH = ::T.let(nil, ::T.untyped)
  MAX_PAYLOAD_LENGTH = ::T.let(nil, ::T.untyped)
  MAX_STRING_LENGTH = ::T.let(nil, ::T.untyped)
  MAX_TRIM_STACK_FRAMES = ::T.let(nil, ::T.untyped)
  RAW_DATA_TYPES = ::T.let(nil, ::T.untyped)
  TRUNCATION_INFO = ::T.let(nil, ::T.untyped)
end

module Bugsnag::Helpers
  def self.deep_merge(l_hash, r_hash); end

  def self.deep_merge!(l_hash, r_hash); end

  def self.extract_exception(payload, &block); end

  def self.get_payload_length(value); end

  def self.is_json_raw_type?(value); end

  def self.payload_too_long?(value); end

  def self.remove_metadata_from_events(object); end

  def self.trim_as_string(text); end

  def self.trim_if_needed(value); end

  def self.trim_metadata(payload); end

  def self.trim_stacktrace_code(payload); end

  def self.trim_stacktrace_functions(payload); end

  def self.trim_strings_in_array(collection); end

  def self.trim_strings_in_hash(hash); end

  def self.trim_strings_in_value(value); end

  def self.truncate_array(array); end

  def self.truncate_arrays_in_hash(hash); end

  def self.truncate_arrays_in_value(value); end

  def self.truncate_exception_messages(payload); end
end

module Bugsnag::MetaData
  def bugsnag_context(); end

  def bugsnag_context=(bugsnag_context); end

  def bugsnag_grouping_hash(); end

  def bugsnag_grouping_hash=(bugsnag_grouping_hash); end

  def bugsnag_meta_data(); end

  def bugsnag_meta_data=(bugsnag_meta_data); end

  def bugsnag_user_id(); end

  def bugsnag_user_id=(bugsnag_user_id); end
end

module Bugsnag::MetaData
end

module Bugsnag::Middleware
end

class Bugsnag::Middleware::Breadcrumbs
  def call(report); end

  def initialize(next_callable); end
end

class Bugsnag::Middleware::Breadcrumbs
end

class Bugsnag::Middleware::Callbacks
  def call(report); end

  def initialize(bugsnag); end
end

class Bugsnag::Middleware::Callbacks
end

class Bugsnag::Middleware::ClassifyError
  def call(report); end

  def initialize(bugsnag); end
  INFO_CLASSES = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Middleware::ClassifyError
end

class Bugsnag::Middleware::ClearanceUser
  def call(report); end

  def initialize(bugsnag); end
  COMMON_USER_FIELDS = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Middleware::ClearanceUser
end

class Bugsnag::Middleware::DelayedJob
  def call(report); end

  def construct_job_payload(payload); end

  def initialize(bugsnag); end
  ACTIVE_JOB_DISPLAY_NAME = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Middleware::DelayedJob
end

class Bugsnag::Middleware::DiscardErrorClass
  def call(report); end

  def initialize(middleware); end
end

class Bugsnag::Middleware::DiscardErrorClass
end

class Bugsnag::Middleware::ExceptionMetaData
  def call(report); end

  def initialize(bugsnag); end
end

class Bugsnag::Middleware::ExceptionMetaData
end

class Bugsnag::Middleware::IgnoreErrorClass
  def call(report); end

  def initialize(bugsnag); end
end

class Bugsnag::Middleware::IgnoreErrorClass
end

class Bugsnag::Middleware::Mailman
  def call(report); end

  def initialize(bugsnag); end
end

class Bugsnag::Middleware::Mailman
end

class Bugsnag::Middleware::RackRequest
  def call(report); end

  def initialize(bugsnag); end
  SPOOF = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Middleware::RackRequest
end

class Bugsnag::Middleware::Rails3Request
  def call(report); end

  def initialize(bugsnag); end
  SPOOF = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Middleware::Rails3Request
end

class Bugsnag::Middleware::Rake
  def call(report); end

  def initialize(bugsnag); end
end

class Bugsnag::Middleware::Rake
end

class Bugsnag::Middleware::SessionData
  def call(report); end

  def initialize(bugsnag); end
end

class Bugsnag::Middleware::SessionData
end

class Bugsnag::Middleware::Sidekiq
  def call(report); end

  def initialize(bugsnag); end
end

class Bugsnag::Middleware::Sidekiq
end

class Bugsnag::Middleware::SuggestionData
  def call(report); end

  def initialize(bugsnag); end
  CAPTURE_REGEX = ::T.let(nil, ::T.untyped)
  DELIMITER = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Middleware::SuggestionData
end

class Bugsnag::Middleware::WardenUser
  def call(report); end

  def initialize(bugsnag); end
  COMMON_USER_FIELDS = ::T.let(nil, ::T.untyped)
  SCOPE_PATTERN = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Middleware::WardenUser
end

module Bugsnag::Middleware
end

class Bugsnag::MiddlewareStack
  def disable(*middlewares); end

  def insert_after(after, new_middleware); end

  def insert_before(before, new_middleware); end

  def method_missing(method, *args, &block); end

  def remove(*middlewares); end

  def run(report); end

  def use(new_middleware); end
end

class Bugsnag::MiddlewareStack
end

class Bugsnag::OnErrorCallbacks
  def call(report); end

  def initialize(next_middleware, callbacks); end
end

class Bugsnag::OnErrorCallbacks
end

class Bugsnag::Rack
  def call(env); end

  def initialize(app); end
  FRAMEWORK_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Rack
end

class Bugsnag::Report
  def add_metadata(section, key_or_data, *args); end

  def add_tab(name, value); end

  def api_key(); end

  def api_key=(api_key); end

  def app_type(); end

  def app_type=(app_type); end

  def app_version(); end

  def app_version=(app_version); end

  def as_json(); end

  def automatic_context(); end

  def automatic_context=(automatic_context); end

  def breadcrumbs(); end

  def breadcrumbs=(breadcrumbs); end

  def clear_metadata(section, *args); end

  def configuration(); end

  def configuration=(configuration); end

  def context(); end

  def context=(context); end

  def delivery_method(); end

  def delivery_method=(delivery_method); end

  def errors(); end

  def exceptions(); end

  def exceptions=(exceptions); end

  def grouping_hash(); end

  def grouping_hash=(grouping_hash); end

  def headers(); end

  def hostname(); end

  def hostname=(hostname); end

  def ignore!(); end

  def ignore?(); end

  def initialize(exception, passed_configuration, auto_notify=T.unsafe(nil)); end

  def meta_data(); end

  def meta_data=(meta_data); end

  def metadata(); end

  def metadata=(metadata); end

  def original_error(); end

  def raw_exceptions(); end

  def raw_exceptions=(raw_exceptions); end

  def release_stage(); end

  def release_stage=(release_stage); end

  def remove_tab(name); end

  def request(); end

  def request_data(); end

  def runtime_versions(); end

  def runtime_versions=(runtime_versions); end

  def session(); end

  def session=(session); end

  def set_user(id=T.unsafe(nil), email=T.unsafe(nil), name=T.unsafe(nil)); end

  def severity(); end

  def severity=(severity); end

  def severity_reason(); end

  def severity_reason=(severity_reason); end

  def summary(); end

  def unhandled(); end

  def user(); end

  def user=(user); end
  CURRENT_PAYLOAD_VERSION = ::T.let(nil, ::T.untyped)
  ERROR_CLASS = ::T.let(nil, ::T.untyped)
  HANDLED_EXCEPTION = ::T.let(nil, ::T.untyped)
  MAX_EXCEPTIONS_TO_UNWRAP = ::T.let(nil, ::T.untyped)
  NOTIFIER_NAME = ::T.let(nil, ::T.untyped)
  NOTIFIER_URL = ::T.let(nil, ::T.untyped)
  NOTIFIER_VERSION = ::T.let(nil, ::T.untyped)
  UNHANDLED_EXCEPTION = ::T.let(nil, ::T.untyped)
  UNHANDLED_EXCEPTION_MIDDLEWARE = ::T.let(nil, ::T.untyped)
  USER_CALLBACK_SET_SEVERITY = ::T.let(nil, ::T.untyped)
  USER_SPECIFIED_SEVERITY = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Report
end

class Bugsnag::SessionTracker
  def create_session(); end

  def send_sessions(); end

  def session_counts(); end

  def start_session(); end
  MUTEX = ::T.let(nil, ::T.untyped)
  SESSION_PAYLOAD_VERSION = ::T.let(nil, ::T.untyped)
  THREAD_SESSION = ::T.let(nil, ::T.untyped)
end

class Bugsnag::SessionTracker
  def self.get_current_session(); end

  def self.set_current_session(session); end
end

module Bugsnag::Stacktrace
  BACKTRACE_LINE_REGEX = ::T.let(nil, ::T.untyped)
  JAVA_BACKTRACE_REGEX = ::T.let(nil, ::T.untyped)
end

module Bugsnag::Stacktrace
  def self.process(backtrace, configuration); end
end

module Bugsnag::Utility
end

class Bugsnag::Utility::CircularBuffer
  include ::Enumerable
  def <<(item); end

  def each(&block); end

  def initialize(max_items=T.unsafe(nil)); end

  def max_items(); end

  def max_items=(new_max_items); end
end

class Bugsnag::Utility::CircularBuffer
end

class Bugsnag::Utility::MetadataDelegate
  def add_metadata(metadata, section, key_or_data, value=T.unsafe(nil)); end

  def clear_metadata(metadata, section, key=T.unsafe(nil)); end
  NOT_PROVIDED = ::T.let(nil, ::T.untyped)
end

class Bugsnag::Utility::MetadataDelegate
end

module Bugsnag::Utility
end

module Bugsnag
  def self.add_on_breadcrumb(callback); end

  def self.add_on_error(callback); end

  def self.at_exit_handler_installed?(); end

  def self.before_notify_callbacks(); end

  def self.breadcrumbs(); end

  def self.cleaner(); end

  def self.configuration(); end

  def self.configure(validate_api_key=T.unsafe(nil)); end

  def self.leave_breadcrumb(name, meta_data=T.unsafe(nil), type=T.unsafe(nil), auto=T.unsafe(nil)); end

  def self.load_integration(integration); end

  def self.load_integrations(); end

  def self.notify(exception, auto_notify=T.unsafe(nil), &block); end

  def self.register_at_exit(); end

  def self.remove_on_breadcrumb(callback); end

  def self.remove_on_error(callback); end

  def self.session_tracker(); end

  def self.start_session(); end
end

class Bundler::APIResponseInvalidDependenciesError
  def status_code(); end
end

class Bundler::APIResponseInvalidDependenciesError
end

class Bundler::CurrentRuby
  def jruby_30?(); end

  def jruby_3?(); end

  def maglev_30?(); end

  def maglev_3?(); end

  def mingw_30?(); end

  def mingw_3?(); end

  def mri_30?(); end

  def mri_3?(); end

  def mswin64_30?(); end

  def mswin64_3?(); end

  def mswin_30?(); end

  def mswin_3?(); end

  def on_30?(); end

  def on_3?(); end

  def rbx_30?(); end

  def rbx_3?(); end

  def ruby_30?(); end

  def ruby_3?(); end

  def truffleruby_30?(); end

  def truffleruby_3?(); end

  def x64_mingw_30?(); end

  def x64_mingw_3?(); end
end

class Bundler::Definition
  def dependencies_for(groups); end

  def most_specific_locked_platform(); end

  def multisource_allowed?(); end

  def requested_dependencies(); end

  def resolve_only_locally!(); end
end

class Bundler::DepProxy
  def clone(); end
end

class Bundler::DepProxy
  def self.get_proxy(dep, platform); end
end

class Bundler::Dependency
  def branch(); end

  def expanded_platforms(); end

  def git(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Dsl
  def check_primary_source_safety(); end
end

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::EnvironmentPreserver
  def replace_with_backup(); end
end

class Bundler::EnvironmentPreserver
  def self.env_to_hash(env); end

  def self.from_env(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*arg); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher::TooManyRequestsError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bundler::FileUtils::Entry_
  def link(dest); end
end

module Bundler::FileUtils
  def self.cp_lr(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil), dereference_root: T.unsafe(nil), remove_destination: T.unsafe(nil)); end

  def self.link_entry(src, dest, dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end
end

class Bundler::GemHelper
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_checksum(built_gem_path=T.unsafe(nil)); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def current_branch(); end

  def default_remote(); end

  def gem_command(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_input(cmd); end

  def sh_with_status(cmd, &block); end

  def spec_path(); end

  def tag_prefix=(tag_prefix); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end

  def self.tag_prefix=(prefix); end
end

class Bundler::GemHelpers::PlatformMatch
  def self.specificity_score(spec_platform, user_platform); end
end

module Bundler::GemHelpers
  def self.local_platform(); end

  def self.same_deps(spec, exemplary_spec); end

  def self.same_specificity(platform, spec, exemplary_spec); end
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::LazySpecification
  def eql?(other); end

  def platform_string(); end
end

module Bundler::Molinillo::SpecificationProvider
  def dependencies_equal?(dependencies, other_dependencies); end
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def add_dependency_names(names); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*arg); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def local!(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def spec_names(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index
  def installed_plugins(); end

  def plugin_commands(plugin); end

  def unregister_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::PluginInstallError
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  def self.list(); end

  def self.save_plugin(name, spec, optional_plugin=T.unsafe(nil)); end

  def self.uninstall(names, options); end
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Resolver
  include ::Bundler::GemHelpers
  def results_for(dependency, base); end

  def source_for(name); end
end

class Bundler::Resolver::SpecGroup
  def activated_platforms(); end

  def activated_platforms=(activated_platforms); end

  def sorted_activated_platforms(); end
end

class Bundler::Resolver::SpecGroup
  def self.create_for(specs, all_platforms, specific_platform); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubygemsIntegration
  def add_default_gems_to(specs); end

  def add_to_load_path(paths); end

  def all_specs(); end

  def backport_ext_builder_monitor(); end

  def correct_for_windows_path(path); end

  def default_stubs(); end

  def find_name(name); end

  def gem_remote_fetcher(); end

  def load_env_plugins(); end

  def plain_specs(); end

  def plain_specs=(specs); end

  def stub_rubygems(specs); end

  def use_gemdeps(gemfile); end
end

class Bundler::Settings
  def processor_count(); end
  STRING_KEYS = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::Settings
  def self.key_for(key); end
end

class Bundler::Source
  def add_dependency_names(names); end

  def cached!(); end

  def local!(); end

  def local_only!(); end

  def remote!(); end

  def spec_names(); end

  def to_err(); end
end

class Bundler::Source::Git
  def glob(); end

  def local?(); end
end

class Bundler::Source::Rubygems
  def dependency_api_available?(); end

  def multiple_remotes?(); end

  def no_remotes?(); end

  def remote_names(); end
end

class Bundler::Source::RubygemsAggregate
  def initialize(sources, source_map); end

  def source_map(); end

  def sources(); end

  def specs(); end

  def to_err(); end
end

class Bundler::Source::RubygemsAggregate
end

class Bundler::SourceList
  def add_global_rubygems_remote(uri); end

  def aggregate_global_source?(); end

  def expired_sources?(replacement_sources); end

  def global_path_source(); end

  def implicit_global_source?(); end

  def local_only!(); end

  def lock_other_sources(); end

  def lock_rubygems_sources(); end

  def merged_gem_lockfile_sections!(replacement_source); end

  def merged_gem_lockfile_sections?(); end

  def non_default_explicit_sources(); end

  def non_global_rubygems_sources(); end
end

class Bundler::SourceMap
  def all_requirements(); end

  def dependencies(); end

  def direct_requirements(); end

  def initialize(sources, dependencies); end

  def pinned_spec_names(skip=T.unsafe(nil)); end

  def sources(); end
end

class Bundler::SourceMap
end

class Bundler::SpecSet
  include ::Enumerable
  def missing_specs(); end
end

class Bundler::StubSpecification
  def extensions(); end

  def gem_build_complete_path(); end

  def manually_installed?(); end
end

class Bundler::Thor
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Bundler::Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def inject_into_module(path, module_name, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
  WARNINGS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Actions::CapturableERB
end

class Bundler::Thor::Actions::CapturableERB
end

module Bundler::Thor::Actions::ClassMethods
  def add_runtime_options!(); end

  def source_paths(); end

  def source_paths_for_search(); end

  def source_root(path=T.unsafe(nil)); end
end

module Bundler::Thor::Actions::ClassMethods
end

class Bundler::Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Bundler::Thor::Actions::CreateFile
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::CreateLink
end

class Bundler::Thor::Actions::Directory
  def execute!(); end

  def file_level_lookup(previous_lookup); end

  def files(lookup); end

  def initialize(base, source, destination=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def source(); end
end

class Bundler::Thor::Actions::Directory
end

class Bundler::Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def on_file_clash_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Bundler::Thor::Actions::EmptyDirectory
end

class Bundler::Thor::Actions::InjectIntoFile
  def behavior(); end

  def flag(); end

  def initialize(base, destination, data, config); end

  def replace!(regexp, string, force); end

  def replacement(); end

  def say_status(behavior, warning: T.unsafe(nil), color: T.unsafe(nil)); end
end

class Bundler::Thor::Actions::InjectIntoFile
end

module Bundler::Thor::Actions
  def self.included(base); end
end

class Bundler::Thor::AmbiguousCommandError
end

class Bundler::Thor::AmbiguousCommandError
end

Bundler::Thor::AmbiguousTaskError = Bundler::Thor::AmbiguousCommandError

class Bundler::Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Argument
end

class Bundler::Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Bundler::Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Bundler::Thor::Base::ClassMethods
  def all_commands(); end

  def all_tasks(); end

  def allow_incompatible_default_type!(); end

  def argument(name, options=T.unsafe(nil)); end

  def arguments(); end

  def attr_accessor(*arg); end

  def attr_reader(*arg); end

  def attr_writer(*arg); end

  def baseclass(); end

  def basename(); end

  def build_option(name, options, scope); end

  def build_options(options, scope); end

  def check_default_type(); end

  def check_default_type!(); end

  def check_unknown_options(); end

  def check_unknown_options!(); end

  def check_unknown_options?(config); end

  def class_option(name, options=T.unsafe(nil)); end

  def class_options(options=T.unsafe(nil)); end

  def class_options_help(shell, groups=T.unsafe(nil)); end

  def commands(); end

  def create_command(meth); end

  def create_task(meth); end

  def disable_required_check?(command_name); end

  def dispatch(command, given_args, given_opts, config); end

  def exit_on_failure?(); end

  def find_and_refresh_command(name); end

  def find_and_refresh_task(name); end

  def from_superclass(method, default=T.unsafe(nil)); end

  def group(name=T.unsafe(nil)); end

  def handle_argument_error(command, error, args, arity); end

  def handle_no_command_error(command, has_namespace=T.unsafe(nil)); end

  def handle_no_task_error(command, has_namespace=T.unsafe(nil)); end

  def inherited(klass); end

  def initialize_added(); end

  def is_thor_reserved_word?(word, type); end

  def method_added(meth); end

  def namespace(name=T.unsafe(nil)); end

  def no_commands(&block); end

  def no_commands?(); end

  def no_commands_context(); end

  def no_tasks(&block); end

  def print_options(shell, options, group_name=T.unsafe(nil)); end

  def public_command(*names); end

  def public_task(*names); end

  def remove_argument(*names); end

  def remove_class_option(*names); end

  def remove_command(*names); end

  def remove_task(*names); end

  def start(given_args=T.unsafe(nil), config=T.unsafe(nil)); end

  def stop_on_unknown_option?(command_name); end

  def strict_args_position(); end

  def strict_args_position!(); end

  def strict_args_position?(config); end

  def tasks(); end
end

module Bundler::Thor::Base::ClassMethods
end

module Bundler::Thor::Base
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Bundler::Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_arguments_for(klass, usage); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Command
end

module Bundler::Thor::CoreExt
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def replace(other_hash); end

  def reverse_merge(other); end

  def reverse_merge!(other_hash); end

  def values_at(*indices); end
end

class Bundler::Thor::CoreExt::HashWithIndifferentAccess
end

module Bundler::Thor::CoreExt
end

Bundler::Thor::Correctable = DidYouMean::Correctable

class Bundler::Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Bundler::Thor::DynamicCommand
end

Bundler::Thor::DynamicTask = Bundler::Thor::DynamicCommand

class Bundler::Thor::Error
end

class Bundler::Thor::Error
end

class Bundler::Thor::Group
  include ::Bundler::Thor::Base
  include ::Bundler::Thor::Invocation
  include ::Bundler::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Bundler::Thor::Group
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*arg); end

  def self.printable_tasks(*arg); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Bundler::Thor::HiddenCommand
end

class Bundler::Thor::HiddenCommand
end

Bundler::Thor::HiddenTask = Bundler::Thor::HiddenCommand

module Bundler::Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Bundler::Thor::Invocation::ClassMethods
  def prepare_for_invocation(key, name); end
end

module Bundler::Thor::Invocation::ClassMethods
end

module Bundler::Thor::Invocation
  def self.included(base); end
end

class Bundler::Thor::InvocationError
end

class Bundler::Thor::InvocationError
end

module Bundler::Thor::LineEditor
end

class Bundler::Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Bundler::Thor::LineEditor::Basic
  def self.available?(); end
end

class Bundler::Thor::LineEditor::Readline
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Bundler::Thor::LineEditor::Readline::PathCompletion
end

class Bundler::Thor::LineEditor::Readline
end

module Bundler::Thor::LineEditor
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::MalformattedArgumentError
end

class Bundler::Thor::NestedContext
  def enter(); end

  def entered?(); end
end

class Bundler::Thor::NestedContext
end

class Bundler::Thor::NoKwargSpellChecker
  def initialize(dictionary); end
end

class Bundler::Thor::NoKwargSpellChecker
end

class Bundler::Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def repeatable(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Option
  def self.parse(key, value); end
end

class Bundler::Thor::Options
  def assign_result!(option, result); end

  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil), disable_required_check=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Options
  def self.to_switches(options); end
end

module Bundler::Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Bundler::Thor::RakeCompat
  def self.included(base); end

  def self.rake_classes(); end
end

class Bundler::Thor::RequiredArgumentMissingError
end

class Bundler::Thor::RequiredArgumentMissingError
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Sandbox
end

module Bundler::Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
  def answer_match(possibilities, answer, case_insensitive); end

  def as_unicode(); end

  def ask(statement, *args); end

  def ask_filtered(statement, color, options); end

  def ask_simply(statement, color, options); end

  def base(); end

  def base=(base); end

  def can_display_colors?(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def error(statement); end

  def file_collision(destination); end

  def file_collision_help(); end

  def git_merge_tool(); end

  def indent(count=T.unsafe(nil)); end

  def is?(value); end

  def lookup_color(color); end

  def merge(destination, content); end

  def merge_tool(); end

  def mute(); end

  def mute?(); end

  def no?(statement, color=T.unsafe(nil)); end

  def padding(); end

  def padding=(value); end

  def prepare_message(message, *color); end

  def print_in_columns(array); end

  def print_table(array, options=T.unsafe(nil)); end

  def print_wrapped(message, options=T.unsafe(nil)); end

  def quiet?(); end

  def say(message=T.unsafe(nil), color=T.unsafe(nil), force_new_line=T.unsafe(nil)); end

  def say_status(status, message, log_status=T.unsafe(nil)); end

  def set_color(string, *arg); end

  def show_diff(destination, content); end

  def stderr(); end

  def stdout(); end

  def terminal_width(); end

  def truncate(string, width); end

  def unix?(); end

  def yes?(statement, color=T.unsafe(nil)); end
  DEFAULT_TERMINAL_WIDTH = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Basic
end

class Bundler::Thor::Shell::Color
  def are_colors_disabled?(); end

  def are_colors_supported?(); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::Color
end

class Bundler::Thor::Shell::HTML
  def ask(statement, color=T.unsafe(nil)); end

  def diff_lcs_loaded?(); end

  def output_diff_line(diff); end

  def set_color(string, *colors); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  ON_BLACK = ::T.let(nil, ::T.untyped)
  ON_BLUE = ::T.let(nil, ::T.untyped)
  ON_CYAN = ::T.let(nil, ::T.untyped)
  ON_GREEN = ::T.let(nil, ::T.untyped)
  ON_MAGENTA = ::T.let(nil, ::T.untyped)
  ON_RED = ::T.let(nil, ::T.untyped)
  ON_WHITE = ::T.let(nil, ::T.untyped)
  ON_YELLOW = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class Bundler::Thor::Shell::HTML
end

module Bundler::Thor::Shell
end

Bundler::Thor::Task = Bundler::Thor::Command

class Bundler::Thor::UndefinedCommandError
  include ::DidYouMean::Correctable
  def all_commands(); end

  def command(); end

  def initialize(command, all_commands, namespace); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UndefinedCommandError::SpellChecker
end

class Bundler::Thor::UndefinedCommandError
end

Bundler::Thor::UndefinedTaskError = Bundler::Thor::UndefinedCommandError

class Bundler::Thor::UnknownArgumentError
  include ::DidYouMean::Correctable
  def initialize(switches, unknown); end

  def switches(); end

  def unknown(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
  def corrections(); end

  def error(); end

  def initialize(error); end

  def spell_checker(); end
end

class Bundler::Thor::UnknownArgumentError::SpellChecker
end

class Bundler::Thor::UnknownArgumentError
end

module Bundler::Thor::Util
end

module Bundler::Thor::Util
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.escape_html(string); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Bundler::Thor
  extend ::Bundler::Thor::Base::ClassMethods
  extend ::Bundler::Thor::Invocation::ClassMethods
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.deprecation_warning(message); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_required_check(); end

  def self.disable_required_check!(*command_names); end

  def self.disable_required_check?(command); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil), **kw); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil), color=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ABS_URI_REF = ::T.let(nil, ::T.untyped)
  DEFAULT_PARSER = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  OPAQUE = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  REL_URI_REF = ::T.let(nil, ::T.untyped)
  RFC3986_PARSER = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TBLDECWWWCOMP_ = ::T.let(nil, ::T.untyped)
  TBLENCWWWCOMP_ = ::T.let(nil, ::T.untyped)
  UNSAFE = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_CODE = ::T.let(nil, ::T.untyped)
  WEB_ENCODINGS_ = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::BadURIError
end

class Bundler::URI::BadURIError
end

class Bundler::URI::Error
end

class Bundler::URI::Error
end

module Bundler::URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

module Bundler::URI::Escape
end

class Bundler::URI::FTP
  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  TYPECODE = ::T.let(nil, ::T.untyped)
  TYPECODE_PREFIX = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class Bundler::URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::File
end

class Bundler::URI::Generic
  include ::Bundler::URI
  include ::Bundler::URI::RFC2396_REGEXP
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  USE_REGISTRY = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::Generic
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class Bundler::URI::HTTP
  def request_uri(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTP
end

class Bundler::URI::HTTPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::HTTPS
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidComponentError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::InvalidURIError
end

class Bundler::URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  SCOPE = ::T.let(nil, ::T.untyped)
  SCOPE_BASE = ::T.let(nil, ::T.untyped)
  SCOPE_ONE = ::T.let(nil, ::T.untyped)
  SCOPE_SUB = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAP
end

class Bundler::URI::LDAPS
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::LDAPS
end

class Bundler::URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMAIL_REGEXP = ::T.let(nil, ::T.untyped)
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::MailTo
end

Bundler::URI::Parser = Bundler::URI::RFC2396_Parser

Bundler::URI::REGEXP = Bundler::URI::RFC2396_REGEXP

class Bundler::URI::RFC2396_Parser
  include ::Bundler::URI::RFC2396_REGEXP
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class Bundler::URI::RFC2396_Parser
end

module Bundler::URI::RFC2396_REGEXP
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
  ABS_PATH = ::T.let(nil, ::T.untyped)
  ABS_URI = ::T.let(nil, ::T.untyped)
  ALNUM = ::T.let(nil, ::T.untyped)
  ALPHA = ::T.let(nil, ::T.untyped)
  DOMLABEL = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  HEX = ::T.let(nil, ::T.untyped)
  HIER_PART = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  HOSTNAME = ::T.let(nil, ::T.untyped)
  HOSTPORT = ::T.let(nil, ::T.untyped)
  IPV4ADDR = ::T.let(nil, ::T.untyped)
  IPV6ADDR = ::T.let(nil, ::T.untyped)
  IPV6REF = ::T.let(nil, ::T.untyped)
  NET_PATH = ::T.let(nil, ::T.untyped)
  OPAQUE_PART = ::T.let(nil, ::T.untyped)
  PATH_SEGMENTS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  REG_NAME = ::T.let(nil, ::T.untyped)
  REL_PATH = ::T.let(nil, ::T.untyped)
  REL_SEGMENT = ::T.let(nil, ::T.untyped)
  REL_URI = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  TOPLABEL = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  URIC = ::T.let(nil, ::T.untyped)
  URIC_NO_SLASH = ::T.let(nil, ::T.untyped)
  URI_REF = ::T.let(nil, ::T.untyped)
  USERINFO = ::T.let(nil, ::T.untyped)
  X_ABS_URI = ::T.let(nil, ::T.untyped)
  X_REL_URI = ::T.let(nil, ::T.untyped)
end

module Bundler::URI::RFC2396_REGEXP::PATTERN
end

module Bundler::URI::RFC2396_REGEXP
end

class Bundler::URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_URI = ::T.let(nil, ::T.untyped)
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class Bundler::URI::RFC3986_Parser
end

module Bundler::URI::Util
end

module Bundler::URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module Bundler::URI
  extend ::Bundler::URI::Escape
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.decode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.extract(str, schemes=T.unsafe(nil), &block); end

  def self.get_encoding(label); end

  def self.join(*str); end

  def self.parse(uri); end

  def self.regexp(schemes=T.unsafe(nil)); end

  def self.scheme_list(); end

  def self.split(uri); end
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*arg); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*arg); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*arg); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler
  def self.configure_gem_home_and_path(path=T.unsafe(nil)); end

  def self.most_specific_locked_platform?(platform); end

  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.preferred_gemfile_name(); end

  def self.reset_settings_and_root!(); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end
end

module Byebug
  include ::Byebug::Helpers::ReflectionHelper
  def displays(); end

  def displays=(displays); end

  def init_file(); end

  def init_file=(init_file); end

  def mode(); end

  def mode=(mode); end

  def run_init_script(); end
  PORT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
end

class Byebug::AutolistSetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutolistSetting
end

class Byebug::AutoprySetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoprySetting
end

class Byebug::AutosaveSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutosaveSetting
end

class Byebug::BasenameSetting
  def banner(); end
end

class Byebug::BasenameSetting
end

class Byebug::BreakCommand
  include ::Byebug::Helpers::EvalHelper
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::BreakCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Breakpoint
  def enabled=(enabled); end

  def enabled?(); end

  def expr(); end

  def expr=(expr); end

  def hit_condition(); end

  def hit_condition=(hit_condition); end

  def hit_count(); end

  def hit_value(); end

  def hit_value=(hit_value); end

  def id(); end

  def initialize(arg, arg1, arg2); end

  def pos(); end

  def source(); end
end

class Byebug::Breakpoint
  def self.add(file, line, expr=T.unsafe(nil)); end

  def self.first(); end

  def self.last(); end

  def self.none?(); end

  def self.potential_line?(filename, lineno); end

  def self.potential_lines(filename); end

  def self.remove(id); end
end

class Byebug::CallstyleSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::CallstyleSetting
end

class Byebug::CatchCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::CatchCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Command
  def arguments(); end

  def confirm(*args, &block); end

  def context(); end

  def errmsg(*args, &block); end

  def frame(); end

  def help(*args, &block); end

  def initialize(processor, input=T.unsafe(nil)); end

  def match(*args, &block); end

  def pr(*args, &block); end

  def prc(*args, &block); end

  def print(*args, &block); end

  def processor(); end

  def prv(*args, &block); end

  def puts(*args, &block); end
end

class Byebug::Command
  extend ::Forwardable
  extend ::Byebug::Helpers::StringHelper
  def self.allow_in_control(); end

  def self.allow_in_control=(allow_in_control); end

  def self.allow_in_post_mortem(); end

  def self.allow_in_post_mortem=(allow_in_post_mortem); end

  def self.always_run(); end

  def self.always_run=(always_run); end

  def self.columnize(width); end

  def self.help(); end

  def self.match(input); end
end

class Byebug::CommandList
  include ::Enumerable
  def each(&blk); end

  def initialize(commands); end

  def match(input); end
end

class Byebug::CommandList
end

class Byebug::CommandNotFound
  def initialize(input, parent=T.unsafe(nil)); end
end

class Byebug::CommandNotFound
end

class Byebug::CommandProcessor
  include ::Byebug::Helpers::EvalHelper
  def after_repl(); end

  def at_breakpoint(brkpt); end

  def at_catchpoint(exception); end

  def at_end(); end

  def at_line(); end

  def at_return(return_value); end

  def at_tracing(); end

  def before_repl(); end

  def command_list(); end

  def commands(*args, &block); end

  def confirm(*args, &block); end

  def context(); end

  def errmsg(*args, &block); end

  def frame(*args, &block); end

  def initialize(context, interface=T.unsafe(nil)); end

  def interface(); end

  def pr(*args, &block); end

  def prc(*args, &block); end

  def prev_line(); end

  def prev_line=(prev_line); end

  def printer(); end

  def proceed!(); end

  def process_commands(); end

  def prompt(); end

  def prv(*args, &block); end

  def puts(*args, &block); end

  def repl(); end
end

class Byebug::CommandProcessor
  extend ::Forwardable
end

class Byebug::ConditionCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::ConditionCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Context
  include ::Byebug::Helpers::FileHelper
  def at_breakpoint(breakpoint); end

  def at_catchpoint(exception); end

  def at_end(); end

  def at_line(); end

  def at_return(return_value); end

  def at_tracing(); end

  def backtrace(); end

  def dead?(); end

  def file(*args, &block); end

  def frame(); end

  def frame=(pos); end

  def frame_binding(*arg); end

  def frame_class(*arg); end

  def frame_file(*arg); end

  def frame_line(*arg); end

  def frame_method(*arg); end

  def frame_self(*arg); end

  def full_location(); end

  def ignored?(); end

  def interrupt(); end

  def line(*args, &block); end

  def location(); end

  def resume(); end

  def stack_size(); end

  def step_into(*arg); end

  def step_out(*arg); end

  def step_over(*arg); end

  def stop_reason(); end

  def suspend(); end

  def suspended?(); end

  def switch(); end

  def thnum(); end

  def thread(); end

  def tracing(); end

  def tracing=(tracing); end
end

class Byebug::Context
  extend ::Byebug::Helpers::PathHelper
  extend ::Forwardable
  def self.ignored_files(); end

  def self.ignored_files=(ignored_files); end

  def self.interface(); end

  def self.interface=(interface); end

  def self.processor(); end

  def self.processor=(processor); end
end

class Byebug::ContinueCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::ContinueCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ControlProcessor
  def commands(); end
end

class Byebug::ControlProcessor
end

class Byebug::DebugCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::DebugCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DebugThread
end

class Byebug::DebugThread
  def self.inherited(); end
end

class Byebug::DeleteCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DeleteCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand
  include ::Byebug::Subcommands
end

class Byebug::DisableCommand::BreakpointsCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DisableCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand::DisplayCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DisableCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisplayCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DownCommand
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DownCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EditCommand
  def execute(); end
end

class Byebug::EditCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand
  include ::Byebug::Subcommands
end

class Byebug::EnableCommand::BreakpointsCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::EnableCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand::DisplayCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::EnableCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::FinishCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::FinishCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Frame
  include ::Byebug::Helpers::FileHelper
  def _binding(); end

  def _class(); end

  def _method(); end

  def _self(); end

  def args(); end

  def c_frame?(); end

  def current?(); end

  def deco_args(); end

  def deco_block(); end

  def deco_call(); end

  def deco_class(); end

  def deco_file(); end

  def deco_method(); end

  def deco_pos(); end

  def file(); end

  def initialize(context, pos); end

  def line(); end

  def locals(); end

  def mark(); end

  def pos(); end

  def to_hash(); end
end

class Byebug::Frame
end

class Byebug::FrameCommand
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::FrameCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::FullpathSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::FullpathSetting
end

class Byebug::HelpCommand
  def execute(); end
end

class Byebug::HelpCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Helpers
end

module Byebug::Helpers::BinHelper
  def executable_file_extensions(); end

  def find_executable(path, cmd); end

  def real_executable?(file); end

  def search_paths(); end

  def which(cmd); end
end

module Byebug::Helpers::BinHelper
end

module Byebug::Helpers::EvalHelper
  def error_eval(str, binding=T.unsafe(nil)); end

  def multiple_thread_eval(expression); end

  def separate_thread_eval(expression); end

  def silent_eval(str, binding=T.unsafe(nil)); end

  def warning_eval(str, binding=T.unsafe(nil)); end
end

module Byebug::Helpers::EvalHelper
end

module Byebug::Helpers::FileHelper
  def get_line(filename, lineno); end

  def get_lines(filename); end

  def n_lines(filename); end

  def normalize(filename); end

  def shortpath(fullpath); end

  def virtual_file?(name); end
end

module Byebug::Helpers::FileHelper
end

module Byebug::Helpers::FrameHelper
  def jump_frames(steps); end

  def switch_to_frame(frame); end
end

module Byebug::Helpers::FrameHelper
end

module Byebug::Helpers::ParseHelper
  def get_int(str, cmd, min=T.unsafe(nil), max=T.unsafe(nil)); end

  def parse_steps(str, cmd); end

  def syntax_valid?(code); end
end

module Byebug::Helpers::ParseHelper
end

module Byebug::Helpers::PathHelper
  def all_files(); end

  def bin_file(); end

  def gem_files(); end

  def lib_files(); end

  def root_path(); end

  def test_files(); end
end

module Byebug::Helpers::PathHelper
end

module Byebug::Helpers::ReflectionHelper
  def commands(); end
end

module Byebug::Helpers::ReflectionHelper
end

module Byebug::Helpers::StringHelper
  def camelize(str); end

  def deindent(str, leading_spaces: T.unsafe(nil)); end

  def prettify(str); end
end

module Byebug::Helpers::StringHelper
end

module Byebug::Helpers::ThreadHelper
  def context_from_thread(thnum); end

  def current_thread?(ctx); end

  def display_context(ctx); end

  def thread_arguments(ctx); end
end

module Byebug::Helpers::ThreadHelper
end

module Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def enable_disable_breakpoints(is_enable, args); end

  def enable_disable_display(is_enable, args); end
end

module Byebug::Helpers::ToggleHelper
end

module Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def var_args(); end

  def var_global(); end

  def var_instance(str); end

  def var_list(ary, binding=T.unsafe(nil)); end

  def var_local(); end
end

module Byebug::Helpers::VarHelper
end

module Byebug::Helpers
end

class Byebug::HistfileSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistfileSetting
end

class Byebug::History
  def buffer(); end

  def clear(); end

  def default_max_size(); end

  def ignore?(buf); end

  def last_ids(number); end

  def pop(); end

  def push(cmd); end

  def restore(); end

  def save(); end

  def size(); end

  def size=(size); end

  def specific_max_size(number); end

  def to_s(n_cmds); end
end

class Byebug::History
end

class Byebug::HistoryCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::HistoryCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::HistsizeSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistsizeSetting
end

class Byebug::InfoCommand
  include ::Byebug::Subcommands
end

class Byebug::InfoCommand::BreakpointsCommand
  def execute(); end
end

class Byebug::InfoCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::DisplayCommand
  def execute(); end
end

class Byebug::InfoCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::FileCommand
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::StringHelper
  def execute(); end
end

class Byebug::InfoCommand::FileCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::LineCommand
  def execute(); end
end

class Byebug::InfoCommand::LineCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::ProgramCommand
  def execute(); end
end

class Byebug::InfoCommand::ProgramCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Interface
  include ::Byebug::Helpers::FileHelper
  def autorestore(); end

  def autosave(); end

  def close(); end

  def command_queue(); end

  def command_queue=(command_queue); end

  def confirm(prompt); end

  def errmsg(message); end

  def error(); end

  def history(); end

  def history=(history); end

  def input(); end

  def last_if_empty(input); end

  def output(); end

  def prepare_input(prompt); end

  def print(message); end

  def puts(message); end

  def read_command(prompt); end

  def read_file(filename); end

  def read_input(prompt, save_hist=T.unsafe(nil)); end
end

class Byebug::Interface
end

class Byebug::InterruptCommand
  def execute(); end
end

class Byebug::InterruptCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::IrbCommand
  def execute(); end
end

class Byebug::IrbCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::KillCommand
  def execute(); end
end

class Byebug::KillCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::LinetraceSetting
  def banner(); end

  def value=(val); end
end

class Byebug::LinetraceSetting
end

class Byebug::ListCommand
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::ParseHelper
  def amend_final(*args, &block); end

  def execute(); end

  def max_line(*args, &block); end

  def size(*args, &block); end
end

class Byebug::ListCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ListsizeSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ListsizeSetting
end

class Byebug::LocalInterface
  def readline(prompt); end

  def with_repl_like_sigint(); end

  def without_readline_completion(); end
  EOF_ALIAS = ::T.let(nil, ::T.untyped)
end

class Byebug::LocalInterface
end

class Byebug::MethodCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::MethodCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::NextCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::NextCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::PostMortemProcessor
  def commands(); end
end

class Byebug::PostMortemProcessor
end

class Byebug::PostMortemSetting
  def banner(); end

  def value=(val); end
end

class Byebug::PostMortemSetting
end

module Byebug::Printers
end

class Byebug::Printers::Base
  def type(); end
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Byebug::Printers::Base::MissedArgument
end

class Byebug::Printers::Base::MissedArgument
end

class Byebug::Printers::Base::MissedPath
end

class Byebug::Printers::Base::MissedPath
end

class Byebug::Printers::Base
end

class Byebug::Printers::Plain
  def print(path, args=T.unsafe(nil)); end

  def print_collection(path, collection, &block); end

  def print_variables(variables, *_unused); end
end

class Byebug::Printers::Plain
end

module Byebug::Printers
end

class Byebug::PryCommand
  def execute(); end
end

class Byebug::PryCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::PryProcessor
  def at_breakpoint(breakpoint); end

  def at_return(_return_value); end

  def bold(*args, &block); end

  def output(*args, &block); end

  def perform(action, options=T.unsafe(nil)); end

  def pry(); end

  def pry=(pry); end

  def run(&_block); end
end

class Byebug::PryProcessor
  def self.start(); end
end

class Byebug::QuitCommand
  def execute(); end
end

class Byebug::QuitCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Remote
end

class Byebug::Remote::Client
  def initialize(interface); end

  def interface(); end

  def socket(); end

  def start(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def started?(); end
end

class Byebug::Remote::Client
end

class Byebug::Remote::Server
  def actual_port(); end

  def initialize(wait_connection:, &block); end

  def start(host, port); end

  def wait_connection(); end
end

class Byebug::Remote::Server
end

module Byebug::Remote
end

class Byebug::RemoteInterface
  def initialize(socket); end

  def readline(prompt); end
end

class Byebug::RemoteInterface
end

class Byebug::RestartCommand
  include ::Byebug::Helpers::BinHelper
  include ::Byebug::Helpers::PathHelper
  def execute(); end
end

class Byebug::RestartCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SaveCommand
  def execute(); end
end

class Byebug::SaveCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SavefileSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::SavefileSetting
end

class Byebug::ScriptInterface
  def initialize(file, verbose=T.unsafe(nil)); end
end

class Byebug::ScriptInterface
end

class Byebug::ScriptProcessor
  def commands(); end
end

class Byebug::ScriptProcessor
end

class Byebug::SetCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::SetCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Setting
  def boolean?(); end

  def help(); end

  def integer?(); end

  def to_sym(); end

  def value(); end

  def value=(value); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Setting
  def self.[](name); end

  def self.[]=(name, value); end

  def self.find(shortcut); end

  def self.help_all(); end

  def self.settings(); end
end

class Byebug::ShowCommand
  def execute(); end
end

class Byebug::ShowCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SkipCommand
  include ::Byebug::Helpers::ParseHelper
  def auto_run(); end

  def execute(); end

  def initialize_attributes(); end

  def keep_execution(); end

  def reset_attributes(); end
end

class Byebug::SkipCommand
  def self.description(); end

  def self.file_line(); end

  def self.file_line=(file_line); end

  def self.file_path(); end

  def self.file_path=(file_path); end

  def self.previous_autolist(); end

  def self.regexp(); end

  def self.restore_autolist(); end

  def self.setup_autolist(value); end

  def self.short_description(); end
end

class Byebug::SourceCommand
  def execute(); end
end

class Byebug::SourceCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SourceFileFormatter
  include ::Byebug::Helpers::FileHelper
  def amend(line, ceiling); end

  def amend_final(line); end

  def amend_initial(line); end

  def annotator(); end

  def file(); end

  def initialize(file, annotator); end

  def lines(min, max); end

  def lines_around(center); end

  def max_initial_line(); end

  def max_line(); end

  def range_around(center); end

  def range_from(min); end

  def size(); end
end

class Byebug::SourceFileFormatter
end

class Byebug::StackOnErrorSetting
  def banner(); end
end

class Byebug::StackOnErrorSetting
end

class Byebug::StepCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::StepCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Subcommands
  def execute(); end

  def subcommand_list(*args, &block); end
end

module Byebug::Subcommands::ClassMethods
  include ::Byebug::Helpers::ReflectionHelper
  def help(); end

  def subcommand_list(); end
end

module Byebug::Subcommands::ClassMethods
end

module Byebug::Subcommands
  extend ::Forwardable
  def self.included(command); end
end

class Byebug::ThreadCommand
  include ::Byebug::Subcommands
end

class Byebug::ThreadCommand::CurrentCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::CurrentCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::ListCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::ListCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::ResumeCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::ResumeCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::StopCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::StopCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::SwitchCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::SwitchCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadsTable
end

class Byebug::ThreadsTable
end

class Byebug::TracevarCommand
  def execute(); end
end

class Byebug::TracevarCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UndisplayCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::UndisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UntracevarCommand
  def execute(); end
end

class Byebug::UntracevarCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UpCommand
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::UpCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand
  include ::Byebug::Subcommands
end

class Byebug::VarCommand::AllCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::AllCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::ArgsCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::ArgsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::ConstCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::ConstCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::GlobalCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::GlobalCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::InstanceCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::InstanceCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::LocalCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::LocalCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::WhereCommand
  include ::Byebug::Helpers::FrameHelper
  def execute(); end
end

class Byebug::WhereCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::WidthSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::WidthSetting
end

module Byebug
  extend ::Byebug
  extend ::Byebug::Helpers::ReflectionHelper
  def self.actual_control_port(); end

  def self.actual_port(); end

  def self.attach(); end

  def self.handle_post_mortem(); end

  def self.interrupt(); end

  def self.load_settings(); end

  def self.parse_host_and_port(host_port_spec); end

  def self.spawn(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_client(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_control(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_server(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.wait_connection(); end

  def self.wait_connection=(wait_connection); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

module CLI
end

module CLI::Kit
  EXIT_BUG = ::T.let(nil, ::T.untyped)
  EXIT_FAILURE_BUT_NOT_BUG = ::T.let(nil, ::T.untyped)
  EXIT_SUCCESS = ::T.let(nil, ::T.untyped)
end

class CLI::Kit::Abort
end

class CLI::Kit::Abort
end

class CLI::Kit::AbortSilent
end

class CLI::Kit::AbortSilent
end

module CLI::Kit::Autocall
  def autocall(const, &block); end

  def const_missing(const); end
end

module CLI::Kit::Autocall
end

class CLI::Kit::BaseCommand
  def call(_args, _command_name); end

  def has_subcommands?(); end

  def stats_tags(args, command_name); end
end

class CLI::Kit::BaseCommand
  def self.call(args, command_name); end

  def self.defined?(); end

  def self.statsd_increment(_metric, **_kwargs); end

  def self.statsd_time(_metric, **_kwargs); end
end

class CLI::Kit::Bug
end

class CLI::Kit::Bug
end

class CLI::Kit::BugSilent
end

class CLI::Kit::BugSilent
end

class CLI::Kit::CommandRegistry
  def add(const, name); end

  def add_alias(from, to); end

  def aliases(); end

  def command_names(); end

  def commands(); end

  def exist?(name); end

  def initialize(default:, contextual_resolver: T.unsafe(nil)); end

  def lookup_command(name); end

  def resolved_commands(); end
end

module CLI::Kit::CommandRegistry::NullContextualResolver
end

module CLI::Kit::CommandRegistry::NullContextualResolver
  def self.aliases(); end

  def self.command_class(_name); end

  def self.command_names(); end
end

class CLI::Kit::CommandRegistry
end

class CLI::Kit::Config
  def file(); end

  def get(section, name, default: T.unsafe(nil)); end

  def get_bool(section, name, default: T.unsafe(nil)); end

  def get_path(section, name=T.unsafe(nil)); end

  def get_section(section); end

  def initialize(tool_name:); end

  def set(section, name, value); end

  def unset(section, name); end
  XDG_CONFIG_HOME = ::T.let(nil, ::T.untyped)
end

class CLI::Kit::Config
end

class CLI::Kit::ErrorHandler
  def call(&block); end

  def exception=(exception); end

  def handle_exception(error); end

  def initialize(log_file:, exception_reporter:, tool_name: T.unsafe(nil)); end
end

module CLI::Kit::ErrorHandler::NullExceptionReporter
end

module CLI::Kit::ErrorHandler::NullExceptionReporter
  def self.report(_exception, _logs); end
end

class CLI::Kit::ErrorHandler
end

class CLI::Kit::Executor
  def call(command, command_name, args); end

  def initialize(log_file:); end
end

class CLI::Kit::Executor
end

class CLI::Kit::GenericAbort
end

class CLI::Kit::GenericAbort
end

class CLI::Kit::Ini
  def git_format(); end

  def ini(); end

  def ini=(ini); end

  def initialize(path=T.unsafe(nil), config: T.unsafe(nil), default_section: T.unsafe(nil), convert_types: T.unsafe(nil)); end

  def parse(); end
end

class CLI::Kit::Ini
end

module CLI::Kit::Levenshtein
end

module CLI::Kit::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class CLI::Kit::Logger
  def debug(msg); end

  def error(msg, debug: T.unsafe(nil)); end

  def fatal(msg, debug: T.unsafe(nil)); end

  def info(msg, debug: T.unsafe(nil)); end

  def initialize(debug_log_file:, env_debug_name: T.unsafe(nil)); end

  def warn(msg, debug: T.unsafe(nil)); end
  MAX_LOG_SIZE = ::T.let(nil, ::T.untyped)
  MAX_NUM_LOGS = ::T.let(nil, ::T.untyped)
end

class CLI::Kit::Logger
end

class CLI::Kit::Resolver
  def call(args); end

  def initialize(tool_name:, command_registry:); end
end

class CLI::Kit::Resolver
end

module CLI::Kit::Support
end

module CLI::Kit::Support::TestHelper
  def assert_all_commands_run(should_raise: T.unsafe(nil)); end

  def setup(); end

  def teardown(); end
end

module CLI::Kit::Support::TestHelper::FakeConfig
  def setup(); end

  def teardown(); end
end

module CLI::Kit::Support::TestHelper::FakeConfig
end

class CLI::Kit::Support::TestHelper::FakeSuccess
  def initialize(success); end

  def success?(); end
end

class CLI::Kit::Support::TestHelper::FakeSuccess
end

module CLI::Kit::Support::TestHelper
end

module CLI::Kit::Support
end

module CLI::Kit::System
  SUDO_PROMPT = ::T.let(nil, ::T.untyped)
end

module CLI::Kit::System
  def self.capture2(*a, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs); end

  def self.capture2e(*a, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs); end

  def self.capture3(*a, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs); end

  def self.error_message(); end

  def self.fake(*a, stdout: T.unsafe(nil), stderr: T.unsafe(nil), allow: T.unsafe(nil), success: T.unsafe(nil), sudo: T.unsafe(nil), env: T.unsafe(nil)); end

  def self.original_capture2(*a, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs); end

  def self.original_capture2e(*a, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs); end

  def self.original_capture3(*a, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs); end

  def self.original_system(*a, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs); end

  def self.os(); end

  def self.popen2(*a, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs, &block); end

  def self.popen2e(*a, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs, &block); end

  def self.popen3(*a, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs, &block); end

  def self.reset!(); end

  def self.split_partial_characters(data); end

  def self.sudo_reason(msg); end

  def self.system(*a, sudo: T.unsafe(nil), env: T.unsafe(nil), **kwargs); end
end

module CLI::Kit::Util
end

module CLI::Kit::Util
  def self.begin(&block_that_might_raise); end

  def self.ci?(); end

  def self.dash_case(camel_case); end

  def self.english_join(array); end

  def self.integration_test_session?(); end

  def self.snake_case(camel_case, seperator=T.unsafe(nil)); end

  def self.strip_heredoc(str); end

  def self.testing?(); end

  def self.to_filesize(bytes, precision: T.unsafe(nil), space: T.unsafe(nil)); end

  def self.to_si_scale(number, unit=T.unsafe(nil), factor: T.unsafe(nil), precision: T.unsafe(nil), space: T.unsafe(nil)); end

  def self.with_dir(dir); end

  def self.with_environment(environment, value); end

  def self.with_tmp_dir(); end
end

module CLI::Kit
end

module CLI::UI
end

module CLI::UI::ANSI
  ESC = ::T.let(nil, ::T.untyped)
end

module CLI::UI::ANSI
  def self.clear_to_end_of_line(); end

  def self.control(args, cmd); end

  def self.cursor_back(n=T.unsafe(nil)); end

  def self.cursor_down(n=T.unsafe(nil)); end

  def self.cursor_forward(n=T.unsafe(nil)); end

  def self.cursor_horizontal_absolute(n=T.unsafe(nil)); end

  def self.cursor_restore(); end

  def self.cursor_save(); end

  def self.cursor_up(n=T.unsafe(nil)); end

  def self.hide_cursor(); end

  def self.next_line(); end

  def self.previous_line(); end

  def self.printing_width(str); end

  def self.sgr(params); end

  def self.show_cursor(); end

  def self.strip_codes(str); end
end

class CLI::UI::Color
  def code(); end

  def initialize(sgr, name); end

  def name(); end

  def sgr(); end
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GRAY = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  MAP = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  RESET = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class CLI::UI::Color::InvalidColorName
  def initialize(name); end
end

class CLI::UI::Color::InvalidColorName
end

class CLI::UI::Color
  def self.available(); end

  def self.lookup(name); end
end

class CLI::UI::Formatter
  def format(sgr_map=T.unsafe(nil), enable_color: T.unsafe(nil)); end

  def initialize(text); end
  BEGIN_EXPR = ::T.let(nil, ::T.untyped)
  DISCARD_BRACES = ::T.let(nil, ::T.untyped)
  END_EXPR = ::T.let(nil, ::T.untyped)
  LITERAL_BRACES = ::T.let(nil, ::T.untyped)
  SCAN_BODY = ::T.let(nil, ::T.untyped)
  SCAN_FUNCNAME = ::T.let(nil, ::T.untyped)
  SCAN_GLYPH = ::T.let(nil, ::T.untyped)
  SCAN_WIDGET = ::T.let(nil, ::T.untyped)
  SGR_MAP = ::T.let(nil, ::T.untyped)
end

class CLI::UI::Formatter::FormatError
  def index(); end

  def index=(index); end

  def initialize(message=T.unsafe(nil), input=T.unsafe(nil), index=T.unsafe(nil)); end

  def input(); end

  def input=(input); end
end

class CLI::UI::Formatter::FormatError
end

class CLI::UI::Formatter
end

module CLI::UI::Frame
end

module CLI::UI::Frame::FrameStack
  COLOR_ENVVAR = ::T.let(nil, ::T.untyped)
  STYLE_ENVVAR = ::T.let(nil, ::T.untyped)
end

class CLI::UI::Frame::FrameStack::StackItem
  def color(); end

  def frame_style(); end

  def initialize(color_name, style_name); end
end

class CLI::UI::Frame::FrameStack::StackItem
end

module CLI::UI::Frame::FrameStack
  def self.items(); end

  def self.pop(); end

  def self.push(item=T.unsafe(nil), color: T.unsafe(nil), style: T.unsafe(nil)); end
end

module CLI::UI::Frame::FrameStyle
end

module CLI::UI::Frame::FrameStyle::Box
  BOTTOM_LEFT = ::T.let(nil, ::T.untyped)
  DIVIDER = ::T.let(nil, ::T.untyped)
  HORIZONTAL = ::T.let(nil, ::T.untyped)
  TOP_LEFT = ::T.let(nil, ::T.untyped)
  VERTICAL = ::T.let(nil, ::T.untyped)
end

module CLI::UI::Frame::FrameStyle::Box
  extend ::CLI::UI::Frame::FrameStyle
  extend ::CLI::UI::Frame::FrameStyle::Interface
  def self.divider(text, color:); end
end

module CLI::UI::Frame::FrameStyle::Bracket
  BOTTOM_LEFT = ::T.let(nil, ::T.untyped)
  DIVIDER = ::T.let(nil, ::T.untyped)
  HORIZONTAL = ::T.let(nil, ::T.untyped)
  TOP_LEFT = ::T.let(nil, ::T.untyped)
  VERTICAL = ::T.let(nil, ::T.untyped)
end

module CLI::UI::Frame::FrameStyle::Bracket
  extend ::CLI::UI::Frame::FrameStyle
  extend ::CLI::UI::Frame::FrameStyle::Interface
  def self.divider(text, color:); end
end

module CLI::UI::Frame::FrameStyle::Interface
  def close(text, color:, right_text: T.unsafe(nil)); end

  def divider(text, color: T.unsafe(nil)); end

  def name(); end

  def open(text, color:); end

  def prefix(); end

  def prefix_width(); end
end

module CLI::UI::Frame::FrameStyle::Interface
end

class CLI::UI::Frame::FrameStyle::InvalidFrameStyleName
  def initialize(name); end
end

class CLI::UI::Frame::FrameStyle::InvalidFrameStyleName
end

module CLI::UI::Frame::FrameStyle
  def self.extended(base); end

  def self.loaded_styles(); end

  def self.lookup(name); end
end

class CLI::UI::Frame::UnnestedFrameException
end

class CLI::UI::Frame::UnnestedFrameException
end

module CLI::UI::Frame
  def self.close(text, color: T.unsafe(nil), elapsed: T.unsafe(nil), frame_style: T.unsafe(nil)); end

  def self.divider(text, color: T.unsafe(nil), frame_style: T.unsafe(nil)); end

  def self.frame_style(); end

  def self.frame_style=(frame_style); end

  def self.open(text, color: T.unsafe(nil), failure_text: T.unsafe(nil), success_text: T.unsafe(nil), timing: T.unsafe(nil), frame_style: T.unsafe(nil)); end

  def self.prefix(color: T.unsafe(nil)); end

  def self.prefix_width(); end

  def self.with_frame_color_override(color); end
end

class CLI::UI::Glyph
  def char(); end

  def codepoint(); end

  def color(); end

  def fmt(); end

  def handle(); end

  def initialize(handle, codepoint, plain, color); end
  BUG = ::T.let(nil, ::T.untyped)
  CHECK = ::T.let(nil, ::T.untyped)
  CHEVRON = ::T.let(nil, ::T.untyped)
  HOURGLASS = ::T.let(nil, ::T.untyped)
  INFO = ::T.let(nil, ::T.untyped)
  MAP = ::T.let(nil, ::T.untyped)
  QUESTION = ::T.let(nil, ::T.untyped)
  STAR = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
  X = ::T.let(nil, ::T.untyped)
end

class CLI::UI::Glyph::InvalidGlyphHandle
  def initialize(handle); end
end

class CLI::UI::Glyph::InvalidGlyphHandle
end

class CLI::UI::Glyph
  def self.available(); end

  def self.lookup(name); end
end

module CLI::UI::OS
end

class CLI::UI::OS::Linux
end

class CLI::UI::OS::Linux
end

class CLI::UI::OS::Mac
end

class CLI::UI::OS::Mac
  def self.shift_cursor_on_line_reset?(); end

  def self.supports_arrow_keys?(); end

  def self.supports_color_prompt?(); end

  def self.supports_emoji?(); end
end

class CLI::UI::OS::Windows
end

class CLI::UI::OS::Windows
  def self.shift_cursor_on_line_reset?(); end

  def self.supports_arrow_keys?(); end

  def self.supports_color_prompt?(); end

  def self.supports_emoji?(); end
end

module CLI::UI::OS
  def self.current(); end
end

class CLI::UI::Printer
end

class CLI::UI::Printer
  def self.puts(msg, frame_color: T.unsafe(nil), to: T.unsafe(nil), encoding: T.unsafe(nil), format: T.unsafe(nil), graceful: T.unsafe(nil), wrap: T.unsafe(nil)); end
end

class CLI::UI::Progress
  def initialize(width: T.unsafe(nil)); end

  def tick(percent: T.unsafe(nil), set_percent: T.unsafe(nil)); end
  FILLED_BAR = ::T.let(nil, ::T.untyped)
  UNFILLED_BAR = ::T.let(nil, ::T.untyped)
end

class CLI::UI::Progress
  def self.progress(width: T.unsafe(nil)); end
end

module CLI::UI::Prompt
end

module CLI::UI::Prompt
  def self.ask(question, options: T.unsafe(nil), default: T.unsafe(nil), is_file: T.unsafe(nil), allow_empty: T.unsafe(nil), multiple: T.unsafe(nil), filter_ui: T.unsafe(nil), select_ui: T.unsafe(nil), &options_proc); end

  def self.ask_password(question); end

  def self.confirm(question, default: T.unsafe(nil)); end
end

CLI::UI::SpinGroup = CLI::UI::Spinner::SpinGroup

module CLI::UI::Spinner
  GLYPHS = ::T.let(nil, ::T.untyped)
  PERIOD = ::T.let(nil, ::T.untyped)
  RUNES = ::T.let(nil, ::T.untyped)
  TASK_FAILED = ::T.let(nil, ::T.untyped)
end

class CLI::UI::Spinner::Async
  def initialize(title); end

  def stop(); end
end

class CLI::UI::Spinner::Async
  def self.start(title); end
end

class CLI::UI::Spinner::SpinGroup
  def add(title, &block); end

  def debrief(); end

  def initialize(auto_debrief: T.unsafe(nil)); end

  def wait(); end
end

class CLI::UI::Spinner::SpinGroup::Task
  def check(); end

  def exception(); end

  def initialize(title, &block); end

  def render(index, force=T.unsafe(nil), width: T.unsafe(nil)); end

  def stderr(); end

  def stdout(); end

  def success(); end

  def title(); end

  def update_title(new_title); end
end

class CLI::UI::Spinner::SpinGroup::Task
end

class CLI::UI::Spinner::SpinGroup
end

module CLI::UI::Spinner
  def self.current_rune(); end

  def self.index(); end

  def self.index=(index); end

  def self.spin(title, auto_debrief: T.unsafe(nil), &block); end
end

module CLI::UI::StdoutRouter
end

class CLI::UI::StdoutRouter::Capture
  def initialize(*block_args, with_frame_inset: T.unsafe(nil), &block); end

  def run(); end

  def stderr(); end

  def stdout(); end
end

class CLI::UI::StdoutRouter::Capture
  def self.with_stdin_masked(); end
end

class CLI::UI::StdoutRouter::Writer
  def initialize(stream, name); end

  def write(*args); end
end

class CLI::UI::StdoutRouter::Writer
end

module CLI::UI::StdoutRouter
  def self.assert_enabled!(); end

  def self.current_id(); end

  def self.disable(); end

  def self.duplicate_output_to(); end

  def self.duplicate_output_to=(duplicate_output_to); end

  def self.enable(); end

  def self.enabled?(stream=T.unsafe(nil)); end

  def self.ensure_activated(); end

  def self.with_enabled(); end

  def self.with_id(on_streams:); end
end

module CLI::UI::Terminal
  DEFAULT_HEIGHT = ::T.let(nil, ::T.untyped)
  DEFAULT_WIDTH = ::T.let(nil, ::T.untyped)
end

module CLI::UI::Terminal
  def self.height(); end

  def self.setup_winsize_trap(); end

  def self.width(); end

  def self.winsize(); end
end

module CLI::UI::Truncater
  EMOJI_RANGE = ::T.let(nil, ::T.untyped)
  ESC = ::T.let(nil, ::T.untyped)
  LC_ALPHA_RANGE = ::T.let(nil, ::T.untyped)
  LEFT_SQUARE_BRACKET = ::T.let(nil, ::T.untyped)
  NUMERIC_RANGE = ::T.let(nil, ::T.untyped)
  PARSE_ANSI = ::T.let(nil, ::T.untyped)
  PARSE_ESC = ::T.let(nil, ::T.untyped)
  PARSE_ROOT = ::T.let(nil, ::T.untyped)
  PARSE_ZWJ = ::T.let(nil, ::T.untyped)
  SEMICOLON = ::T.let(nil, ::T.untyped)
  TRUNCATED = ::T.let(nil, ::T.untyped)
  UC_ALPHA_RANGE = ::T.let(nil, ::T.untyped)
  ZWJ = ::T.let(nil, ::T.untyped)
end

module CLI::UI::Truncater
  def self.call(text, printing_width); end
end

module CLI::UI::Widgets
  MAP = ::T.let(nil, ::T.untyped)
end

class CLI::UI::Widgets::Base
  def initialize(argstring); end
end

class CLI::UI::Widgets::Base
  def self.argparse_pattern(); end

  def self.call(argstring); end
end

class CLI::UI::Widgets::InvalidWidgetArguments
  def initialize(argstring, pattern); end
end

class CLI::UI::Widgets::InvalidWidgetArguments
end

class CLI::UI::Widgets::InvalidWidgetHandle
  def initialize(handle); end
end

class CLI::UI::Widgets::InvalidWidgetHandle
end

class CLI::UI::Widgets::Status
  def render(); end
  ARGPARSE_PATTERN = ::T.let(nil, ::T.untyped)
  ARROW = ::T.let(nil, ::T.untyped)
  CLOSE = ::T.let(nil, ::T.untyped)
  COMMA = ::T.let(nil, ::T.untyped)
  EMPTY_SET = ::T.let(nil, ::T.untyped)
  OPEN = ::T.let(nil, ::T.untyped)
  SPINNER_STOPPED = ::T.let(nil, ::T.untyped)
end

class CLI::UI::Widgets::Status
end

module CLI::UI::Widgets
  def self.available(); end

  def self.lookup(handle); end

  def self.register(name, &cb); end
end

class CLI::UI::Wrap
  def initialize(input); end

  def wrap(); end
end

class CLI::UI::Wrap
end

module CLI::UI
  def self.ask(question, **kwargs); end

  def self.confirm(question, **kwargs); end

  def self.enable_color=(bool); end

  def self.enable_color?(); end

  def self.fmt(input, enable_color: T.unsafe(nil)); end

  def self.frame(*args, **kwargs, &block); end

  def self.frame_style=(frame_style); end

  def self.glyph(handle); end

  def self.log_output_to(path); end

  def self.puts(msg, **kwargs); end

  def self.raw(); end

  def self.resolve_color(input); end

  def self.resolve_style(input); end

  def self.resolve_text(input, truncate_to: T.unsafe(nil)); end

  def self.spinner(*args, **kwargs, &block); end

  def self.with_frame_color(color, &block); end

  def self.wrap(input); end
end

module CLI
end

class Class
  def json_creatable?(); end
end

module CodeRay
  CODERAY_PATH = ::T.let(nil, ::T.untyped)
  TokenKinds = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class CodeRay::Duo
  def call(code, options=T.unsafe(nil)); end

  def encode(code, options=T.unsafe(nil)); end

  def encoder(); end

  def format(); end

  def format=(format); end

  def highlight(code, options=T.unsafe(nil)); end

  def initialize(lang=T.unsafe(nil), format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def lang=(lang); end

  def options(); end

  def options=(options); end

  def scanner(); end
end

class CodeRay::Duo
  def self.[](*arg); end
end

module CodeRay::Encoders
end

class CodeRay::Encoders::Encoder
  def <<(token); end

  def begin_group(kind); end

  def begin_line(kind); end

  def compile(tokens, options=T.unsafe(nil)); end

  def encode(code, lang, options=T.unsafe(nil)); end

  def encode_tokens(tokens, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def file_extension(); end

  def finish(options); end

  def get_output(options); end

  def highlight(code, lang, options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def output(data); end

  def scanner(); end

  def scanner=(scanner); end

  def setup(options); end

  def text_token(text, kind); end

  def token(content, kind); end

  def tokens(tokens, options=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Encoders::Encoder::PLUGIN_HOST = CodeRay::Encoders

class CodeRay::Encoders::Encoder
  extend ::CodeRay::Plugin
  def self.const_missing(sym); end

  def self.file_extension(); end
end

class CodeRay::Encoders::Terminal
  TOKEN_COLORS = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::Terminal
end

module CodeRay::Encoders
  extend ::CodeRay::PluginHost
end

module CodeRay::FileType
  TypeFromExt = ::T.let(nil, ::T.untyped)
  TypeFromName = ::T.let(nil, ::T.untyped)
  TypeFromShebang = ::T.let(nil, ::T.untyped)
end

class CodeRay::FileType::UnknownFileType
end

class CodeRay::FileType::UnknownFileType
end

module CodeRay::FileType
  def self.[](filename, read_shebang=T.unsafe(nil)); end

  def self.fetch(filename, default=T.unsafe(nil), read_shebang=T.unsafe(nil)); end

  def self.type_from_shebang(filename); end
end

module CodeRay::Plugin
  def aliases(); end

  def plugin_host(host=T.unsafe(nil)); end

  def plugin_id(); end

  def register_for(id); end

  def title(title=T.unsafe(nil)); end
end

module CodeRay::Plugin
end

module CodeRay::PluginHost
  def [](id, *args, &blk); end

  def all_plugins(); end

  def const_missing(const); end

  def default(id=T.unsafe(nil)); end

  def list(); end

  def load(id, *args, &blk); end

  def load_all(); end

  def load_plugin_map(); end

  def make_plugin_hash(); end

  def map(hash); end

  def path_to(plugin_id); end

  def plugin_hash(); end

  def plugin_path(*args); end

  def register(plugin, id); end

  def validate_id(id); end
  PLUGIN_HOSTS = ::T.let(nil, ::T.untyped)
  PLUGIN_HOSTS_BY_ID = ::T.let(nil, ::T.untyped)
end

class CodeRay::PluginHost::HostNotFound
end

class CodeRay::PluginHost::HostNotFound
end

class CodeRay::PluginHost::PluginNotFound
end

class CodeRay::PluginHost::PluginNotFound
end

module CodeRay::PluginHost
  def self.extended(mod); end
end

module CodeRay::Scanners
end

class CodeRay::Scanners::Scanner
  include ::Enumerable
  def binary_string(); end

  def column(pos=T.unsafe(nil)); end

  def each(&block); end

  def file_extension(); end

  def initialize(code=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def line(pos=T.unsafe(nil)); end

  def raise_inspect(message, tokens, state=T.unsafe(nil), ambit=T.unsafe(nil), backtrace=T.unsafe(nil)); end

  def raise_inspect_arguments(message, tokens, state, ambit); end

  def reset_instance(); end

  def scan_rest(); end

  def scan_tokens(tokens, options); end

  def scanner_state_info(state); end

  def set_string_from_source(source); end

  def set_tokens_from_options(options); end

  def setup(); end

  def state(); end

  def state=(state); end

  def string=(code); end

  def tokenize(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def tokens(); end

  def tokens_last(tokens, n); end

  def tokens_size(tokens); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  KINDS_NOT_LOC = ::T.let(nil, ::T.untyped)
  SCANNER_STATE_INFO = ::T.let(nil, ::T.untyped)
  SCAN_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

CodeRay::Scanners::Scanner::PLUGIN_HOST = CodeRay::Scanners

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner
  extend ::CodeRay::Plugin
  def self.encode_with_encoding(code, target_encoding); end

  def self.encoding(name=T.unsafe(nil)); end

  def self.file_extension(extension=T.unsafe(nil)); end

  def self.guess_encoding(s); end

  def self.lang(); end

  def self.normalize(code); end

  def self.to_unix(code); end
end

module CodeRay::Scanners
  extend ::CodeRay::PluginHost
end

module CodeRay::Styles
end

class CodeRay::Styles::Style
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Styles::Style::PLUGIN_HOST = CodeRay::Styles

class CodeRay::Styles::Style
  extend ::CodeRay::Plugin
end

module CodeRay::Styles
  extend ::CodeRay::PluginHost
end

class CodeRay::Tokens
  def begin_group(kind); end

  def begin_line(kind); end

  def count(); end

  def encode(encoder, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def method_missing(meth, options=T.unsafe(nil)); end

  def scanner(); end

  def scanner=(scanner); end

  def split_into_parts(*sizes); end

  def text_token(*arg); end

  def tokens(*arg); end
end

class CodeRay::Tokens
end

class CodeRay::TokensProxy
  def block(); end

  def block=(block); end

  def each(*args, &blk); end

  def encode(encoder, options=T.unsafe(nil)); end

  def initialize(input, lang, options=T.unsafe(nil), block=T.unsafe(nil)); end

  def input(); end

  def input=(input); end

  def lang(); end

  def lang=(lang); end

  def method_missing(method, *args, &blk); end

  def options(); end

  def options=(options); end

  def scanner(); end

  def tokens(); end
end

class CodeRay::TokensProxy
end

module CodeRay
  def self.coderay_path(*path); end

  def self.encode(code, lang, format, options=T.unsafe(nil)); end

  def self.encode_file(filename, format, options=T.unsafe(nil)); end

  def self.encode_tokens(tokens, format, options=T.unsafe(nil)); end

  def self.encoder(format, options=T.unsafe(nil)); end

  def self.get_scanner_options(options); end

  def self.highlight(code, lang, options=T.unsafe(nil), format=T.unsafe(nil)); end

  def self.highlight_file(filename, options=T.unsafe(nil), format=T.unsafe(nil)); end

  def self.scan(code, lang, options=T.unsafe(nil), &block); end

  def self.scan_file(filename, lang=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.scanner(lang, options=T.unsafe(nil), &block); end
end

module Colorize
end

module Colorize::ClassMethods
  def color_codes(); end

  def color_matrix(_=T.unsafe(nil)); end

  def color_methods(); end

  def color_samples(); end

  def colors(); end

  def disable_colorization(value=T.unsafe(nil)); end

  def disable_colorization=(value); end

  def mode_codes(); end

  def modes(); end

  def modes_methods(); end
end

module Colorize::ClassMethods
end

module Colorize::InstanceMethods
  def colorize(params); end

  def colorized?(); end

  def uncolorize(); end
end

module Colorize::InstanceMethods
end

module Colorize
end

class Date
  def infinite?(); end

  def to_liquid(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Delegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class DidYouMean::ClassNameChecker
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

class DidYouMean::CorrectElement
  def call(names, element); end
end

class DidYouMean::CorrectElement
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

module DidYouMean::Jaro
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def names_to_exclude(); end

  def receiver(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::NullChecker
  def corrections(); end

  def initialize(*arg); end
end

class DidYouMean::ParseDimensions
  def call(); end

  def initialize(dictionary, separator); end
end

class DidYouMean::ParseDimensions
end

class DidYouMean::PlainFormatter
  def message_for(corrections); end
end

class DidYouMean::PlainFormatter
end

class DidYouMean::TreeSpellChecker
  def augment(); end

  def correct(input); end

  def dictionary(); end

  def dimensions(); end

  def initialize(dictionary:, separator: T.unsafe(nil), augment: T.unsafe(nil)); end

  def separator(); end
end

class DidYouMean::TreeSpellChecker
end

class DidYouMean::VariableNameChecker
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.correct_error(error_class, spell_checker); end

  def self.formatter(); end

  def self.formatter=(formatter); end
end

class Dir
  def children(); end

  def each_child(); end
end

module Dir::Tmpname
  UNUSABLE_CHARS = ::T.let(nil, ::T.untyped)
end

class Dir
  def self.exists?(arg); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

class Encoding
  def _dump(*arg); end
  CESU_8 = ::T.let(nil, ::T.untyped)
end

class Encoding::Converter
  def initialize(*arg); end
end

class Encoding
  def self._load(arg); end
end

module Enumerable
  def sum(*arg); end
end

class Enumerator
  def +(arg); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*arg); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*arg, &blk); end

  def initialize(*arg); end
end

class Enumerator::Lazy
  def eager(); end
end

class Enumerator::Producer
  def each(&blk); end
end

class Enumerator::Producer
end

class Enumerator::Yielder
  def to_proc(); end
end

class Enumerator
  def self.produce(*arg); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

module Etc
  VERSION = ::T.let(nil, ::T.untyped)
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*arg); end

  def self.each(&blk); end

  def self.members(); end
end

class Exception
  def __bb_context(); end
end

class ExitCalledError
end

class ExitCalledError
end

class Extension::Command::Serve::RuntimeConfiguration
  include ::SmartProperties
end

class Extension::Command::Serve::RuntimeConfiguration
  extend ::SmartProperties::ClassMethods
end

class Extension::Features::Argo
  include ::SmartProperties
end

class Extension::Features::Argo
  extend ::SmartProperties::ClassMethods
end

class Extension::Features::ArgoServe
  include ::SmartProperties
end

class Extension::Features::ArgoServe
  extend ::SmartProperties::ClassMethods
end

class Extension::Features::ArgoSetup
  include ::SmartProperties
end

class Extension::Features::ArgoSetup
  extend ::SmartProperties::ClassMethods
end

class Extension::Features::ArgoSetupStep
  include ::SmartProperties
end

class Extension::Features::ArgoSetupStep
  extend ::SmartProperties::ClassMethods
end

class Extension::Forms::Connect
  def type(); end

  def type=(type); end
end

class Extension::Forms::Connect::ExtensionProjectDetails
  include ::SmartProperties
end

class Extension::Forms::Connect::ExtensionProjectDetails
  extend ::SmartProperties::ClassMethods
end

class Extension::Forms::Create
  def api_key(); end

  def api_key=(api_key); end

  def name(); end

  def name=(name); end

  def template(); end

  def template=(template); end

  def type(); end

  def type=(type); end
end

class Extension::Forms::Create::ExtensionProjectDetails
  include ::SmartProperties
end

class Extension::Forms::Create::ExtensionProjectDetails
  extend ::SmartProperties::ClassMethods
end

class Extension::Forms::Questions::AskApp
  include ::SmartProperties
  include ::ShopifyCLI::MethodObject::AutoCreateResultObject
end

class Extension::Forms::Questions::AskApp
  extend ::SmartProperties::ClassMethods
end

class Extension::Forms::Questions::AskName
  include ::SmartProperties
  include ::ShopifyCLI::MethodObject::AutoCreateResultObject
end

class Extension::Forms::Questions::AskName
  extend ::SmartProperties::ClassMethods
end

class Extension::Forms::Questions::AskRegistration
  include ::SmartProperties
  include ::ShopifyCLI::MethodObject::AutoCreateResultObject
end

class Extension::Forms::Questions::AskRegistration
  extend ::SmartProperties::ClassMethods
end

class Extension::Forms::Questions::AskTemplate
  include ::SmartProperties
  include ::ShopifyCLI::MethodObject::AutoCreateResultObject
end

class Extension::Forms::Questions::AskTemplate
  extend ::SmartProperties::ClassMethods
end

class Extension::Forms::Questions::AskType
  include ::SmartProperties
  include ::ShopifyCLI::MethodObject::AutoCreateResultObject
end

class Extension::Forms::Questions::AskType
  extend ::SmartProperties::ClassMethods
end

class Extension::Models::App
  include ::SmartProperties
end

class Extension::Models::App
  extend ::SmartProperties::ClassMethods
end

class Extension::Models::DevelopmentServer
  include ::SmartProperties
end

class Extension::Models::DevelopmentServer
  extend ::SmartProperties::ClassMethods
end

class Extension::Models::LazySpecificationHandler
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Extension::Models::NpmPackage
  def self.[](*arg); end

  def self.members(); end
end

class Extension::Models::Product
  include ::SmartProperties
end

class Extension::Models::Product
  extend ::SmartProperties::ClassMethods
end

class Extension::Models::Registration
  include ::SmartProperties
end

class Extension::Models::Registration
  extend ::SmartProperties::ClassMethods
end

class Extension::Models::ServerConfig::App
  include ::SmartProperties
end

class Extension::Models::ServerConfig::App
  extend ::SmartProperties::ClassMethods
end

class Extension::Models::ServerConfig::Development
  include ::SmartProperties
end

class Extension::Models::ServerConfig::Development
  extend ::SmartProperties::ClassMethods
end

class Extension::Models::ServerConfig::DevelopmentEntries
  include ::SmartProperties
end

class Extension::Models::ServerConfig::DevelopmentEntries
  extend ::SmartProperties::ClassMethods
end

class Extension::Models::ServerConfig::DevelopmentRenderer
  include ::SmartProperties
end

class Extension::Models::ServerConfig::DevelopmentRenderer
  extend ::SmartProperties::ClassMethods
end

class Extension::Models::ServerConfig::DevelopmentResource
  include ::SmartProperties
end

class Extension::Models::ServerConfig::DevelopmentResource
  extend ::SmartProperties::ClassMethods
end

class Extension::Models::ServerConfig::Extension
  include ::SmartProperties
end

class Extension::Models::ServerConfig::Extension
  extend ::SmartProperties::ClassMethods
end

class Extension::Models::ServerConfig::Root
  include ::SmartProperties
end

class Extension::Models::ServerConfig::Root
  extend ::SmartProperties::ClassMethods
end

class Extension::Models::ServerConfig::User
  include ::SmartProperties
end

class Extension::Models::ServerConfig::User
  extend ::SmartProperties::ClassMethods
end

class Extension::Models::Specification
  include ::SmartProperties
end

class Extension::Models::Specification::Features::Argo
  include ::SmartProperties
end

class Extension::Models::Specification::Features::Argo
  extend ::SmartProperties::ClassMethods
end

class Extension::Models::Specification
  extend ::SmartProperties::ClassMethods
end

class Extension::Models::Specifications
  include ::SmartProperties
end

class Extension::Models::Specifications
  extend ::SmartProperties::ClassMethods
end

class Extension::Models::ValidationError
  include ::SmartProperties
end

class Extension::Models::ValidationError
  extend ::SmartProperties::ClassMethods
end

class Extension::Models::Version
  include ::SmartProperties
end

class Extension::Models::Version
  extend ::SmartProperties::ClassMethods
end

class Extension::Tasks::ChooseNextAvailablePort
  include ::SmartProperties
  include ::ShopifyCLI::MethodObject::AutoCreateResultObject
end

class Extension::Tasks::ChooseNextAvailablePort
  extend ::SmartProperties::ClassMethods
end

class Extension::Tasks::ConfigureFeatures
  include ::SmartProperties
  include ::ShopifyCLI::MethodObject::AutoCreateResultObject
end

class Extension::Tasks::ConfigureFeatures
  extend ::SmartProperties::ClassMethods
end

class Extension::Tasks::ConfigureFeaturesTest
end

class Extension::Tasks::ConfigureOptions
  include ::SmartProperties
  include ::ShopifyCLI::MethodObject::AutoCreateResultObject
end

class Extension::Tasks::ConfigureOptions
  extend ::SmartProperties::ClassMethods
end

class Extension::Tasks::ConvertServerConfig
  include ::SmartProperties
end

class Extension::Tasks::ConvertServerConfig
  extend ::SmartProperties::ClassMethods
end

class Extension::Tasks::EnsureResourceUrl
  include ::SmartProperties
end

class Extension::Tasks::EnsureResourceUrl
  extend ::SmartProperties::ClassMethods
end

class Extension::Tasks::ExecuteCommands::Base
  include ::SmartProperties
end

class Extension::Tasks::ExecuteCommands::Base
  extend ::SmartProperties::ClassMethods
end

class Extension::Tasks::FetchSpecifications
  include ::SmartProperties
  include ::ShopifyCLI::MethodObject::AutoCreateResultObject
end

class Extension::Tasks::FetchSpecifications
  extend ::SmartProperties::ClassMethods
end

class Extension::Tasks::FindNpmPackages
  include ::SmartProperties
  include ::ShopifyCLI::MethodObject::AutoCreateResultObject
end

class Extension::Tasks::FindNpmPackages
  extend ::SmartProperties::ClassMethods
end

class Extension::Tasks::FindPackageFromJson
  include ::SmartProperties
end

class Extension::Tasks::FindPackageFromJson
  extend ::SmartProperties::ClassMethods
end

class Extension::Tasks::MergeServerConfig
  include ::SmartProperties
end

class Extension::Tasks::MergeServerConfig
  extend ::SmartProperties::ClassMethods
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
  def to_liquid(); end
end

class Fiber
  def initialize(*arg); end

  def transfer(*arg); end
end

class Fiber
  def self.current(); end
end

class File
  def self.absolute_path?(arg); end

  def self.exists?(arg); end
end

FileList = Rake::FileList

module FileUtils
  include ::FileUtils::StreamUtils_
  def ruby(*args, **options, &block); end

  def safe_ln(*args, **options); end

  def sh(*cmd, &block); end

  def split_all(path); end
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

module Forwardable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

class FrozenError
  def receiver(); end
end

module GC
  def garbage_collect(full_mark: T.unsafe(nil), immediate_mark: T.unsafe(nil), immediate_sweep: T.unsafe(nil)); end
end

module GC
  def self.verify_transient_heap_internal_consistency(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  KERNEL_WARN_IGNORES_INTERNAL_ENTRIES = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  UNTAINT = ::T.let(nil, ::T.untyped)
end

class Gem::BasicSpecification
  def plugins(); end
end

class Gem::ConfigFile
  def ipv4_fallback_enabled(); end

  def ipv4_fallback_enabled=(ipv4_fallback_enabled); end
  DEFAULT_IPV4_FALLBACK_ENABLED = ::T.let(nil, ::T.untyped)
end

class Gem::Dependency
  def filters_bundler?(); end
end

module Gem::Deprecate
  def deprecate(name, repl, year, month); end
end

module Gem::Deprecate
  def self.next_rubygems_major_version(); end

  def self.rubygems_deprecate(name, replacement=T.unsafe(nil)); end

  def self.rubygems_deprecate_command(); end
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::ExtConfBuilder
end

class Gem::Ext::ExtConfBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil), extension_dir=T.unsafe(nil)); end

  def self.get_relative_path(path, base); end
end

class Gem::Installer
  include ::Gem::InstallerUninstallerUtils
  def ensure_writable_dir(dir); end

  def generate_plugins(); end
end

Gem::Installer::ExtensionBuildError = Gem::Ext::BuildError

class Gem::Installer::FakePackage
  def copy_to(path); end

  def data_mode(); end

  def data_mode=(data_mode); end

  def dir_mode(); end

  def dir_mode=(dir_mode); end

  def extract_files(destination_dir, pattern=T.unsafe(nil)); end

  def initialize(spec); end

  def prog_mode(); end

  def prog_mode=(prog_mode); end

  def spec(); end

  def spec=(spec); end
end

class Gem::Installer::FakePackage
end

module Gem::InstallerUninstallerUtils
  def regenerate_plugins_for(spec, plugins_dir); end

  def remove_plugins_for(spec, plugins_dir); end
end

module Gem::InstallerUninstallerUtils
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::Platform
  def self.match_gem?(platform, gem_name); end

  def self.match_spec?(spec); end
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  extend ::Gem::Text
end

class Gem::Requirement
  def _sorted_requirements(); end
end

class Gem::Resolver::APISet::GemParser
  def parse(line); end
end

class Gem::Resolver::APISet::GemParser
end

class Gem::Resolver::APISpecification
  def self.new(set, api_data); end
end

class Gem::Resolver::ActivationRequest
  def eql?(other); end
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::IndexSpecification
  def ==(other); end
end

class Gem::Resolver::InstallerSet
  def force(); end

  def force=(force); end
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

module Gem::Resolver::Molinillo::Delegates::ResolutionState
  def unused_unwind_options(); end
end

module Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  def dependencies_equal?(dependencies, other_dependencies); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Resolver::Molinillo::DependencyGraph::Vertex
  def _path_to?(other, visited=T.unsafe(nil)); end

  def _recursive_predecessors(vertices=T.unsafe(nil)); end

  def _recursive_successors(vertices=T.unsafe(nil)); end
end

class Gem::Resolver::Molinillo::ResolutionState
  def unused_unwind_options(); end

  def unused_unwind_options=(_); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::Conflict
  def possibility_set(); end

  def possibility_set=(_); end

  def underlying_error(); end

  def underlying_error=(_); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::PossibilitySet
  def dependencies(); end

  def dependencies=(_); end

  def latest_version(); end

  def possibilities(); end

  def possibilities=(_); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::PossibilitySet
  def self.[](*arg); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::UnwindDetails
  include ::Comparable
  def all_requirements(); end

  def conflicting_requirements(); end

  def conflicting_requirements=(_); end

  def requirement_tree(); end

  def requirement_tree=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements_unwound_to_instead(); end

  def requirements_unwound_to_instead=(_); end

  def reversed_requirement_tree_index(); end

  def state_index(); end

  def state_index=(_); end

  def state_requirement(); end

  def state_requirement=(_); end

  def sub_dependencies_to_avoid(); end

  def unwinding_to_primary_requirement?(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::UnwindDetails
  def self.[](*arg); end

  def self.members(); end
end

module Gem::Resolver::Molinillo::SpecificationProvider
  def dependencies_equal?(dependencies, other_dependencies); end
end

class Gem::Resolver::Molinillo::VersionConflict
  include ::Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  def message_with_trees(opts=T.unsafe(nil)); end

  def specification_provider(); end
end

class Gem::Resolver::Specification
  def required_ruby_version(); end

  def required_rubygems_version(); end
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil), num_results=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def _deprecated_validate_dependencies(); end

  def _deprecated_validate_metadata(); end

  def _deprecated_validate_permissions(); end

  def removed_method_calls(); end

  def to_ruby(); end
  REMOVED_METHODS = ::T.let(nil, ::T.untyped)
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
  def self.latest_spec_for(name); end

  def self.stubs_for_pattern(pattern, match_platform=T.unsafe(nil)); end
end

class Gem::SpecificationPolicy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_duplicate_dependencies(); end

  def validate_metadata(); end

  def validate_optional(strict); end

  def validate_permissions(); end

  def validate_required!(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

module Gem::Util
  def self._deprecated_silent_system(*command); end
end

Gem::Version::Requirement = Gem::Requirement

module Gem
  def self.activated_gem_paths(); end

  def self.cache_home(); end

  def self.config_home(); end

  def self.data_home(); end

  def self.disable_system_update_message(); end

  def self.disable_system_update_message=(disable_system_update_message); end

  def self.find_config_file(); end

  def self.plugin_suffix_pattern(); end

  def self.plugin_suffix_regexp(); end

  def self.plugindir(install_dir=T.unsafe(nil)); end
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  def deconstruct_keys(arg); end

  def to_liquid(); end
end

class Hash
  def self.ruby2_keywords_hash(arg); end

  def self.ruby2_keywords_hash?(arg); end

  def self.try_convert(arg); end
end

class IO
  def beep(); end

  def check_winsize_changed(); end

  def clear_screen(); end

  def console_mode(); end

  def console_mode=(console_mode); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(cursor); end

  def cursor_down(arg); end

  def cursor_left(arg); end

  def cursor_right(arg); end

  def cursor_up(arg); end

  def echo=(echo); end

  def echo?(); end

  def erase_line(arg); end

  def erase_screen(arg); end

  def getch(*arg); end

  def getpass(*arg); end

  def goto(arg, arg1); end

  def goto_column(arg); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*arg); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(arg); end

  def pressed?(); end

  def raw(*arg); end

  def raw!(*arg); end

  def ready?(); end

  def scroll_backward(arg); end

  def scroll_forward(arg); end

  def set_encoding_by_bom(); end

  def wait(*arg); end

  def wait_readable(*arg); end

  def wait_writable(*arg); end

  def winsize(); end

  def winsize=(winsize); end
end

class IO::ConsoleMode
  def echo=(echo); end

  def raw(*arg); end

  def raw!(*arg); end
end

class IO::ConsoleMode
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.console(*arg); end

  def self.console_size(); end

  def self.default_console_size(); end
end

class IPAddr
  def ==(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end
end

module IRB
  IRBRC_EXT = ::T.let(nil, ::T.untyped)
  MagicFile = ::T.let(nil, ::T.untyped)
  STDIN_FILE_NAME = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module IRB::Color
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  REVERSE = ::T.let(nil, ::T.untyped)
  UNDERLINE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

module IRB::Color
  def self.clear(); end

  def self.colorable?(); end

  def self.colorize(text, seq); end

  def self.colorize_code(code, complete: T.unsafe(nil)); end

  def self.inspect_colorable?(obj, seen: T.unsafe(nil)); end
end

class IRB::Context
  def __exit__(*arg); end

  def __inspect__(); end

  def __to_s__(); end

  def echo_on_assignment(); end

  def echo_on_assignment=(echo_on_assignment); end

  def echo_on_assignment?(); end

  def evaluate(line, line_no, exception: T.unsafe(nil)); end

  def initialize(irb, workspace=T.unsafe(nil), input_method=T.unsafe(nil)); end

  def inspect_last_value(); end

  def newline_before_multiline_output(); end

  def newline_before_multiline_output=(newline_before_multiline_output); end

  def newline_before_multiline_output?(); end

  def omit_on_assignment(); end

  def omit_on_assignment=(omit_on_assignment); end

  def omit_on_assignment?(); end

  def use_colorize(); end

  def use_colorize?(); end

  def use_multiline(); end

  def use_multiline?(); end

  def use_reidline(); end

  def use_reidline?(); end

  def use_singleline(); end

  def use_singleline?(); end
  IDNAME_IVARS = ::T.let(nil, ::T.untyped)
  NOPRINTING_IVARS = ::T.let(nil, ::T.untyped)
  NO_INSPECTING_IVARS = ::T.let(nil, ::T.untyped)
end

class IRB::DefaultEncodings
  def external(); end

  def external=(_); end

  def internal(); end

  def internal=(_); end
end

class IRB::DefaultEncodings
  def self.[](*arg); end

  def self.members(); end
end

module IRB::ExtendCommandBundle
  def irb(*opts, &b); end

  def irb_change_workspace(*opts, &b); end

  def irb_current_working_workspace(*opts, &b); end

  def irb_fg(*opts, &b); end

  def irb_help(*opts, &b); end

  def irb_info(*opts, &b); end

  def irb_jobs(*opts, &b); end

  def irb_kill(*opts, &b); end

  def irb_pop_workspace(*opts, &b); end

  def irb_push_workspace(*opts, &b); end

  def irb_source(*opts, &b); end

  def irb_workspaces(*opts, &b); end
end

IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

module IRB::ExtendCommandBundle
  def self.irb_original_method_name(method_name); end
end

class IRB::FileInputMethod
  def initialize(file); end
end

module IRB::InputCompletor
  BASIC_WORD_BREAK_CHARACTERS = ::T.let(nil, ::T.untyped)
  CompletionProc = ::T.let(nil, ::T.untyped)
  Operators = ::T.let(nil, ::T.untyped)
  PerfectMatchedProc = ::T.let(nil, ::T.untyped)
  ReservedWords = ::T.let(nil, ::T.untyped)
end

module IRB::InputCompletor
  def self.ignored_modules(); end

  def self.retrieve_completion_data(input, bind: T.unsafe(nil), doc_namespace: T.unsafe(nil)); end

  def self.select_message(receiver, message, candidates, sep=T.unsafe(nil)); end
end

class IRB::InputMethod
  def initialize(file=T.unsafe(nil)); end

  def winsize(); end
end

class IRB::Inspector
  def initialize(inspect_proc, init_proc=T.unsafe(nil)); end
end

class IRB::Irb
  def assignment_expression?(line); end

  def handle_exception(exc); end

  def initialize(workspace=T.unsafe(nil), input_method=T.unsafe(nil)); end

  def output_value(omit=T.unsafe(nil)); end

  def prompt(prompt, ltype, indent, line_no); end
  ASSIGNMENT_NODE_TYPES = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
  def String(mes); end

  def encoding(); end

  def find(file, paths=T.unsafe(nil)); end

  def format(*opts); end

  def gets(*rs); end

  def initialize(locale=T.unsafe(nil)); end

  def lang(); end

  def load(file, priv=T.unsafe(nil)); end

  def modifier(); end

  def print(*opts); end

  def printf(*opts); end

  def puts(*opts); end

  def readline(*rs); end

  def require(file, priv=T.unsafe(nil)); end

  def territory(); end
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
  LOCALE_NAME_RE = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
end

class IRB::OutputMethod::NotImplementedError
  def initialize(val); end
end

class IRB::ReadlineInputMethod
  def initialize(); end
end

class IRB::ReadlineInputMethod
  def self.initialize_readline(); end
end

class IRB::ReidlineInputMethod
  include ::Reline
  def auto_indent(&block); end

  def check_termination(&block); end

  def dynamic_prompt(&block); end

  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
end

class IRB::ReidlineInputMethod
end

class IRB::StdioInputMethod
  def initialize(); end
end

class IRB::WorkSpace
  def initialize(*main); end

  def local_variable_get(name); end

  def local_variable_set(name, value); end
end

module IRB
  def self.Inspector(inspect, init=T.unsafe(nil)); end

  def self.delete_caller(); end

  def self.init_config(ap_path); end

  def self.init_error(); end

  def self.load_modules(); end

  def self.parse_opts(argv: T.unsafe(nil)); end

  def self.rc_file(ext=T.unsafe(nil)); end

  def self.rc_file_generators(); end

  def self.run_config(); end

  def self.setup(ap_path, argv: T.unsafe(nil)); end
end

module IniParse
  VERSION = ::T.let(nil, ::T.untyped)
end

class IniParse::Document
  include ::Enumerable
  def [](key); end

  def delete(*args); end

  def each(*args, &blk); end

  def has_section?(key); end

  def initialize(path=T.unsafe(nil)); end

  def lines(); end

  def path(); end

  def path=(path); end

  def save(path=T.unsafe(nil)); end

  def section(key); end

  def to_h(); end

  def to_hash(); end

  def to_ini(); end
end

class IniParse::Document
end

class IniParse::Generator
  def blank(); end

  def comment(comment, opts=T.unsafe(nil)); end

  def context(); end

  def document(); end

  def gen(); end

  def initialize(opts=T.unsafe(nil)); end

  def method_missing(name, *args, &blk); end

  def option(key, value, opts=T.unsafe(nil)); end

  def section(name, opts=T.unsafe(nil)); end

  def with_options(opts=T.unsafe(nil)); end
end

class IniParse::Generator
  def self.gen(opts=T.unsafe(nil), &blk); end
end

class IniParse::IniParseError
end

class IniParse::IniParseError
end

module IniParse::LineCollection
  include ::Enumerable
  def <<(line); end

  def [](key); end

  def []=(key, value); end

  def delete(key); end

  def each(include_blank=T.unsafe(nil), &blk); end

  def has_key?(*args); end

  def initialize(); end

  def keys(); end

  def push(line); end

  def to_a(); end

  def to_h(); end

  def to_hash(); end
end

module IniParse::LineCollection
end

class IniParse::LineNotAllowed
end

class IniParse::LineNotAllowed
end

module IniParse::Lines
end

class IniParse::Lines::AnonymousSection
  def initialize(); end
end

class IniParse::Lines::AnonymousSection
end

class IniParse::Lines::Blank
  include ::IniParse::Lines::Line
end

class IniParse::Lines::Blank
  def self.parse(line, opts); end
end

class IniParse::Lines::Comment
end

class IniParse::Lines::Comment
end

module IniParse::Lines::Line
  def blank?(); end

  def comment(); end

  def has_comment?(); end

  def initialize(opts=T.unsafe(nil)); end

  def line_contents(); end

  def options(); end

  def to_ini(); end
end

module IniParse::Lines::Line
end

class IniParse::Lines::Option
  include ::IniParse::Lines::Line
  def initialize(key, value, opts=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def value(); end

  def value=(value); end
end

class IniParse::Lines::Option
  def self.parse(line, opts); end

  def self.typecast(value); end
end

class IniParse::Lines::Section
  include ::IniParse::Lines::Line
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def delete(*args); end

  def each(*args, &blk); end

  def has_option?(key); end

  def initialize(key, opts=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def lines(); end

  def merge!(other); end

  def option(key); end
end

class IniParse::Lines::Section
  def self.parse(line, opts); end
end

module IniParse::Lines
end

class IniParse::NoSectionError
end

class IniParse::NoSectionError
end

class IniParse::OptionCollection
  include ::IniParse::LineCollection
  include ::Enumerable
  def each(*args, &blk); end
end

class IniParse::OptionCollection
end

class IniParse::ParseError
end

class IniParse::ParseError
end

class IniParse::Parser
  def initialize(source); end

  def parse(); end
end

class IniParse::Parser
  def self.parse_line(line); end

  def self.parse_types(); end

  def self.parse_types=(types); end
end

class IniParse::SectionCollection
  include ::IniParse::LineCollection
  include ::Enumerable
end

class IniParse::SectionCollection
end

module IniParse
  def self.gen(&blk); end

  def self.open(path); end

  def self.parse(source); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def to_bn(); end
end

class JSON::Ext::Generator::State
  def self.from_state(arg); end
end

class JSON::Ext::Parser
  def initialize(*arg); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module Javy
  BIN_FOLDER = ::T.let(nil, ::T.untyped)
  HASH_FOLDER = ::T.let(nil, ::T.untyped)
  ROOT = ::T.let(nil, ::T.untyped)
  TARGET = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Javy::Asset
  def basename(); end

  def basename=(_); end

  def download(target:); end

  def filename(); end

  def owner(); end

  def owner=(_); end

  def platform(); end

  def platform=(_); end

  def repository(); end

  def repository=(_); end

  def url(); end

  def version(); end

  def version=(_); end
end

class Javy::Asset
  def self.[](*arg); end

  def self.members(); end
end

class Javy::Error
end

class Javy::Error
end

class Javy::ExecutionError
end

class Javy::ExecutionError
end

class Javy::InstallationError
end

class Javy::InstallationError
  def self.asset_not_found(platform:, version:, url:); end

  def self.cpu_unsupported(); end

  def self.invalid_binary(); end
end

class Javy::Platform
  def cpu(); end

  def format_executable_path(path); end

  def initialize(ruby_platform=T.unsafe(nil)); end

  def os(); end

  def ruby_platform(); end

  def ruby_platform=(_); end
end

class Javy::Platform
  def self.[](*arg); end

  def self.members(); end
end

module Javy
  def self.build(source:, dest: T.unsafe(nil)); end

  def self.install(); end
end

module Kernel
  def byebug(); end

  def debugger(); end

  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def remote_byebug(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def then(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end
end

class KeyError
  include ::DidYouMean::Correctable
end

module Liquid
  AnyStartingTag = ::T.let(nil, ::T.untyped)
  ArgumentSeparator = ::T.let(nil, ::T.untyped)
  FilterArgumentSeparator = ::T.let(nil, ::T.untyped)
  FilterSeparator = ::T.let(nil, ::T.untyped)
  PartialTemplateParser = ::T.let(nil, ::T.untyped)
  QuotedFragment = ::T.let(nil, ::T.untyped)
  QuotedString = ::T.let(nil, ::T.untyped)
  RAISE_EXCEPTION_LAMBDA = ::T.let(nil, ::T.untyped)
  TagAttributes = ::T.let(nil, ::T.untyped)
  TagEnd = ::T.let(nil, ::T.untyped)
  TagStart = ::T.let(nil, ::T.untyped)
  TemplateParser = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VariableAttributeSeparator = ::T.let(nil, ::T.untyped)
  VariableEnd = ::T.let(nil, ::T.untyped)
  VariableIncompleteEnd = ::T.let(nil, ::T.untyped)
  VariableParser = ::T.let(nil, ::T.untyped)
  VariableSegment = ::T.let(nil, ::T.untyped)
  VariableSignature = ::T.let(nil, ::T.untyped)
  VariableStart = ::T.let(nil, ::T.untyped)
  WhitespaceControl = ::T.let(nil, ::T.untyped)
end

class Liquid::ArgumentError
end

class Liquid::ArgumentError
end

class Liquid::Assign
  def from(); end

  def to(); end
  Syntax = ::T.let(nil, ::T.untyped)
end

class Liquid::Assign::ParseTreeVisitor
end

class Liquid::Assign::ParseTreeVisitor
end

class Liquid::Assign
  def self.raise_syntax_error(parse_context); end
end

class Liquid::BlankFileSystem
  def read_template_file(_template_path); end
end

class Liquid::BlankFileSystem
end

class Liquid::Block
  def block_delimiter(); end

  def block_name(); end

  def initialize(tag_name, markup, options); end

  def parse(tokens); end

  def raise_tag_never_closed(block_name); end

  def render(context); end

  def unknown_tag(tag_name, _markup, _tokenizer); end
  MAX_DEPTH = ::T.let(nil, ::T.untyped)
end

class Liquid::Block
  def self.raise_unknown_tag(tag, block_name, block_delimiter, parse_context); end
end

class Liquid::BlockBody
  def blank?(); end

  def nodelist(); end

  def parse(tokenizer, parse_context, &block); end

  def remove_blank_strings(); end

  def render(context); end

  def render_to_output_buffer(context, output); end

  def whitespace_handler(token, parse_context); end
  ContentOfVariable = ::T.let(nil, ::T.untyped)
  FullToken = ::T.let(nil, ::T.untyped)
  LiquidTagToken = ::T.let(nil, ::T.untyped)
  TAGSTART = ::T.let(nil, ::T.untyped)
  VARSTART = ::T.let(nil, ::T.untyped)
  WhitespaceOrNothing = ::T.let(nil, ::T.untyped)
end

class Liquid::BlockBody
  def self.raise_missing_tag_terminator(token, parse_context); end

  def self.raise_missing_variable_terminator(token, parse_context); end

  def self.render_node(context, output, node); end

  def self.rescue_render_node(context, output, line_number, exc, blank_tag); end

  def self.unknown_tag_in_liquid_tag(tag, parse_context); end
end

class Liquid::Break
  INTERRUPT = ::T.let(nil, ::T.untyped)
end

class Liquid::Break
end

class Liquid::BreakInterrupt
end

class Liquid::BreakInterrupt
end

class Liquid::Capture
  Syntax = ::T.let(nil, ::T.untyped)
end

class Liquid::Capture
end

class Liquid::Case
  def blocks(); end

  def left(); end

  def unknown_tag(tag, markup, tokens); end
  Syntax = ::T.let(nil, ::T.untyped)
  WhenSyntax = ::T.let(nil, ::T.untyped)
end

class Liquid::Case::ParseTreeVisitor
end

class Liquid::Case::ParseTreeVisitor
end

class Liquid::Case
end

class Liquid::Comment
  def render_to_output_buffer(_context, output); end

  def unknown_tag(_tag, _markup, _tokens); end
end

class Liquid::Comment
end

class Liquid::Condition
  def and(condition); end

  def attach(attachment); end

  def attachment(); end

  def child_condition(); end

  def child_relation(); end

  def else?(); end

  def evaluate(context=T.unsafe(nil)); end

  def initialize(left=T.unsafe(nil), operator=T.unsafe(nil), right=T.unsafe(nil)); end

  def left(); end

  def left=(left); end

  def operator(); end

  def operator=(operator); end

  def or(condition); end

  def right(); end

  def right=(right); end
end

class Liquid::Condition::MethodLiteral
  def initialize(method_name, to_s); end

  def method_name(); end
end

class Liquid::Condition::MethodLiteral
end

class Liquid::Condition::ParseTreeVisitor
end

class Liquid::Condition::ParseTreeVisitor
end

class Liquid::Condition
  def self.operators(); end

  def self.parse_expression(parse_context, markup); end
end

class Liquid::Context
  def [](expression); end

  def []=(key, value); end

  def add_filters(filters); end

  def apply_global_filter(obj); end

  def base_scope_depth=(base_scope_depth); end

  def clear_instance_assigns(); end

  def disabled_tags=(disabled_tags); end

  def environments(); end

  def errors(); end

  def errors=(errors); end

  def evaluate(object); end

  def exception_renderer(); end

  def exception_renderer=(exception_renderer); end

  def filters=(filters); end

  def find_variable(key, raise_on_not_found: T.unsafe(nil)); end

  def global_filter(); end

  def global_filter=(global_filter); end

  def handle_error(e, line_number=T.unsafe(nil)); end

  def initialize(environments=T.unsafe(nil), outer_scope=T.unsafe(nil), registers=T.unsafe(nil), rethrow_errors=T.unsafe(nil), resource_limits=T.unsafe(nil), static_environments=T.unsafe(nil)); end

  def interrupt?(); end

  def invoke(method, *args); end

  def key?(key); end

  def lookup_and_evaluate(obj, key, raise_on_not_found: T.unsafe(nil)); end

  def merge(new_scopes); end

  def new_isolated_subcontext(); end

  def partial(); end

  def partial=(partial); end

  def pop(); end

  def pop_interrupt(); end

  def push(new_scope=T.unsafe(nil)); end

  def push_interrupt(e); end

  def registers(); end

  def resource_limits(); end

  def scopes(); end

  def stack(new_scope=T.unsafe(nil)); end

  def static_environments(); end

  def static_registers(); end

  def strainer(); end

  def strainer=(strainer); end

  def strict_filters(); end

  def strict_filters=(strict_filters); end

  def strict_variables(); end

  def strict_variables=(strict_variables); end

  def tag_disabled?(tag_name); end

  def template_name(); end

  def template_name=(template_name); end

  def warnings(); end

  def warnings=(warnings); end

  def with_disabled_tags(tag_names); end
end

class Liquid::Context
  def self.build(environments: T.unsafe(nil), outer_scope: T.unsafe(nil), registers: T.unsafe(nil), rethrow_errors: T.unsafe(nil), resource_limits: T.unsafe(nil), static_environments: T.unsafe(nil), &block); end
end

class Liquid::ContextError
end

class Liquid::ContextError
end

class Liquid::Continue
  INTERRUPT = ::T.let(nil, ::T.untyped)
end

class Liquid::Continue
end

class Liquid::ContinueInterrupt
end

class Liquid::ContinueInterrupt
end

class Liquid::Cycle
  def initialize(tag_name, markup, options); end

  def variables(); end
  NamedSyntax = ::T.let(nil, ::T.untyped)
  SimpleSyntax = ::T.let(nil, ::T.untyped)
end

class Liquid::Cycle::ParseTreeVisitor
end

class Liquid::Cycle::ParseTreeVisitor
end

class Liquid::Cycle
end

class Liquid::Decrement
  def initialize(tag_name, markup, options); end
end

class Liquid::Decrement
end

class Liquid::DisabledError
end

class Liquid::DisabledError
end

class Liquid::Document
  def body(); end

  def initialize(parse_context); end

  def nodelist(); end

  def parse(tokenizer, parse_context); end

  def parse_context(); end

  def render(context); end

  def render_to_output_buffer(context, output); end

  def unknown_tag(tag, _markup, _tokenizer); end
end

class Liquid::Document
  def self.parse(tokens, parse_context); end
end

class Liquid::Drop
  def [](method_or_key); end

  def context=(context); end

  def invoke_drop(method_or_key); end

  def key?(_name); end

  def liquid_method_missing(method); end

  def to_liquid(); end
end

class Liquid::Drop
  def self.invokable?(method_name); end

  def self.invokable_methods(); end
end

class Liquid::Echo
  def render(context); end

  def variable(); end
end

class Liquid::Echo::ParseTreeVisitor
end

class Liquid::Echo::ParseTreeVisitor
end

class Liquid::Echo
end

class Liquid::ElseCondition
  def evaluate(_context); end
end

class Liquid::ElseCondition
end

class Liquid::Error
  def line_number(); end

  def line_number=(line_number); end

  def markup_context(); end

  def markup_context=(markup_context); end

  def template_name(); end

  def template_name=(template_name); end

  def to_s(with_prefix=T.unsafe(nil)); end
end

class Liquid::Error
end

class Liquid::Expression
  DOUBLE_QUOTED_STRING = ::T.let(nil, ::T.untyped)
  FLOATS_REGEX = ::T.let(nil, ::T.untyped)
  INTEGERS_REGEX = ::T.let(nil, ::T.untyped)
  LITERALS = ::T.let(nil, ::T.untyped)
  RANGES_REGEX = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTED_STRING = ::T.let(nil, ::T.untyped)
end

class Liquid::Expression
  def self.parse(markup); end
end

class Liquid::FileSystemError
end

class Liquid::FileSystemError
end

class Liquid::FloatDomainError
end

class Liquid::FloatDomainError
end

class Liquid::For
  def collection_name(); end

  def from(); end

  def lax_parse(markup); end

  def limit(); end

  def strict_parse(markup); end

  def unknown_tag(tag, markup, tokens); end

  def variable_name(); end
  Syntax = ::T.let(nil, ::T.untyped)
end

class Liquid::For::ParseTreeVisitor
end

class Liquid::For::ParseTreeVisitor
end

class Liquid::For
end

class Liquid::ForloopDrop
  def first(); end

  def increment!(); end

  def index(); end

  def index0(); end

  def initialize(name, length, parentloop); end

  def last(); end

  def length(); end

  def name(); end

  def parentloop(); end

  def rindex(); end

  def rindex0(); end
end

class Liquid::ForloopDrop
end

class Liquid::I18n
  def initialize(path=T.unsafe(nil)); end

  def locale(); end

  def path(); end

  def t(name, vars=T.unsafe(nil)); end

  def translate(name, vars=T.unsafe(nil)); end
  DEFAULT_LOCALE = ::T.let(nil, ::T.untyped)
end

class Liquid::I18n::TranslationError
end

class Liquid::I18n::TranslationError
end

class Liquid::I18n
end

class Liquid::If
  def blocks(); end

  def unknown_tag(tag, markup, tokens); end
  BOOLEAN_OPERATORS = ::T.let(nil, ::T.untyped)
  ExpressionsAndOperators = ::T.let(nil, ::T.untyped)
  Syntax = ::T.let(nil, ::T.untyped)
end

class Liquid::If::ParseTreeVisitor
end

class Liquid::If::ParseTreeVisitor
end

class Liquid::If
end

class Liquid::Ifchanged
end

class Liquid::Ifchanged
end

class Liquid::Include
  include ::Liquid::Tag::Disableable
  def attributes(); end

  def initialize(tag_name, markup, options); end

  def template_name_expr(); end

  def variable_name_expr(); end
  SYNTAX = ::T.let(nil, ::T.untyped)
  Syntax = ::T.let(nil, ::T.untyped)
end

class Liquid::Include::ParseTreeVisitor
end

class Liquid::Include::ParseTreeVisitor
end

class Liquid::Include
end

class Liquid::Increment
  def initialize(tag_name, markup, options); end
end

class Liquid::Increment
end

class Liquid::InternalError
end

class Liquid::InternalError
end

class Liquid::Interrupt
  def initialize(message=T.unsafe(nil)); end

  def message(); end
end

class Liquid::Interrupt
end

class Liquid::Lexer
  def initialize(input); end

  def tokenize(); end
  COMPARISON_OPERATOR = ::T.let(nil, ::T.untyped)
  DOTDOT = ::T.let(nil, ::T.untyped)
  DOUBLE_STRING_LITERAL = ::T.let(nil, ::T.untyped)
  IDENTIFIER = ::T.let(nil, ::T.untyped)
  NUMBER_LITERAL = ::T.let(nil, ::T.untyped)
  SINGLE_STRING_LITERAL = ::T.let(nil, ::T.untyped)
  SPECIALS = ::T.let(nil, ::T.untyped)
  WHITESPACE_OR_NOTHING = ::T.let(nil, ::T.untyped)
end

class Liquid::Lexer
end

class Liquid::LocalFileSystem
  def full_path(template_path); end

  def initialize(root, pattern=T.unsafe(nil)); end

  def read_template_file(template_path); end

  def root(); end

  def root=(root); end
end

class Liquid::LocalFileSystem
end

class Liquid::MemoryError
end

class Liquid::MemoryError
end

class Liquid::MethodOverrideError
end

class Liquid::MethodOverrideError
end

class Liquid::ParseContext
  def [](option_key); end

  def depth(); end

  def depth=(depth); end

  def error_mode(); end

  def initialize(options=T.unsafe(nil)); end

  def line_number(); end

  def line_number=(line_number); end

  def locale(); end

  def locale=(locale); end

  def new_block_body(); end

  def new_tokenizer(markup, start_line_number: T.unsafe(nil), for_liquid_tag: T.unsafe(nil)); end

  def parse_expression(markup); end

  def partial(); end

  def partial=(value); end

  def partial_options(); end

  def trim_whitespace(); end

  def trim_whitespace=(trim_whitespace); end

  def warnings(); end
end

class Liquid::ParseContext
end

class Liquid::ParseTreeVisitor
  def add_callback_for(*classes, &block); end

  def children(); end

  def initialize(node, callbacks); end

  def visit(context=T.unsafe(nil)); end
end

class Liquid::ParseTreeVisitor
  def self.for(node, callbacks=T.unsafe(nil)); end
end

class Liquid::Parser
  def argument(); end

  def consume(type=T.unsafe(nil)); end

  def consume?(type); end

  def expression(); end

  def id?(str); end

  def initialize(input); end

  def jump(point); end

  def look(type, ahead=T.unsafe(nil)); end

  def variable_lookups(); end
end

class Liquid::Parser
end

module Liquid::ParserSwitching
  def parse_with_selected_parser(markup); end

  def strict_parse_with_error_mode_fallback(markup); end
end

module Liquid::ParserSwitching
end

class Liquid::PartialCache
end

class Liquid::PartialCache
  def self.load(template_name, context:, parse_context:); end
end

class Liquid::RangeLookup
  def end_obj(); end

  def evaluate(context); end

  def initialize(start_obj, end_obj); end

  def start_obj(); end
end

class Liquid::RangeLookup::ParseTreeVisitor
end

class Liquid::RangeLookup::ParseTreeVisitor
end

class Liquid::RangeLookup
  def self.parse(start_markup, end_markup); end
end

class Liquid::Raw
  def ensure_valid_markup(tag_name, markup, parse_context); end

  def initialize(tag_name, markup, parse_context); end

  def render_to_output_buffer(_context, output); end
  FullTokenPossiblyInvalid = ::T.let(nil, ::T.untyped)
  Syntax = ::T.let(nil, ::T.untyped)
end

class Liquid::Raw
end

class Liquid::Register
end

class Liquid::Register
end

class Liquid::Render
  include ::Liquid::Tag::Disabler
  def attributes(); end

  def initialize(tag_name, markup, options); end

  def render_tag(context, output); end

  def template_name_expr(); end
  FOR = ::T.let(nil, ::T.untyped)
  SYNTAX = ::T.let(nil, ::T.untyped)
end

class Liquid::Render::ParseTreeVisitor
end

class Liquid::Render::ParseTreeVisitor
end

class Liquid::Render
end

class Liquid::ResourceLimits
  def assign_score(); end

  def assign_score_limit(); end

  def assign_score_limit=(assign_score_limit); end

  def increment_assign_score(amount); end

  def increment_render_score(amount); end

  def increment_write_score(output); end

  def initialize(limits); end

  def raise_limits_reached(); end

  def reached?(); end

  def render_length_limit(); end

  def render_length_limit=(render_length_limit); end

  def render_score(); end

  def render_score_limit(); end

  def render_score_limit=(render_score_limit); end

  def reset(); end

  def with_capture(); end
end

class Liquid::ResourceLimits
end

class Liquid::StackLevelError
end

class Liquid::StackLevelError
end

class Liquid::StandardError
end

class Liquid::StandardError
end

module Liquid::StandardFilters
  def abs(input); end

  def append(input, string); end

  def at_least(input, n); end

  def at_most(input, n); end

  def base64_decode(input); end

  def base64_encode(input); end

  def base64_url_safe_decode(input); end

  def base64_url_safe_encode(input); end

  def capitalize(input); end

  def ceil(input); end

  def compact(input, property=T.unsafe(nil)); end

  def concat(input, array); end

  def date(input, format); end

  def default(input, default_value=T.unsafe(nil), options=T.unsafe(nil)); end

  def divided_by(input, operand); end

  def downcase(input); end

  def escape(input); end

  def escape_once(input); end

  def first(array); end

  def floor(input); end

  def h(input); end

  def join(input, glue=T.unsafe(nil)); end

  def last(array); end

  def lstrip(input); end

  def map(input, property); end

  def minus(input, operand); end

  def modulo(input, operand); end

  def newline_to_br(input); end

  def plus(input, operand); end

  def prepend(input, string); end

  def remove(input, string); end

  def remove_first(input, string); end

  def replace(input, string, replacement=T.unsafe(nil)); end

  def replace_first(input, string, replacement=T.unsafe(nil)); end

  def reverse(input); end

  def round(input, n=T.unsafe(nil)); end

  def rstrip(input); end

  def size(input); end

  def slice(input, offset, length=T.unsafe(nil)); end

  def sort(input, property=T.unsafe(nil)); end

  def sort_natural(input, property=T.unsafe(nil)); end

  def split(input, pattern); end

  def strip(input); end

  def strip_html(input); end

  def strip_newlines(input); end

  def times(input, operand); end

  def truncate(input, length=T.unsafe(nil), truncate_string=T.unsafe(nil)); end

  def truncatewords(input, words=T.unsafe(nil), truncate_string=T.unsafe(nil)); end

  def uniq(input, property=T.unsafe(nil)); end

  def upcase(input); end

  def url_decode(input); end

  def url_encode(input); end

  def where(input, property, target_value=T.unsafe(nil)); end
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_ONCE_REGEXP = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
  STRIP_HTML_BLOCKS = ::T.let(nil, ::T.untyped)
  STRIP_HTML_TAGS = ::T.let(nil, ::T.untyped)
end

class Liquid::StandardFilters::InputIterator
  include ::Enumerable
  def compact(); end

  def concat(args); end

  def each(&blk); end

  def empty?(); end

  def initialize(input, context); end

  def join(glue); end

  def reverse(); end

  def uniq(&block); end
end

class Liquid::StandardFilters::InputIterator
end

module Liquid::StandardFilters
end

class Liquid::StaticRegisters
  def [](key); end

  def []=(key, value); end

  def delete(key); end

  def fetch(key, default=T.unsafe(nil), &block); end

  def initialize(registers=T.unsafe(nil)); end

  def key?(key); end

  def static(); end
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class Liquid::StaticRegisters
end

module Liquid::StrainerFactory
  def add_global_filter(filter); end

  def create(context, filters=T.unsafe(nil)); end
end

module Liquid::StrainerFactory
  extend ::Liquid::StrainerFactory
end

class Liquid::StrainerTemplate
  def initialize(context); end

  def invoke(method, *args); end
end

class Liquid::StrainerTemplate
  def self.add_filter(filter); end

  def self.invokable?(method); end
end

class Liquid::SyntaxError
end

class Liquid::SyntaxError
end

class Liquid::TableRow
  def attributes(); end

  def collection_name(); end

  def variable_name(); end
  Syntax = ::T.let(nil, ::T.untyped)
end

class Liquid::TableRow::ParseTreeVisitor
end

class Liquid::TableRow::ParseTreeVisitor
end

class Liquid::TableRow
end

class Liquid::TablerowloopDrop
  def col(); end

  def col0(); end

  def col_first(); end

  def col_last(); end

  def first(); end

  def increment!(); end

  def index(); end

  def index0(); end

  def initialize(length, cols); end

  def last(); end

  def length(); end

  def rindex(); end

  def rindex0(); end

  def row(); end
end

class Liquid::TablerowloopDrop
end

class Liquid::Tag
  include ::Liquid::ParserSwitching
  def blank?(); end

  def initialize(tag_name, markup, parse_context); end

  def line_number(); end

  def name(); end

  def nodelist(); end

  def options(); end

  def parse(_tokens); end

  def parse_context(); end

  def raw(); end

  def render(_context); end

  def render_to_output_buffer(context, output); end

  def tag_name(); end
end

module Liquid::Tag::Disableable
  def disabled_error(context); end

  def render_to_output_buffer(context, output); end
end

module Liquid::Tag::Disableable
end

module Liquid::Tag::Disabler
  def render_to_output_buffer(context, output); end
end

module Liquid::Tag::Disabler
  def self.prepended(base); end
end

class Liquid::Tag
  def self.disable_tags(*tag_names); end

  def self.parse(tag_name, markup, tokenizer, parse_context); end
end

class Liquid::Template
  def assigns(); end

  def errors(); end

  def instance_assigns(); end

  def parse(source, options=T.unsafe(nil)); end

  def profiler(); end

  def registers(); end

  def render(*args); end

  def render!(*args); end

  def render_to_output_buffer(context, output); end

  def resource_limits(); end

  def root(); end

  def root=(root); end

  def warnings(); end
end

class Liquid::Template::TagRegistry
  include ::Enumerable
  def [](tag_name); end

  def []=(tag_name, klass); end

  def delete(tag_name); end

  def each(&block); end
end

class Liquid::Template::TagRegistry
end

class Liquid::Template
  def self.default_exception_renderer(); end

  def self.default_exception_renderer=(default_exception_renderer); end

  def self.default_resource_limits(); end

  def self.error_mode(); end

  def self.error_mode=(error_mode); end

  def self.file_system(); end

  def self.file_system=(file_system); end

  def self.parse(source, options=T.unsafe(nil)); end

  def self.register_filter(mod); end

  def self.register_tag(name, klass); end

  def self.tags(); end
end

class Liquid::TemplateFactory
  def for(_template_name); end
end

class Liquid::TemplateFactory
end

class Liquid::Tokenizer
  def for_liquid_tag(); end

  def initialize(source, line_numbers=T.unsafe(nil), line_number: T.unsafe(nil), for_liquid_tag: T.unsafe(nil)); end

  def line_number(); end

  def shift(); end
end

class Liquid::Tokenizer
end

class Liquid::UndefinedDropMethod
end

class Liquid::UndefinedDropMethod
end

class Liquid::UndefinedFilter
end

class Liquid::UndefinedFilter
end

class Liquid::UndefinedVariable
end

class Liquid::UndefinedVariable
end

class Liquid::Unless
end

class Liquid::Unless
end

module Liquid::Usage
end

module Liquid::Usage
  def self.increment(name); end
end

module Liquid::Utils
end

module Liquid::Utils
  def self.slice_collection(collection, from, to); end

  def self.slice_collection_using_each(collection, from, to); end

  def self.to_date(obj); end

  def self.to_integer(num); end

  def self.to_liquid_value(obj); end

  def self.to_number(obj); end
end

class Liquid::Variable
  include ::Liquid::ParserSwitching
  def disabled?(_context); end

  def disabled_tags(); end

  def filters(); end

  def filters=(filters); end

  def initialize(markup, parse_context); end

  def lax_parse(markup); end

  def line_number(); end

  def line_number=(line_number); end

  def name(); end

  def name=(name); end

  def options(); end

  def parse_context(); end

  def parse_filterargs(p); end

  def raw(); end

  def render(context); end

  def render_to_output_buffer(context, output); end

  def strict_parse(markup); end
  FilterArgsRegex = ::T.let(nil, ::T.untyped)
  FilterMarkupRegex = ::T.let(nil, ::T.untyped)
  FilterParser = ::T.let(nil, ::T.untyped)
  JustTagAttributes = ::T.let(nil, ::T.untyped)
  MarkupWithQuotedFragment = ::T.let(nil, ::T.untyped)
end

class Liquid::Variable::ParseTreeVisitor
end

class Liquid::Variable::ParseTreeVisitor
end

class Liquid::Variable
end

class Liquid::VariableLookup
  def ==(other); end

  def evaluate(context); end

  def initialize(markup); end

  def lookups(); end

  def name(); end

  def state(); end
  COMMAND_METHODS = ::T.let(nil, ::T.untyped)
  SQUARE_BRACKETED = ::T.let(nil, ::T.untyped)
end

class Liquid::VariableLookup::ParseTreeVisitor
end

class Liquid::VariableLookup::ParseTreeVisitor
end

class Liquid::VariableLookup
  def self.parse(markup); end
end

class Liquid::ZeroDivisionError
end

class Liquid::ZeroDivisionError
end

module Liquid
  def self.cache_classes(); end

  def self.cache_classes=(cache_classes); end
end

module Listen
  VERSION = ::T.let(nil, ::T.untyped)
end

module Listen::Adapter
  OPTIMIZED_ADAPTERS = ::T.let(nil, ::T.untyped)
  POLLING_FALLBACK_MESSAGE = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::BSD
  BUNDLER_DECLARE_GEM = ::T.let(nil, ::T.untyped)
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::BSD
end

class Listen::Adapter::Base
  def config(); end

  def configure(); end

  def initialize(config); end

  def options(); end

  def start(); end

  def started?(); end

  def stop(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Base
  def self.usable?(); end
end

class Listen::Adapter::Config
  def adapter_options(); end

  def directories(); end

  def initialize(directories, queue, silencer, adapter_options); end

  def queue(); end

  def silencer(); end
end

class Listen::Adapter::Config
end

class Listen::Adapter::Darwin
  DEFAULTS = ::T.let(nil, ::T.untyped)
  INCOMPATIBLE_GEM_VERSION = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Darwin
end

class Listen::Adapter::Linux
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
  README_URL = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Linux
end

class Listen::Adapter::Polling
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Polling
end

class Listen::Adapter::Windows
  BUNDLER_DECLARE_GEM = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Windows
end

module Listen::Adapter
  def self.select(options=T.unsafe(nil)); end
end

class Listen::Backend
  def initialize(directories, queue, silencer, config); end

  def min_delay_between_events(); end

  def start(*args, &block); end

  def stop(*args, &block); end
end

class Listen::Backend
  extend ::Forwardable
end

class Listen::Change
  def initialize(config, record); end

  def invalidate(type, rel_path, options); end

  def record(); end
end

class Listen::Change::Config
  def initialize(queue, silencer); end

  def queue(*args); end

  def silenced?(path, type); end
end

class Listen::Change::Config
end

class Listen::Change
end

class Listen::Directory
end

class Listen::Directory
  def self._async_changes(snapshot, path, previous, options); end

  def self._change(snapshot, type, path, options); end

  def self._children(path); end

  def self.ascendant_of?(base, other); end

  def self.scan(snapshot, rel_path, options); end
end

class Listen::Error
end

class Listen::Error::INotifyMaxWatchesExceeded
end

class Listen::Error::INotifyMaxWatchesExceeded
end

class Listen::Error::NotStarted
end

class Listen::Error::NotStarted
end

class Listen::Error::SymlinkLoop
end

class Listen::Error::SymlinkLoop
end

class Listen::Error
end

module Listen::Event
end

class Listen::Event::Config
  def call(*args); end

  def callable?(); end

  def event_queue(); end

  def initialize(listener, event_queue, queue_optimizer, wait_for_delay, &block); end

  def listener(); end

  def min_delay_between_events(); end

  def optimize_changes(changes); end

  def sleep(seconds); end
end

class Listen::Event::Config
end

class Listen::Event::Loop
  include ::Listen::FSM
  def initialize(config); end

  def pause(); end

  def start(); end

  def started?(); end

  def stop(); end

  def stopped?(); end

  def wakeup_on_event(); end
  MAX_STARTUP_SECONDS = ::T.let(nil, ::T.untyped)
end

Listen::Event::Loop::Error = Listen::Error

Listen::Event::Loop::NotStarted = Listen::Error::NotStarted

class Listen::Event::Loop
  extend ::Listen::FSM::ClassMethods
end

class Listen::Event::Processor
  def initialize(config, reasons); end

  def loop_for(latency); end
end

class Listen::Event::Processor::Stopped
end

class Listen::Event::Processor::Stopped
end

class Listen::Event::Processor
end

class Listen::Event::Queue
  def <<(args); end

  def close(*args, &block); end

  def empty?(*args, &block); end

  def initialize(config); end

  def pop(*args, &block); end
end

class Listen::Event::Queue::Config
  def initialize(relative); end

  def relative?(); end
end

class Listen::Event::Queue::Config
end

class Listen::Event::Queue
  extend ::Forwardable
end

module Listen::Event
end

module Listen::FSM
  def initialize_fsm(); end

  def state(); end

  def wait_for_state(*wait_for_states, timeout: T.unsafe(nil)); end
end

module Listen::FSM::ClassMethods
  def start_state(new_start_state=T.unsafe(nil)); end

  def state(state_name, to: T.unsafe(nil), &block); end

  def states(); end
end

module Listen::FSM::ClassMethods
end

class Listen::FSM::State
  def call(obj); end

  def initialize(name, transitions, &block); end

  def name(); end

  def transitions(); end

  def valid_transition?(new_state); end
end

class Listen::FSM::State
end

module Listen::FSM
  def self.included(klass); end
end

class Listen::File
end

class Listen::File
  def self.change(record, rel_path); end

  def self.inaccurate_mac_time?(stat); end
end

class Listen::Listener
  include ::Listen::FSM
  def ignore(regexps); end

  def ignore!(regexps); end

  def initialize(*dirs, &block); end

  def only(regexps); end

  def pause(); end

  def paused?(); end

  def processing?(); end

  def start(); end

  def stop(); end

  def stopped?(); end
end

class Listen::Listener::Config
  def adapter_instance_options(klass); end

  def adapter_select_options(); end

  def initialize(opts); end

  def min_delay_between_events(); end

  def relative?(); end

  def silencer_rules(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Listen::Listener::Config
end

class Listen::Listener
  extend ::Listen::FSM::ClassMethods
end

module Listen::MonotonicTime
end

module Listen::MonotonicTime
  def self.now(); end
end

class Listen::Options
  def initialize(opts, defaults); end

  def method_missing(name, *_); end
end

class Listen::Options
end

class Listen::QueueOptimizer
  def initialize(config); end

  def smoosh_changes(changes); end
end

class Listen::QueueOptimizer::Config
  def debug(*args, &block); end

  def exist?(path); end

  def initialize(adapter_class, silencer); end

  def silenced?(path, type); end
end

class Listen::QueueOptimizer::Config
end

class Listen::QueueOptimizer
end

class Listen::Record
  def add_dir(rel_path); end

  def build(); end

  def dir_entries(rel_path); end

  def file_data(rel_path); end

  def initialize(directory, silencer); end

  def root(); end

  def unset_path(rel_path); end

  def update_file(rel_path, data); end
end

class Listen::Record::Entry
  def children(); end

  def initialize(root, relative, name=T.unsafe(nil)); end

  def meta(); end

  def name(); end

  def real_path(); end

  def record_dir_key(); end

  def relative(); end

  def root(); end

  def sys_path(); end
end

class Listen::Record::Entry
end

class Listen::Record::SymlinkDetector
  def verify_unwatched!(entry); end
  README_URL = ::T.let(nil, ::T.untyped)
  SYMLINK_LOOP_ERROR = ::T.let(nil, ::T.untyped)
end

Listen::Record::SymlinkDetector::Error = Listen::Error

class Listen::Record::SymlinkDetector
end

class Listen::Record
end

class Listen::Silencer
  def configure(options); end

  def ignore_patterns(); end

  def ignore_patterns=(ignore_patterns); end

  def initialize(**options); end

  def only_patterns(); end

  def only_patterns=(only_patterns); end

  def silenced?(relative_path, type); end
  DEFAULT_IGNORED_DIRECTORIES = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORED_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Listen::Silencer::Controller
  def append_ignores(*regexps); end

  def initialize(silencer, default_options); end

  def replace_with_bang_ignores(regexps); end

  def replace_with_only(regexps); end
end

class Listen::Silencer::Controller
end

class Listen::Silencer
end

module Listen::Thread
end

module Listen::Thread
  def self.new(name, &block); end

  def self.rescue_and_log(method_name, *args, caller_stack: T.unsafe(nil)); end
end

module Listen
  def self.logger(); end

  def self.logger=(logger); end

  def self.stop(); end

  def self.to(*args, &block); end
end

class Logger
  def debug!(); end

  def error!(); end

  def fatal!(); end

  def info!(); end

  def warn!(); end
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::LogDevice
  include ::MonitorMixin
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

class Method
  include ::MethodSource::SourceLocation::MethodExtensions
  include ::MethodSource::MethodExtensions
end

module MethodSource
  VERSION = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers
  def comment_describing(file, line_number); end

  def complete_expression?(str); end

  def expression_at(file, line_number, options=T.unsafe(nil)); end
end

module MethodSource::CodeHelpers::IncompleteExpression
  GENERIC_REGEXPS = ::T.let(nil, ::T.untyped)
  RBX_ONLY_REGEXPS = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers::IncompleteExpression
  def self.===(ex); end

  def self.rbx?(); end
end

module MethodSource::CodeHelpers
end

module MethodSource::MethodExtensions
  def comment(); end

  def source(); end
end

module MethodSource::MethodExtensions
  def self.included(klass); end
end

module MethodSource::ReeSourceLocation
  def source_location(); end
end

module MethodSource::ReeSourceLocation
end

module MethodSource::SourceLocation
end

module MethodSource::SourceLocation::MethodExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::MethodExtensions
end

module MethodSource::SourceLocation::ProcExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::ProcExtensions
end

module MethodSource::SourceLocation::UnboundMethodExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::UnboundMethodExtensions
end

module MethodSource::SourceLocation
end

class MethodSource::SourceNotFoundError
end

class MethodSource::SourceNotFoundError
end

module MethodSource
  extend ::MethodSource::CodeHelpers
  def self.comment_helper(source_location, name=T.unsafe(nil)); end

  def self.extract_code(source_location); end

  def self.lines_for(file_name, name=T.unsafe(nil)); end

  def self.source_helper(source_location, name=T.unsafe(nil)); end

  def self.valid_expression?(str); end
end

MiniTest = Minitest

module Minitest
  ENCS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Minitest::AbstractReporter
  include ::Mutex_m
  def lock(); end

  def locked?(); end

  def passed?(); end

  def prerecord(klass, name); end

  def record(result); end

  def report(); end

  def start(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class Minitest::AbstractReporter
end

class Minitest::Assertion
  def error(); end

  def location(); end

  def result_code(); end

  def result_label(); end
end

class Minitest::Assertion
end

module Minitest::Assertions
  def _synchronize(); end

  def assert(test, msg=T.unsafe(nil)); end

  def assert_empty(obj, msg=T.unsafe(nil)); end

  def assert_equal(exp, act, msg=T.unsafe(nil)); end

  def assert_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_in_epsilon(exp, act, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_includes(collection, obj, msg=T.unsafe(nil)); end

  def assert_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_mock(mock); end

  def assert_nil(obj, msg=T.unsafe(nil)); end

  def assert_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_output(stdout=T.unsafe(nil), stderr=T.unsafe(nil)); end

  def assert_path_exists(path, msg=T.unsafe(nil)); end

  def assert_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_raises(*exp); end

  def assert_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def assert_same(exp, act, msg=T.unsafe(nil)); end

  def assert_send(send_ary, m=T.unsafe(nil)); end

  def assert_silent(); end

  def assert_throws(sym, msg=T.unsafe(nil)); end

  def capture_io(); end

  def capture_subprocess_io(); end

  def diff(exp, act); end

  def exception_details(e, msg); end

  def fail_after(y, m, d, msg); end

  def flunk(msg=T.unsafe(nil)); end

  def message(msg=T.unsafe(nil), ending=T.unsafe(nil), &default); end

  def mu_pp(obj); end

  def mu_pp_for_diff(obj); end

  def pass(_msg=T.unsafe(nil)); end

  def refute(test, msg=T.unsafe(nil)); end

  def refute_empty(obj, msg=T.unsafe(nil)); end

  def refute_equal(exp, act, msg=T.unsafe(nil)); end

  def refute_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_includes(collection, obj, msg=T.unsafe(nil)); end

  def refute_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_match(matcher, obj, msg=T.unsafe(nil)); end

  def refute_nil(obj, msg=T.unsafe(nil)); end

  def refute_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_path_exists(path, msg=T.unsafe(nil)); end

  def refute_predicate(o1, op, msg=T.unsafe(nil)); end

  def refute_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def refute_same(exp, act, msg=T.unsafe(nil)); end

  def skip(msg=T.unsafe(nil), bt=T.unsafe(nil)); end

  def skip_until(y, m, d, msg); end

  def skipped?(); end

  def things_to_diff(exp, act); end
  E = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  def self.diff(); end

  def self.diff=(o); end
end

class Minitest::BacktraceFilter
  def filter(bt); end
  MT_RE = ::T.let(nil, ::T.untyped)
end

class Minitest::BacktraceFilter
end

class Minitest::CompositeReporter
  def <<(reporter); end

  def initialize(*reporters); end

  def io(); end

  def reporters(); end

  def reporters=(reporters); end
end

class Minitest::CompositeReporter
end

class Minitest::Expectation
  def ctx(); end

  def ctx=(_); end

  def target(); end

  def target=(_); end
end

class Minitest::Expectation
  def self.[](*arg); end

  def self.members(); end
end

module Minitest::Expectations
  def must_be(*args); end

  def must_be_close_to(*args); end

  def must_be_empty(*args); end

  def must_be_instance_of(*args); end

  def must_be_kind_of(*args); end

  def must_be_nil(*args); end

  def must_be_same_as(*args); end

  def must_be_silent(*args); end

  def must_be_within_delta(*args); end

  def must_be_within_epsilon(*args); end

  def must_equal(*args); end

  def must_include(*args); end

  def must_match(*args); end

  def must_output(*args); end

  def must_raise(*args); end

  def must_respond_to(*args); end

  def must_throw(*args); end

  def path_must_exist(*args); end

  def path_wont_exist(*args); end

  def wont_be(*args); end

  def wont_be_close_to(*args); end

  def wont_be_empty(*args); end

  def wont_be_instance_of(*args); end

  def wont_be_kind_of(*args); end

  def wont_be_nil(*args); end

  def wont_be_same_as(*args); end

  def wont_be_within_delta(*args); end

  def wont_be_within_epsilon(*args); end

  def wont_equal(*args); end

  def wont_include(*args); end

  def wont_match(*args); end

  def wont_respond_to(*args); end
end

module Minitest::Expectations
end

class Minitest::ExtensibleBacktraceFilter
  def add_filter(regex); end

  def filter(backtrace); end

  def filters?(str); end
end

class Minitest::ExtensibleBacktraceFilter
  def self.default_filter(); end
end

module Minitest::Guard
  def jruby?(platform=T.unsafe(nil)); end

  def maglev?(platform=T.unsafe(nil)); end

  def mri?(platform=T.unsafe(nil)); end

  def osx?(platform=T.unsafe(nil)); end

  def rubinius?(platform=T.unsafe(nil)); end

  def windows?(platform=T.unsafe(nil)); end
end

module Minitest::Guard
end

class Minitest::Mock
  def ===(*args, &b); end

  def __call(name, data); end

  def __respond_to?(*arg); end

  def class(*args, &b); end

  def expect(name, retval, args=T.unsafe(nil), &blk); end

  def initialize(delegator=T.unsafe(nil)); end

  def inspect(*args, &b); end

  def instance_eval(*args, &b); end

  def instance_variables(*args, &b); end

  def method_missing(sym, *args, &block); end

  def object_id(*args, &b); end

  def public_send(*args, &b); end

  def respond_to?(sym, include_private=T.unsafe(nil)); end

  def send(*args, &b); end

  def to_s(*args, &b); end

  def verify(); end
end

class Minitest::Mock
end

module Minitest::Parallel
end

class Minitest::Parallel::Executor
  def <<(work); end

  def initialize(size); end

  def shutdown(); end

  def size(); end

  def start(); end
end

class Minitest::Parallel::Executor
end

module Minitest::Parallel::Test
  def _synchronize(); end
end

module Minitest::Parallel::Test::ClassMethods
  def run_one_method(klass, method_name, reporter); end

  def test_order(); end
end

module Minitest::Parallel::Test::ClassMethods
end

module Minitest::Parallel::Test
end

module Minitest::Parallel
end

class Minitest::ProgressReporter
end

class Minitest::ProgressReporter
end

module Minitest::RelativePosition
  INFO_PADDING = ::T.let(nil, ::T.untyped)
  MARK_SIZE = ::T.let(nil, ::T.untyped)
  TEST_PADDING = ::T.let(nil, ::T.untyped)
  TEST_SIZE = ::T.let(nil, ::T.untyped)
end

module Minitest::RelativePosition
end

module Minitest::Reportable
  def class_name(); end

  def error?(); end

  def location(); end

  def passed?(); end

  def result_code(); end

  def skipped?(); end
end

module Minitest::Reportable
end

class Minitest::Reporter
  def initialize(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def io(); end

  def io=(io); end

  def options(); end

  def options=(options); end
end

class Minitest::Reporter
end

module Minitest::Reporters
  VERSION = ::T.let(nil, ::T.untyped)
end

module Minitest::Reporters::ANSI
end

module Minitest::Reporters::ANSI::Code
  include ::ANSI::Code
  include ::ANSI::Constants
end

module Minitest::Reporters::ANSI::Code
  extend ::ANSI::Code
  extend ::ANSI::Constants
  def self.color?(); end
end

module Minitest::Reporters::ANSI
end

class Minitest::Reporters::BaseReporter
  def add_defaults(defaults); end

  def after_suite(test); end

  def after_test(_test); end

  def before_suite(test); end

  def before_test(test); end

  def filter_backtrace(backtrace); end

  def initialize(options=T.unsafe(nil)); end

  def print(*args); end

  def print_colored_status(test); end

  def print_info(e, name=T.unsafe(nil)); end

  def puts(*args); end

  def record(test); end

  def result(test); end

  def test_class(result); end

  def tests(); end

  def tests=(tests); end

  def total_count(); end
end

class Minitest::Reporters::BaseReporter
end

class Minitest::Reporters::DefaultReporter
  include ::Minitest::Reporters::ANSI::Code
  include ::ANSI::Code
  include ::ANSI::Constants
  include ::Minitest::RelativePosition
  def after_suite(suite); end

  def before_suite(suite); end

  def on_record(test); end

  def on_report(); end

  def on_start(); end

  def print_failure(test); end

  def record_failure(record); end

  def record_pass(record); end

  def record_skip(record); end
end

class Minitest::Reporters::DefaultReporter
end

class Minitest::Reporters::HtmlReporter
  def friendly_name(test); end

  def initialize(args=T.unsafe(nil)); end

  def passes(); end

  def percent_errors_failures(); end

  def percent_passes(); end

  def percent_skipps(); end

  def title(); end
end

class Minitest::Reporters::HtmlReporter
end

class Minitest::Reporters::JUnitReporter
  def get_relative_path(result); end

  def initialize(reports_dir=T.unsafe(nil), empty=T.unsafe(nil), options=T.unsafe(nil)); end

  def reports_path(); end
  DEFAULT_REPORTS_DIR = ::T.let(nil, ::T.untyped)
end

class Minitest::Reporters::JUnitReporter
end

class Minitest::Reporters::MeanTimeReporter
  def all_suite_times(); end

  def all_suite_times=(all_suite_times); end

  def reset_statistics!(); end
end

class Minitest::Reporters::MeanTimeReporter::InvalidOrder
end

class Minitest::Reporters::MeanTimeReporter::InvalidOrder
end

class Minitest::Reporters::MeanTimeReporter::InvalidSortColumn
end

class Minitest::Reporters::MeanTimeReporter::InvalidSortColumn
end

class Minitest::Reporters::MeanTimeReporter
  def self.reset_statistics!(); end
end

class Minitest::Reporters::ProgressReporter
  include ::Minitest::RelativePosition
  include ::Minitest::Reporters::ANSI::Code
  include ::ANSI::Code
  include ::ANSI::Constants
  PROGRESS_MARK = ::T.let(nil, ::T.untyped)
end

class Minitest::Reporters::ProgressReporter
end

class Minitest::Reporters::RubyMateReporter
  include ::Minitest::RelativePosition
  INFO_PADDING = ::T.let(nil, ::T.untyped)
end

class Minitest::Reporters::RubyMateReporter
end

class Minitest::Reporters::RubyMineReporter
end

class Minitest::Reporters::RubyMineReporter
end

class Minitest::Reporters::SpecReporter
  include ::Minitest::Reporters::ANSI::Code
  include ::ANSI::Code
  include ::ANSI::Constants
  include ::Minitest::RelativePosition
  def after_suite(_suite); end

  def before_suite(suite); end

  def record_print_failures_if_any(test); end

  def record_print_status(test); end
end

class Minitest::Reporters::SpecReporter
end

module Minitest::Reporters
  def self.choose_reporters(console_reporters, env); end

  def self.clock_time(); end

  def self.minitest_version(); end

  def self.reporters(); end

  def self.reporters=(reporters); end

  def self.use!(console_reporters=T.unsafe(nil), env=T.unsafe(nil), backtrace_filter=T.unsafe(nil)); end

  def self.use_around_test_hooks!(); end

  def self.use_old_activesupport_fix!(); end

  def self.use_runner!(console_reporters, env); end
end

class Minitest::Result
  include ::Minitest::Reportable
  def klass(); end

  def klass=(klass); end

  def source_location(); end

  def source_location=(source_location); end
end

class Minitest::Result
  def self.from(runnable); end
end

class Minitest::Runnable
  def assertions(); end

  def assertions=(assertions); end

  def failure(); end

  def failures(); end

  def failures=(failures); end

  def initialize(name); end

  def marshal_dump(); end

  def marshal_load(ary); end

  def name(); end

  def name=(o); end

  def passed?(); end

  def result_code(); end

  def run(); end

  def skipped?(); end

  def time(); end

  def time=(time); end

  def time_it(); end
  SIGNALS = ::T.let(nil, ::T.untyped)
end

class Minitest::Runnable
  def self.inherited(klass); end

  def self.methods_matching(re); end

  def self.on_signal(name, action); end

  def self.reset(); end

  def self.run(reporter, options=T.unsafe(nil)); end

  def self.run_one_method(klass, method_name, reporter); end

  def self.runnable_methods(); end

  def self.runnables(); end

  def self.with_info_handler(reporter, &block); end
end

class Minitest::Skip
end

class Minitest::Skip
end

class Minitest::Spec
  include ::Minitest::Spec::DSL::InstanceMethods
  TYPES = ::T.let(nil, ::T.untyped)
end

module Minitest::Spec::DSL
  def after(_type=T.unsafe(nil), &block); end

  def before(_type=T.unsafe(nil), &block); end

  def children(); end

  def create(name, desc); end

  def desc(); end

  def describe_stack(); end

  def it(desc=T.unsafe(nil), &block); end

  def let(name, &block); end

  def name(); end

  def nuke_test_methods!(); end

  def register_spec_type(*args, &block); end

  def spec_type(desc, *additional); end

  def specify(desc=T.unsafe(nil), &block); end

  def subject(&block); end

  def to_s(); end
  TYPES = ::T.let(nil, ::T.untyped)
end

module Minitest::Spec::DSL::InstanceMethods
  def _(value=T.unsafe(nil), &block); end

  def before_setup(); end

  def expect(value=T.unsafe(nil), &block); end

  def value(value=T.unsafe(nil), &block); end
end

module Minitest::Spec::DSL::InstanceMethods
end

module Minitest::Spec::DSL
  def self.extended(obj); end
end

class Minitest::Spec
  extend ::Minitest::Spec::DSL
  def self.current(); end
end

class Minitest::StatisticsReporter
  def assertions(); end

  def assertions=(assertions); end

  def count(); end

  def count=(count); end

  def errors(); end

  def errors=(errors); end

  def failures(); end

  def failures=(failures); end

  def results(); end

  def results=(results); end

  def skips(); end

  def skips=(skips); end

  def start_time(); end

  def start_time=(start_time); end

  def total_time(); end

  def total_time=(total_time); end
end

class Minitest::StatisticsReporter
end

class Minitest::SummaryReporter
  def aggregated_results(io); end

  def old_sync(); end

  def old_sync=(old_sync); end

  def statistics(); end

  def summary(); end

  def sync(); end

  def sync=(sync); end
end

class Minitest::SummaryReporter
end

class Minitest::Test
  include ::Minitest::Assertions
  include ::Minitest::Reportable
  include ::Minitest::Test::LifecycleHooks
  include ::Minitest::Guard
  def capture_exceptions(); end

  def with_info_handler(&block); end
  PASSTHROUGH_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  TEARDOWN_METHODS = ::T.let(nil, ::T.untyped)
end

module Minitest::Test::LifecycleHooks
  def after_setup(); end

  def after_teardown(); end

  def before_setup(); end

  def before_teardown(); end

  def setup(); end

  def teardown(); end
end

module Minitest::Test::LifecycleHooks
end

class Minitest::Test
  extend ::Minitest::Guard
  def self.i_suck_and_my_tests_are_order_dependent!(); end

  def self.io_lock(); end

  def self.io_lock=(io_lock); end

  def self.make_my_diffs_pretty!(); end

  def self.parallelize_me!(); end

  def self.test_order(); end
end

class Minitest::UnexpectedError
  def error=(error); end

  def initialize(error); end
end

class Minitest::UnexpectedError
end

class Minitest::Unit
  VERSION = ::T.let(nil, ::T.untyped)
end

class Minitest::Unit::TestCase
end

class Minitest::Unit::TestCase
end

class Minitest::Unit
  def self.after_tests(&b); end

  def self.autorun(); end
end

module Minitest
  def self.__run(reporter, options); end

  def self.after_run(&block); end

  def self.autorun(); end

  def self.backtrace_filter(); end

  def self.backtrace_filter=(backtrace_filter); end

  def self.clock_time(); end

  def self.extensions(); end

  def self.extensions=(extensions); end

  def self.filter_backtrace(bt); end

  def self.info_signal(); end

  def self.info_signal=(info_signal); end

  def self.init_plugins(options); end

  def self.load_plugins(); end

  def self.parallel_executor(); end

  def self.parallel_executor=(parallel_executor); end

  def self.process_args(args=T.unsafe(nil)); end

  def self.reporter(); end

  def self.reporter=(reporter); end

  def self.run(args=T.unsafe(nil)); end

  def self.run_one_method(klass, method_name); end
end

class MockExpectationError
end

class MockExpectationError
end

class Module
  def infect_an_assertion(meth, new_name, dont_flip=T.unsafe(nil)); end

  def rake_extension(method); end
end

class Monitor
  def enter(); end

  def exit(); end

  def mon_check_owner(); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_enter(); end

  def try_mon_enter(); end

  def wait_for_cond(arg, arg1); end
end

module MonitorMixin
  def initialize(*args); end
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

module Mutex_m
  VERSION = ::T.let(nil, ::T.untyped)
end

class NameError
  include ::DidYouMean::Correctable
end

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def ipaddr(); end

  def ipaddr=(addr); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def write_timeout(); end

  def write_timeout=(sec); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

Net::HTTP::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPServerException

Net::HTTPClientErrorCode = Net::HTTPClientError

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

Net::HTTPInformation::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPInformationCode = Net::HTTPInformation

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

Net::HTTPRedirectionCode = Net::HTTPRedirection

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

Net::HTTPServerErrorCode = Net::HTTPServerError

Net::HTTPSession = Net::HTTP

Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_liquid(); end
end

class NoMatchingPatternError
end

class NoMatchingPatternError
end

class Node::Forms::Create
  def organization_id(); end

  def organization_id=(organization_id); end

  def shop_domain(); end

  def shop_domain=(shop_domain); end

  def type(); end

  def type=(type); end
end

module Nokogiri
  LIBXML2_PATCHES = ::T.let(nil, ::T.untyped)
  LIBXML_COMPILED_VERSION = ::T.let(nil, ::T.untyped)
  LIBXML_ICONV_ENABLED = ::T.let(nil, ::T.untyped)
  LIBXML_LOADED_VERSION = ::T.let(nil, ::T.untyped)
  LIBXML_MEMORY_MANAGEMENT = ::T.let(nil, ::T.untyped)
  LIBXSLT_COMPILED_VERSION = ::T.let(nil, ::T.untyped)
  LIBXSLT_DATETIME_ENABLED = ::T.let(nil, ::T.untyped)
  LIBXSLT_LOADED_VERSION = ::T.let(nil, ::T.untyped)
  LIBXSLT_PATCHES = ::T.let(nil, ::T.untyped)
  OTHER_LIBRARY_VERSIONS = ::T.let(nil, ::T.untyped)
  PACKAGED_LIBRARIES = ::T.let(nil, ::T.untyped)
  PRECOMPILED_LIBRARIES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_INFO = ::T.let(nil, ::T.untyped)
end

module Nokogiri::CSS
end

class Nokogiri::CSS::Node
  def accept(visitor); end

  def find_by_type(types); end

  def initialize(type, value); end

  def to_a(); end

  def to_type(); end

  def to_xpath(prefix=T.unsafe(nil), visitor=T.unsafe(nil)); end

  def type(); end

  def type=(type); end

  def value(); end

  def value=(value); end
  ALLOW_COMBINATOR_ON_SELF = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Node
end

class Nokogiri::CSS::Parser
  def _reduce_1(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_50(val, _values, result); end

  def _reduce_51(val, _values, result); end

  def _reduce_52(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_7(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def initialize(namespaces=T.unsafe(nil)); end

  def on_error(error_token_id, error_value, value_stack); end

  def parse(string); end

  def unescape_css_identifier(identifier); end

  def unescape_css_string(str); end

  def xpath_for(string, options=T.unsafe(nil)); end
  CACHE_SWITCH_NAME = ::T.let(nil, ::T.untyped)
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Parser
  def self.[](string); end

  def self.[]=(string, value); end

  def self.cache_on?(); end

  def self.clear_cache(create_new_object=T.unsafe(nil)); end

  def self.set_cache(value); end

  def self.without_cache(&block); end
end

class Nokogiri::CSS::SyntaxError
end

class Nokogiri::CSS::SyntaxError
end

class Nokogiri::CSS::Tokenizer
  def _next_token(); end

  def action(); end

  def filename(); end

  def lineno(); end

  def load_file(filename); end

  def next_token(); end

  def scan(str); end

  def scan_file(filename); end

  def scan_setup(str); end

  def scan_str(str); end

  def state(); end

  def state=(state); end
end

class Nokogiri::CSS::Tokenizer::ScanError
end

class Nokogiri::CSS::Tokenizer::ScanError
end

class Nokogiri::CSS::Tokenizer
end

class Nokogiri::CSS::XPathVisitor
  def accept(node); end

  def visit_attribute_condition(node); end

  def visit_child_selector(node); end

  def visit_class_condition(node); end

  def visit_combinator(node); end

  def visit_conditional_selector(node); end

  def visit_descendant_selector(node); end

  def visit_direct_adjacent_selector(node); end

  def visit_element_name(node); end

  def visit_following_selector(node); end

  def visit_function(node); end

  def visit_id(node); end

  def visit_not(node); end

  def visit_pseudo_class(node); end
end

class Nokogiri::CSS::XPathVisitor
end

class Nokogiri::CSS::XPathVisitorAlwaysUseBuiltins
end

class Nokogiri::CSS::XPathVisitorAlwaysUseBuiltins
end

class Nokogiri::CSS::XPathVisitorOptimallyUseBuiltins
end

class Nokogiri::CSS::XPathVisitorOptimallyUseBuiltins
end

module Nokogiri::CSS
  def self.parse(selector); end

  def self.xpath_for(selector, options=T.unsafe(nil)); end
end

module Nokogiri::Decorators
end

module Nokogiri::Decorators::Slop
  def method_missing(name, *args, &block); end
  XPATH_PREFIX = ::T.let(nil, ::T.untyped)
end

module Nokogiri::Decorators::Slop
end

module Nokogiri::Decorators
end

class Nokogiri::EncodingHandler
  def name(); end
end

class Nokogiri::EncodingHandler
  def self.[](arg); end

  def self.alias(arg, arg1); end

  def self.clear_aliases!(); end

  def self.delete(arg); end
end

module Nokogiri::Gumbo
  DEFAULT_MAX_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_ERRORS = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_TREE_DEPTH = ::T.let(nil, ::T.untyped)
end

module Nokogiri::Gumbo
  def self.fragment(arg, arg1, arg2, arg3, arg4, arg5); end

  def self.parse(arg, arg1, arg2, arg3, arg4); end
end

module Nokogiri::HTML4
end

class Nokogiri::HTML4::ElementDescription
end

Nokogiri::HTML::ElementDescription::Desc = Struct::HTMLElementDescription

class Nokogiri::HTML4::ElementDescription
end

module Nokogiri::HTML4
end

module Nokogiri::HTML4
  NamedCharacters = ::T.let(nil, ::T.untyped)
end

class Nokogiri::HTML4::Builder
  def to_html(); end
end

class Nokogiri::HTML4::Builder
end

class Nokogiri::HTML4::Document
  def meta_encoding(); end

  def meta_encoding=(encoding); end

  def serialize(options=T.unsafe(nil)); end

  def title(); end

  def title=(text); end
end

class Nokogiri::HTML4::Document::EncodingFound
  def found_encoding(); end

  def initialize(encoding); end
end

class Nokogiri::HTML4::Document::EncodingFound
end

class Nokogiri::HTML4::Document::EncodingReader
  def encoding_found(); end

  def initialize(io); end

  def read(len); end
end

class Nokogiri::HTML4::Document::EncodingReader::JumpSAXHandler
  def initialize(jumptag); end
end

class Nokogiri::HTML4::Document::EncodingReader::JumpSAXHandler
end

class Nokogiri::HTML4::Document::EncodingReader::SAXHandler
  def encoding(); end
end

class Nokogiri::HTML4::Document::EncodingReader::SAXHandler
end

class Nokogiri::HTML4::Document::EncodingReader
  def self.detect_encoding(chunk); end
end

class Nokogiri::HTML4::Document
end

class Nokogiri::HTML4::DocumentFragment
end

class Nokogiri::HTML4::DocumentFragment
  def self.parse(tags, encoding=T.unsafe(nil)); end
end

class Nokogiri::HTML4::ElementDescription
  def block?(); end

  def default_sub_element(); end

  def deprecated?(); end

  def deprecated_attributes(); end

  def description(); end

  def empty?(); end

  def implied_end_tag?(); end

  def implied_start_tag?(); end

  def inline?(); end

  def name(); end

  def optional_attributes(); end

  def required_attributes(); end

  def save_end_tag?(); end

  def sub_elements(); end
  ACTION_ATTR = ::T.let(nil, ::T.untyped)
  ALIGN_ATTR = ::T.let(nil, ::T.untyped)
  ALT_ATTR = ::T.let(nil, ::T.untyped)
  APPLET_ATTRS = ::T.let(nil, ::T.untyped)
  AREA_ATTRS = ::T.let(nil, ::T.untyped)
  ATTRS = ::T.let(nil, ::T.untyped)
  A_ATTRS = ::T.let(nil, ::T.untyped)
  BASEFONT_ATTRS = ::T.let(nil, ::T.untyped)
  BGCOLOR_ATTR = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  BLOCKLI_ELT = ::T.let(nil, ::T.untyped)
  BODY_ATTRS = ::T.let(nil, ::T.untyped)
  BODY_CONTENTS = ::T.let(nil, ::T.untyped)
  BODY_DEPR = ::T.let(nil, ::T.untyped)
  BUTTON_ATTRS = ::T.let(nil, ::T.untyped)
  CELLHALIGN = ::T.let(nil, ::T.untyped)
  CELLVALIGN = ::T.let(nil, ::T.untyped)
  CLEAR_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ELT = ::T.let(nil, ::T.untyped)
  COMPACT_ATTR = ::T.let(nil, ::T.untyped)
  COMPACT_ATTRS = ::T.let(nil, ::T.untyped)
  CONTENT_ATTR = ::T.let(nil, ::T.untyped)
  COREATTRS = ::T.let(nil, ::T.untyped)
  CORE_ATTRS = ::T.let(nil, ::T.untyped)
  CORE_I18N_ATTRS = ::T.let(nil, ::T.untyped)
  DIR_ATTR = ::T.let(nil, ::T.untyped)
  DL_CONTENTS = ::T.let(nil, ::T.untyped)
  DefaultDescriptions = ::T.let(nil, ::T.untyped)
  EDIT_ATTRS = ::T.let(nil, ::T.untyped)
  EMBED_ATTRS = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  EVENTS = ::T.let(nil, ::T.untyped)
  FIELDSET_CONTENTS = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
  FLOW_PARAM = ::T.let(nil, ::T.untyped)
  FONTSTYLE = ::T.let(nil, ::T.untyped)
  FONT_ATTRS = ::T.let(nil, ::T.untyped)
  FORMCTRL = ::T.let(nil, ::T.untyped)
  FORM_ATTRS = ::T.let(nil, ::T.untyped)
  FORM_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAMESET_ATTRS = ::T.let(nil, ::T.untyped)
  FRAMESET_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAME_ATTRS = ::T.let(nil, ::T.untyped)
  HEADING = ::T.let(nil, ::T.untyped)
  HEAD_ATTRS = ::T.let(nil, ::T.untyped)
  HEAD_CONTENTS = ::T.let(nil, ::T.untyped)
  HREF_ATTRS = ::T.let(nil, ::T.untyped)
  HR_DEPR = ::T.let(nil, ::T.untyped)
  HTML_ATTRS = ::T.let(nil, ::T.untyped)
  HTML_CDATA = ::T.let(nil, ::T.untyped)
  HTML_CONTENT = ::T.let(nil, ::T.untyped)
  HTML_FLOW = ::T.let(nil, ::T.untyped)
  HTML_INLINE = ::T.let(nil, ::T.untyped)
  HTML_PCDATA = ::T.let(nil, ::T.untyped)
  I18N = ::T.let(nil, ::T.untyped)
  I18N_ATTRS = ::T.let(nil, ::T.untyped)
  IFRAME_ATTRS = ::T.let(nil, ::T.untyped)
  IMG_ATTRS = ::T.let(nil, ::T.untyped)
  INLINE = ::T.let(nil, ::T.untyped)
  INLINE_P = ::T.let(nil, ::T.untyped)
  INPUT_ATTRS = ::T.let(nil, ::T.untyped)
  LABEL_ATTR = ::T.let(nil, ::T.untyped)
  LABEL_ATTRS = ::T.let(nil, ::T.untyped)
  LANGUAGE_ATTR = ::T.let(nil, ::T.untyped)
  LEGEND_ATTRS = ::T.let(nil, ::T.untyped)
  LINK_ATTRS = ::T.let(nil, ::T.untyped)
  LIST = ::T.let(nil, ::T.untyped)
  LI_ELT = ::T.let(nil, ::T.untyped)
  MAP_CONTENTS = ::T.let(nil, ::T.untyped)
  META_ATTRS = ::T.let(nil, ::T.untyped)
  MODIFIER = ::T.let(nil, ::T.untyped)
  NAME_ATTR = ::T.let(nil, ::T.untyped)
  NOFRAMES_CONTENT = ::T.let(nil, ::T.untyped)
  OBJECT_ATTRS = ::T.let(nil, ::T.untyped)
  OBJECT_CONTENTS = ::T.let(nil, ::T.untyped)
  OBJECT_DEPR = ::T.let(nil, ::T.untyped)
  OL_ATTRS = ::T.let(nil, ::T.untyped)
  OPTGROUP_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ELT = ::T.let(nil, ::T.untyped)
  PARAM_ATTRS = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PHRASE = ::T.let(nil, ::T.untyped)
  PRE_CONTENT = ::T.let(nil, ::T.untyped)
  PROMPT_ATTRS = ::T.let(nil, ::T.untyped)
  QUOTE_ATTRS = ::T.let(nil, ::T.untyped)
  ROWS_COLS_ATTR = ::T.let(nil, ::T.untyped)
  SCRIPT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_CONTENT = ::T.let(nil, ::T.untyped)
  SPECIAL = ::T.let(nil, ::T.untyped)
  SRC_ALT_ATTRS = ::T.let(nil, ::T.untyped)
  STYLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_CONTENTS = ::T.let(nil, ::T.untyped)
  TABLE_DEPR = ::T.let(nil, ::T.untyped)
  TALIGN_ATTRS = ::T.let(nil, ::T.untyped)
  TARGET_ATTR = ::T.let(nil, ::T.untyped)
  TEXTAREA_ATTRS = ::T.let(nil, ::T.untyped)
  TH_TD_ATTR = ::T.let(nil, ::T.untyped)
  TH_TD_DEPR = ::T.let(nil, ::T.untyped)
  TR_CONTENTS = ::T.let(nil, ::T.untyped)
  TR_ELT = ::T.let(nil, ::T.untyped)
  TYPE_ATTR = ::T.let(nil, ::T.untyped)
  UL_DEPR = ::T.let(nil, ::T.untyped)
  VERSION_ATTR = ::T.let(nil, ::T.untyped)
  WIDTH_ATTR = ::T.let(nil, ::T.untyped)
end

class Nokogiri::HTML4::ElementDescription
  def self.[](arg); end
end

class Nokogiri::HTML4::EntityDescription
end

class Nokogiri::HTML4::EntityDescription
end

class Nokogiri::HTML4::EntityLookup
  def [](name); end

  def get(arg); end
end

class Nokogiri::HTML4::EntityLookup
end

module Nokogiri::HTML4::SAX
end

class Nokogiri::HTML4::SAX::Parser
  def parse_file(filename, encoding=T.unsafe(nil)); end

  def parse_memory(data, encoding=T.unsafe(nil)); end
end

class Nokogiri::HTML4::SAX::Parser
end

class Nokogiri::HTML4::SAX::ParserContext
end

class Nokogiri::HTML4::SAX::ParserContext
  def self.file(arg, arg1); end

  def self.memory(arg, arg1); end
end

class Nokogiri::HTML4::SAX::PushParser
end

class Nokogiri::HTML4::SAX::PushParser
end

module Nokogiri::HTML4::SAX
end

module Nokogiri::HTML4
  def self.fragment(string, encoding=T.unsafe(nil)); end

  def self.parse(input, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end
end

module Nokogiri::HTML5
  HTML_NAMESPACE = ::T.let(nil, ::T.untyped)
  MATHML_NAMESPACE = ::T.let(nil, ::T.untyped)
  SVG_NAMESPACE = ::T.let(nil, ::T.untyped)
  XLINK_NAMESPACE = ::T.let(nil, ::T.untyped)
  XMLNS_NAMESPACE = ::T.let(nil, ::T.untyped)
  XML_NAMESPACE = ::T.let(nil, ::T.untyped)
end

class Nokogiri::HTML5::Document
  def to_xml(options=T.unsafe(nil), &block); end
end

class Nokogiri::HTML5::Document
  def self.do_parse(string_or_io, url, encoding, options); end

  def self.parse(string_or_io, url=T.unsafe(nil), encoding=T.unsafe(nil), **options, &block); end

  def self.read_io(io, url=T.unsafe(nil), encoding=T.unsafe(nil), **options); end

  def self.read_memory(string, url=T.unsafe(nil), encoding=T.unsafe(nil), **options); end
end

class Nokogiri::HTML5::DocumentFragment
  def document=(document); end

  def errors=(errors); end

  def initialize(doc, tags=T.unsafe(nil), ctx=T.unsafe(nil), options=T.unsafe(nil)); end

  def serialize(options=T.unsafe(nil), &block); end
end

class Nokogiri::HTML5::DocumentFragment
  def self.parse(tags, encoding=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Nokogiri::HTML5::Node
  def fragment(tags); end

  def inner_html(options=T.unsafe(nil)); end

  def write_to(io, *options); end
end

module Nokogiri::HTML5::Node
end

module Nokogiri::HTML5
  def self.escape_text(text, encoding, attribute_mode); end

  def self.fragment(string, encoding=T.unsafe(nil), **options); end

  def self.get(uri, options=T.unsafe(nil)); end

  def self.get_impl(uri, options=T.unsafe(nil)); end

  def self.parse(string, url=T.unsafe(nil), encoding=T.unsafe(nil), **options, &block); end

  def self.prepend_newline?(node); end

  def self.read_and_encode(string, encoding); end

  def self.reencode(body, content_type=T.unsafe(nil)); end

  def self.serialize_node_internal(current_node, io, encoding, options); end
end

class Nokogiri::SyntaxError
end

class Nokogiri::SyntaxError
end

module Nokogiri::Test
end

module Nokogiri::Test
  def self.__foreign_error_handler(); end
end

class Nokogiri::VersionInfo
  include ::Singleton
  def compiled_libxml_version(); end

  def compiled_libxslt_version(); end

  def engine(); end

  def jruby?(); end

  def libxml2?(); end

  def libxml2_has_iconv?(); end

  def libxml2_precompiled?(); end

  def libxml2_using_packaged?(); end

  def libxml2_using_system?(); end

  def libxslt_has_datetime?(); end

  def loaded_libxml_version(); end

  def loaded_libxslt_version(); end

  def ruby_minor(); end

  def to_hash(); end

  def to_markdown(); end

  def warnings(); end

  def windows?(); end
end

class Nokogiri::VersionInfo
  extend ::Singleton::SingletonClassMethods
end

module Nokogiri::XML
  XML_C14N_1_0 = ::T.let(nil, ::T.untyped)
  XML_C14N_1_1 = ::T.let(nil, ::T.untyped)
  XML_C14N_EXCLUSIVE_1_0 = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Attr
  def content=(content); end

  def value(); end

  def value=(value); end
end

class Nokogiri::XML::Attr
end

class Nokogiri::XML::AttributeDecl
  def attribute_type(); end

  def default(); end

  def enumeration(); end
end

class Nokogiri::XML::AttributeDecl
end

class Nokogiri::XML::Builder
  def <<(string); end

  def [](ns); end

  def arity(); end

  def arity=(arity); end

  def cdata(string); end

  def comment(string); end

  def context(); end

  def context=(context); end

  def doc(); end

  def doc=(doc); end

  def initialize(options=T.unsafe(nil), root=T.unsafe(nil), &block); end

  def method_missing(method, *args, &block); end

  def parent(); end

  def parent=(parent); end

  def text(string); end

  def to_xml(*args); end
  DEFAULT_DOCUMENT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Builder
  def self.with(root, &block); end
end

class Nokogiri::XML::CDATA
end

class Nokogiri::XML::CDATA
end

class Nokogiri::XML::CharacterData
  include ::Nokogiri::XML::PP::CharacterData
end

class Nokogiri::XML::CharacterData
end

class Nokogiri::XML::Comment
end

class Nokogiri::XML::Comment
end

class Nokogiri::XML::DTD
  def entities(); end

  def external_id(); end

  def html5_dtd?(); end

  def html_dtd?(); end

  def notations(); end

  def system_id(); end

  def validate(arg); end
end

class Nokogiri::XML::DTD
end

class Nokogiri::XML::Document
  def canonicalize(*arg); end

  def collect_namespaces(); end

  def create_cdata(string, &block); end

  def create_comment(string, &block); end

  def create_element(name, *contents_or_attrs, &block); end

  def create_entity(*arg); end

  def create_text_node(string, &block); end

  def decorate(node); end

  def decorators(key); end

  def encoding(); end

  def encoding=(encoding); end

  def errors(); end

  def errors=(errors); end

  def fragment(tags=T.unsafe(nil)); end

  def initialize(*args); end

  def namespace_inheritance(); end

  def namespace_inheritance=(namespace_inheritance); end

  def remove_namespaces!(); end

  def root(); end

  def root=(root); end

  def slop!(); end

  def to_xml(*args, &block); end

  def url(); end

  def validate(); end

  def version(); end
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NCNAME_CHAR = ::T.let(nil, ::T.untyped)
  NCNAME_RE = ::T.let(nil, ::T.untyped)
  NCNAME_START_CHAR = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Document
  def self.empty_doc?(string_or_io); end

  def self.parse(string_or_io, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.read_io(arg, arg1, arg2, arg3); end

  def self.read_memory(arg, arg1, arg2, arg3); end
end

class Nokogiri::XML::DocumentFragment
  def dup(); end

  def errors(); end

  def errors=(things); end

  def fragment(data); end

  def initialize(document, tags=T.unsafe(nil), ctx=T.unsafe(nil)); end

  def search(*rules); end

  def serialize(); end

  def to_html(*args); end

  def to_xhtml(*args); end

  def to_xml(*args); end
end

class Nokogiri::XML::DocumentFragment
  def self.parse(tags); end
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::ElementContent
  def children(); end

  def document(); end

  def name(); end

  def occur(); end

  def prefix(); end

  def type(); end
  ELEMENT = ::T.let(nil, ::T.untyped)
  MULT = ::T.let(nil, ::T.untyped)
  ONCE = ::T.let(nil, ::T.untyped)
  OPT = ::T.let(nil, ::T.untyped)
  OR = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
  SEQ = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::ElementContent
end

class Nokogiri::XML::ElementDecl
  def element_type(); end

  def prefix(); end
end

class Nokogiri::XML::ElementDecl
end

class Nokogiri::XML::EntityDecl
  def entity_type(); end

  def external_id(); end

  def original_content(); end

  def system_id(); end
  EXTERNAL_GENERAL_PARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_GENERAL_UNPARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_GENERAL = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_PREDEFINED = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::EntityDecl
  def self.new(name, doc, *args); end
end

class Nokogiri::XML::EntityReference
end

class Nokogiri::XML::EntityReference
end

class Nokogiri::XML::Namespace
  include ::Nokogiri::XML::PP::Node
  def document(); end

  def href(); end

  def prefix(); end
end

class Nokogiri::XML::Namespace
end

class Nokogiri::XML::Node
  include ::Nokogiri::XML::PP::Node
  include ::Nokogiri::XML::Searchable
  include ::Enumerable
  include ::Nokogiri::HTML5::Node
  def <<(node_or_tags); end

  def ==(other); end

  def >(selector); end

  def [](name); end

  def []=(name, value); end

  def accept(visitor); end

  def add_child(node_or_tags); end

  def add_class(names); end

  def add_namespace(arg, arg1); end

  def add_namespace_definition(arg, arg1); end

  def add_next_sibling(node_or_tags); end

  def add_previous_sibling(node_or_tags); end

  def after(node_or_tags); end

  def ancestors(selector=T.unsafe(nil)); end

  def append_class(names); end

  def attr(name); end

  def attribute(arg); end

  def attribute_nodes(); end

  def attribute_with_ns(arg, arg1); end

  def attributes(); end

  def before(node_or_tags); end

  def blank?(); end

  def canonicalize(mode=T.unsafe(nil), inclusive_namespaces=T.unsafe(nil), with_comments=T.unsafe(nil)); end

  def cdata?(); end

  def child(); end

  def children(); end

  def children=(node_or_tags); end

  def classes(); end

  def coerce(data); end

  def comment?(); end

  def content(); end

  def content=(string); end

  def create_external_subset(arg, arg1, arg2); end

  def create_internal_subset(arg, arg1, arg2); end

  def css_path(); end

  def decorate!(); end

  def default_namespace=(url); end

  def delete(name); end

  def description(); end

  def do_xinclude(options=T.unsafe(nil)); end

  def document(); end

  def document?(); end

  def dup(*arg); end

  def each(&blk); end

  def elem?(); end

  def element?(); end

  def element_children(); end

  def elements(); end

  def encode_special_chars(arg); end

  def external_subset(); end

  def first_element_child(); end

  def fragment?(); end

  def get_attribute(name); end

  def has_attribute?(arg); end

  def html?(); end

  def initialize(name, document); end

  def inner_html=(node_or_tags); end

  def inner_text(); end

  def internal_subset(); end

  def key?(arg); end

  def keys(); end

  def kwattr_add(attribute_name, keywords); end

  def kwattr_append(attribute_name, keywords); end

  def kwattr_remove(attribute_name, keywords); end

  def kwattr_values(attribute_name); end

  def lang(); end

  def lang=(lang); end

  def last_element_child(); end

  def line(); end

  def line=(line); end

  def matches?(selector); end

  def name(); end

  def name=(name); end

  def namespace(); end

  def namespace=(ns); end

  def namespace_definitions(); end

  def namespace_scopes(); end

  def namespaced_key?(arg, arg1); end

  def namespaces(); end

  def native_content=(native_content); end

  def next(); end

  def next=(node_or_tags); end

  def next_element(); end

  def next_sibling(); end

  def node_name(); end

  def node_name=(node_name); end

  def node_type(); end

  def parent(); end

  def parent=(parent_node); end

  def parse(string_or_io, options=T.unsafe(nil)); end

  def path(); end

  def pointer_id(); end

  def prepend_child(node_or_tags); end

  def previous(); end

  def previous=(node_or_tags); end

  def previous_element(); end

  def previous_sibling(); end

  def processing_instruction?(); end

  def read_only?(); end

  def remove(); end

  def remove_attribute(name); end

  def remove_class(names=T.unsafe(nil)); end

  def replace(node_or_tags); end

  def serialize(*args, &block); end

  def set_attribute(name, value); end

  def swap(node_or_tags); end

  def text(); end

  def text?(); end

  def to_html(options=T.unsafe(nil)); end

  def to_str(); end

  def to_xhtml(options=T.unsafe(nil)); end

  def to_xml(options=T.unsafe(nil)); end

  def traverse(&block); end

  def type(); end

  def unlink(); end

  def value?(value); end

  def values(); end

  def wrap(html); end

  def write_html_to(io, options=T.unsafe(nil)); end

  def write_xhtml_to(io, options=T.unsafe(nil)); end

  def write_xml_to(io, options=T.unsafe(nil)); end

  def xml?(); end
  ATTRIBUTE_DECL = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_NODE = ::T.let(nil, ::T.untyped)
  CDATA_SECTION_NODE = ::T.let(nil, ::T.untyped)
  COMMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCB_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_FRAG_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_TYPE_NODE = ::T.let(nil, ::T.untyped)
  DTD_NODE = ::T.let(nil, ::T.untyped)
  ELEMENT_DECL = ::T.let(nil, ::T.untyped)
  ELEMENT_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_DECL = ::T.let(nil, ::T.untyped)
  ENTITY_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_REF_NODE = ::T.let(nil, ::T.untyped)
  HTML_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NAMESPACE_DECL = ::T.let(nil, ::T.untyped)
  NOTATION_NODE = ::T.let(nil, ::T.untyped)
  PI_NODE = ::T.let(nil, ::T.untyped)
  TEXT_NODE = ::T.let(nil, ::T.untyped)
  XINCLUDE_END = ::T.let(nil, ::T.untyped)
  XINCLUDE_START = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Node
end

class Nokogiri::XML::NodeSet
  include ::Nokogiri::XML::Searchable
  include ::Enumerable
  def &(arg); end

  def +(arg); end

  def -(arg); end

  def <<(arg); end

  def ==(other); end

  def >(selector); end

  def [](*arg); end

  def add_class(name); end

  def after(datum); end

  def append_class(name); end

  def attr(key, value=T.unsafe(nil), &block); end

  def attribute(key, value=T.unsafe(nil), &block); end

  def before(datum); end

  def children(); end

  def clone(); end

  def delete(arg); end

  def document(); end

  def document=(document); end

  def each(&blk); end

  def empty?(); end

  def filter(expr); end

  def first(n=T.unsafe(nil)); end

  def index(node=T.unsafe(nil)); end

  def initialize(document, list=T.unsafe(nil)); end

  def inner_html(*args); end

  def inner_text(); end

  def last(); end

  def length(); end

  def pop(); end

  def push(arg); end

  def remove(); end

  def remove_attr(name); end

  def remove_attribute(name); end

  def remove_class(name=T.unsafe(nil)); end

  def reverse(); end

  def set(key, value=T.unsafe(nil), &block); end

  def shift(); end

  def size(); end

  def slice(*arg); end

  def text(); end

  def to_a(); end

  def to_ary(); end

  def to_html(*args); end

  def to_xhtml(*args); end

  def to_xml(*args); end

  def unlink(); end

  def wrap(html); end

  def |(arg); end
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::NodeSet
end

class Nokogiri::XML::Notation
end

class Nokogiri::XML::Notation
end

module Nokogiri::XML::PP
end

module Nokogiri::XML::PP::CharacterData
  def inspect(); end

  def pretty_print(pp); end
end

module Nokogiri::XML::PP::CharacterData
end

module Nokogiri::XML::PP::Node
  def inspect(); end

  def pretty_print(pp); end
end

module Nokogiri::XML::PP::Node
end

module Nokogiri::XML::PP
end

class Nokogiri::XML::ParseOptions
  def ==(other); end

  def compact(); end

  def compact?(); end

  def default_html(); end

  def default_html?(); end

  def default_schema(); end

  def default_schema?(); end

  def default_xml(); end

  def default_xml?(); end

  def default_xslt(); end

  def default_xslt?(); end

  def dtdattr(); end

  def dtdattr?(); end

  def dtdload(); end

  def dtdload?(); end

  def dtdvalid(); end

  def dtdvalid?(); end

  def huge(); end

  def huge?(); end

  def initialize(options=T.unsafe(nil)); end

  def nobasefix(); end

  def nobasefix?(); end

  def noblanks(); end

  def noblanks?(); end

  def nocdata(); end

  def nocdata?(); end

  def nocompact(); end

  def nodefault_html(); end

  def nodefault_schema(); end

  def nodefault_xml(); end

  def nodefault_xslt(); end

  def nodict(); end

  def nodict?(); end

  def nodtdattr(); end

  def nodtdload(); end

  def nodtdvalid(); end

  def noent(); end

  def noent?(); end

  def noerror(); end

  def noerror?(); end

  def nohuge(); end

  def nonet(); end

  def nonet?(); end

  def nonobasefix(); end

  def nonoblanks(); end

  def nonocdata(); end

  def nonodict(); end

  def nonoent(); end

  def nonoerror(); end

  def nononet(); end

  def nonowarning(); end

  def nonoxincnode(); end

  def nonsclean(); end

  def noold10(); end

  def nopedantic(); end

  def norecover(); end

  def nosax1(); end

  def nowarning(); end

  def nowarning?(); end

  def noxinclude(); end

  def noxincnode(); end

  def noxincnode?(); end

  def nsclean(); end

  def nsclean?(); end

  def old10(); end

  def old10?(); end

  def options(); end

  def options=(options); end

  def pedantic(); end

  def pedantic?(); end

  def recover(); end

  def recover?(); end

  def sax1(); end

  def sax1?(); end

  def strict(); end

  def strict?(); end

  def to_i(); end

  def xinclude(); end

  def xinclude?(); end
  COMPACT = ::T.let(nil, ::T.untyped)
  DEFAULT_HTML = ::T.let(nil, ::T.untyped)
  DEFAULT_SCHEMA = ::T.let(nil, ::T.untyped)
  DEFAULT_XML = ::T.let(nil, ::T.untyped)
  DEFAULT_XSLT = ::T.let(nil, ::T.untyped)
  DTDATTR = ::T.let(nil, ::T.untyped)
  DTDLOAD = ::T.let(nil, ::T.untyped)
  DTDVALID = ::T.let(nil, ::T.untyped)
  HUGE = ::T.let(nil, ::T.untyped)
  NOBASEFIX = ::T.let(nil, ::T.untyped)
  NOBLANKS = ::T.let(nil, ::T.untyped)
  NOCDATA = ::T.let(nil, ::T.untyped)
  NODICT = ::T.let(nil, ::T.untyped)
  NOENT = ::T.let(nil, ::T.untyped)
  NOERROR = ::T.let(nil, ::T.untyped)
  NONET = ::T.let(nil, ::T.untyped)
  NOWARNING = ::T.let(nil, ::T.untyped)
  NOXINCNODE = ::T.let(nil, ::T.untyped)
  NSCLEAN = ::T.let(nil, ::T.untyped)
  OLD10 = ::T.let(nil, ::T.untyped)
  PEDANTIC = ::T.let(nil, ::T.untyped)
  RECOVER = ::T.let(nil, ::T.untyped)
  SAX1 = ::T.let(nil, ::T.untyped)
  STRICT = ::T.let(nil, ::T.untyped)
  XINCLUDE = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::ParseOptions
end

class Nokogiri::XML::ProcessingInstruction
  def initialize(document, name, content); end
end

class Nokogiri::XML::ProcessingInstruction
end

class Nokogiri::XML::Reader
  include ::Enumerable
  def attribute(arg); end

  def attribute_at(arg); end

  def attribute_count(); end

  def attribute_nodes(); end

  def attributes(); end

  def attributes?(); end

  def base_uri(); end

  def default?(); end

  def depth(); end

  def each(&blk); end

  def empty_element?(); end

  def encoding(); end

  def errors(); end

  def errors=(errors); end

  def initialize(source, url=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def inner_xml(); end

  def lang(); end

  def local_name(); end

  def name(); end

  def namespace_uri(); end

  def namespaces(); end

  def node_type(); end

  def outer_xml(); end

  def prefix(); end

  def read(); end

  def self_closing?(); end

  def source(); end

  def state(); end

  def value(); end

  def value?(); end

  def xml_version(); end
  TYPE_ATTRIBUTE = ::T.let(nil, ::T.untyped)
  TYPE_CDATA = ::T.let(nil, ::T.untyped)
  TYPE_COMMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_FRAGMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY_REFERENCE = ::T.let(nil, ::T.untyped)
  TYPE_NONE = ::T.let(nil, ::T.untyped)
  TYPE_NOTATION = ::T.let(nil, ::T.untyped)
  TYPE_PROCESSING_INSTRUCTION = ::T.let(nil, ::T.untyped)
  TYPE_SIGNIFICANT_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_TEXT = ::T.let(nil, ::T.untyped)
  TYPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_XML_DECLARATION = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Reader
  def self.from_io(*arg); end

  def self.from_memory(*arg); end
end

class Nokogiri::XML::RelaxNG
end

class Nokogiri::XML::RelaxNG
end

module Nokogiri::XML::SAX
end

class Nokogiri::XML::SAX::Document
  def cdata_block(string); end

  def characters(string); end

  def comment(string); end

  def end_document(); end

  def end_element(name); end

  def end_element_namespace(name, prefix=T.unsafe(nil), uri=T.unsafe(nil)); end

  def error(string); end

  def processing_instruction(name, content); end

  def start_document(); end

  def start_element(name, attrs=T.unsafe(nil)); end

  def start_element_namespace(name, attrs=T.unsafe(nil), prefix=T.unsafe(nil), uri=T.unsafe(nil), ns=T.unsafe(nil)); end

  def warning(string); end

  def xmldecl(version, encoding, standalone); end
end

class Nokogiri::XML::SAX::Document
end

class Nokogiri::XML::SAX::Parser
  def document(); end

  def document=(document); end

  def encoding(); end

  def encoding=(encoding); end

  def initialize(doc=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def parse(thing, &block); end

  def parse_file(filename); end

  def parse_io(io, encoding=T.unsafe(nil)); end

  def parse_memory(data); end
  ENCODINGS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::SAX::Parser
end

class Nokogiri::XML::SAX::ParserContext
  def column(); end

  def line(); end

  def parse_with(arg); end

  def recovery(); end

  def recovery=(recovery); end

  def replace_entities(); end

  def replace_entities=(replace_entities); end
end

class Nokogiri::XML::SAX::ParserContext
  def self.file(arg); end

  def self.io(arg, arg1); end

  def self.memory(arg); end

  def self.new(thing, encoding=T.unsafe(nil)); end
end

class Nokogiri::XML::SAX::PushParser
  def <<(chunk, last_chunk=T.unsafe(nil)); end

  def document(); end

  def document=(document); end

  def finish(); end

  def initialize(doc=T.unsafe(nil), file_name=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def replace_entities(); end

  def replace_entities=(replace_entities); end

  def write(chunk, last_chunk=T.unsafe(nil)); end
end

class Nokogiri::XML::SAX::PushParser
end

module Nokogiri::XML::SAX
end

class Nokogiri::XML::Schema
  def errors(); end

  def errors=(errors); end

  def parse_options(); end

  def parse_options=(parse_options); end

  def valid?(thing); end

  def validate(thing); end
end

class Nokogiri::XML::Schema
  def self.from_document(*arg); end

  def self.new(string_or_io, options=T.unsafe(nil)); end

  def self.read_memory(*arg); end
end

module Nokogiri::XML::Searchable
  def %(*args); end

  def /(*args); end

  def at(*args); end

  def at_css(*args); end

  def at_xpath(*args); end

  def css(*args); end

  def search(*args); end

  def xpath(*args); end
  LOOKS_LIKE_XPATH = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML::Searchable
end

class Nokogiri::XML::SyntaxError
  def code(); end

  def column(); end

  def domain(); end

  def error?(); end

  def fatal?(); end

  def file(); end

  def int1(); end

  def level(); end

  def line(); end

  def none?(); end

  def str1(); end

  def str2(); end

  def str3(); end

  def warning?(); end
end

class Nokogiri::XML::SyntaxError
end

class Nokogiri::XML::Text
end

class Nokogiri::XML::Text
end

module Nokogiri::XML::XPath
end

class Nokogiri::XML::XPath::SyntaxError
end

class Nokogiri::XML::XPath::SyntaxError
end

module Nokogiri::XML::XPath
end

class Nokogiri::XML::XPathContext
  def evaluate(*arg); end

  def register_namespaces(namespaces); end

  def register_ns(arg, arg1); end

  def register_variable(arg, arg1); end
end

class Nokogiri::XML::XPathContext
  def self.new(arg); end
end

module Nokogiri::XML
  def self.Reader(string_or_io, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.RelaxNG(string_or_io, options=T.unsafe(nil)); end

  def self.Schema(string_or_io, options=T.unsafe(nil)); end

  def self.fragment(string); end

  def self.parse(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end
end

module Nokogiri::XSLT
end

class Nokogiri::XSLT::Stylesheet
  def apply_to(document, params=T.unsafe(nil)); end

  def serialize(arg); end

  def transform(*arg); end
end

class Nokogiri::XSLT::Stylesheet
  def self.parse_stylesheet_doc(arg); end
end

module Nokogiri::XSLT
  def self.parse(string, modules=T.unsafe(nil)); end

  def self.quote_params(params); end

  def self.register(arg, arg1); end
end

module Nokogiri
  def self.HTML(input, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.HTML4(input, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.HTML5(input, url=T.unsafe(nil), encoding=T.unsafe(nil), **options, &block); end

  def self.Slop(*args, &block); end

  def self.XML(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.XSLT(stylesheet, modules=T.unsafe(nil)); end

  def self.install_default_aliases(); end

  def self.jruby?(); end

  def self.make(input=T.unsafe(nil), opts=T.unsafe(nil), &blk); end

  def self.parse(string, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.uses_gumbo?(); end

  def self.uses_libxml?(requirement=T.unsafe(nil)); end
end

class Numeric
  def to_liquid(); end
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  include ::Minitest::Expectations
  def pry(object=T.unsafe(nil), hash=T.unsafe(nil)); end

  def stub(name, val_or_callable, *block_args); end

  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(arg); end

  def negative?(); end
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*arg); end

  def self.pbkdf2_hmac(*arg); end

  def self.scrypt(*arg); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(arg); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  def alpn_protocols(); end

  def alpn_protocols=(alpn_protocols); end

  def alpn_select_cb(); end

  def alpn_select_cb=(alpn_select_cb); end

  def enable_fallback_scsv(); end

  def max_version=(version); end

  def min_version=(version); end
  DEFAULT_TMP_DH_CALLBACK = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def tmp_key(); end
end

module OpenSSL::X509
  V_ERR_CA_KEY_TOO_SMALL = ::T.let(nil, ::T.untyped)
  V_ERR_CA_MD_TOO_WEAK = ::T.let(nil, ::T.untyped)
  V_ERR_CRL_PATH_VALIDATION_ERROR = ::T.let(nil, ::T.untyped)
  V_ERR_DANE_NO_MATCH = ::T.let(nil, ::T.untyped)
  V_ERR_DIFFERENT_CRL_SCOPE = ::T.let(nil, ::T.untyped)
  V_ERR_EE_KEY_TOO_SMALL = ::T.let(nil, ::T.untyped)
  V_ERR_EMAIL_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_EXCLUDED_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_HOSTNAME_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_CALL = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_NON_CA = ::T.let(nil, ::T.untyped)
  V_ERR_INVALID_POLICY_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_IP_ADDRESS_MISMATCH = ::T.let(nil, ::T.untyped)
  V_ERR_KEYUSAGE_NO_CRL_SIGN = ::T.let(nil, ::T.untyped)
  V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE = ::T.let(nil, ::T.untyped)
  V_ERR_NO_EXPLICIT_POLICY = ::T.let(nil, ::T.untyped)
  V_ERR_NO_VALID_SCTS = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_CERT_UNKNOWN = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_VERIFY_FAILED = ::T.let(nil, ::T.untyped)
  V_ERR_OCSP_VERIFY_NEEDED = ::T.let(nil, ::T.untyped)
  V_ERR_PATH_LOOP = ::T.let(nil, ::T.untyped)
  V_ERR_PERMITTED_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_PATH_LENGTH_EXCEEDED = ::T.let(nil, ::T.untyped)
  V_ERR_PROXY_SUBJECT_NAME_VIOLATION = ::T.let(nil, ::T.untyped)
  V_ERR_STORE_LOOKUP = ::T.let(nil, ::T.untyped)
  V_ERR_SUBTREE_MINMAX = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_CANNOT_SIGN_P_384_WITH_P_256 = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_ALGORITHM = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_CURVE = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_SIGNATURE_ALGORITHM = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_INVALID_VERSION = ::T.let(nil, ::T.untyped)
  V_ERR_SUITE_B_LOS_NOT_ALLOWED = ::T.let(nil, ::T.untyped)
  V_ERR_UNABLE_TO_GET_CRL_ISSUER = ::T.let(nil, ::T.untyped)
  V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_UNHANDLED_CRITICAL_EXTENSION = ::T.let(nil, ::T.untyped)
  V_ERR_UNNESTED_RESOURCE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSPECIFIED = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_CONSTRAINT_TYPE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_EXTENSION_FEATURE = ::T.let(nil, ::T.untyped)
  V_ERR_UNSUPPORTED_NAME_SYNTAX = ::T.let(nil, ::T.untyped)
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_PARTIAL_CHAIN = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_128_LOS = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_128_LOS_ONLY = ::T.let(nil, ::T.untyped)
  V_FLAG_SUITEB_192_LOS = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
  V_FLAG_USE_CHECK_TIME = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

class OpenStruct
  VERSION = ::T.let(nil, ::T.untyped)
end

class OpenURI::Buffer
  def <<(str); end

  def io(); end

  def size(); end
  StringMax = ::T.let(nil, ::T.untyped)
end

class OpenURI::Buffer
end

class OpenURI::HTTPError
  def initialize(message, io); end
end

class OpenURI::HTTPRedirect
  def initialize(message, io, uri); end
end

module OpenURI::Meta
  def content_type_parse(); end

  def meta_add_field(name, value); end

  def meta_add_field2(name, values); end

  def meta_setup_encoding(); end
  RE_LWS = ::T.let(nil, ::T.untyped)
  RE_PARAMETERS = ::T.let(nil, ::T.untyped)
  RE_QUOTED_STRING = ::T.let(nil, ::T.untyped)
  RE_TOKEN = ::T.let(nil, ::T.untyped)
end

module OpenURI::Meta
  def self.init(obj, src=T.unsafe(nil)); end
end

module OpenURI
  def self.check_options(options); end

  def self.open_http(buf, target, proxy, options); end

  def self.open_loop(uri, options); end

  def self.open_uri(name, *rest); end

  def self.redirectable?(uri1, uri2); end

  def self.scan_open_optional_arguments(*rest); end
end

class OptionParser
  def additional_message(typ, opt); end
end

class OptionParser::List
  def get_candidates(id); end
end

class OptionParser::ParseError
  def additional(); end

  def additional=(additional); end
end

class PHP::Forms::Create
  def name(); end

  def name=(name); end

  def organization_id(); end

  def organization_id=(organization_id); end

  def shop_domain(); end

  def shop_domain=(shop_domain); end

  def type(); end

  def type=(type); end
end

class PStore
  def initialize(file, thread_safe=T.unsafe(nil)); end
end

ParseError = Racc::ParseError

module Parser
  MESSAGES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Parser::AST
end

class Parser::AST::Node
  def loc(); end

  def location(); end
end

class Parser::AST::Node
end

class Parser::AST::Processor
  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_argument(node); end

  def on_array(node); end

  def on_array_pattern(node); end

  def on_array_pattern_with_tail(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_blockarg_expr(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_const(node); end

  def on_const_pattern(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_empty_else(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_find_pattern(node); end

  def on_for(node); end

  def on_forward_arg(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_hash_pattern(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_iflipflop(node); end

  def on_in_match(node); end

  def on_in_pattern(node); end

  def on_index(node); end

  def on_indexasgn(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwargs(node); end

  def on_kwbegin(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_alt(node); end

  def on_match_as(node); end

  def on_match_current_line(node); end

  def on_match_pattern(node); end

  def on_match_pattern_p(node); end

  def on_match_rest(node); end

  def on_match_var(node); end

  def on_match_with_lvasgn(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_next(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_pin(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_procarg0(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_restarg_expr(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_super(node); end

  def on_undef(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_var(node); end

  def on_vasgn(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def process_argument_node(node); end

  def process_regular_node(node); end

  def process_var_asgn_node(node); end

  def process_variable_node(node); end
end

class Parser::AST::Processor
end

module Parser::AST
end

class Parser::Base
  def builder(); end

  def context(); end

  def current_arg_stack(); end

  def diagnostics(); end

  def initialize(builder=T.unsafe(nil)); end

  def lexer(); end

  def max_numparam_stack(); end

  def parse(source_buffer); end

  def parse_with_comments(source_buffer); end

  def pattern_hash_keys(); end

  def pattern_variables(); end

  def reset(); end

  def source_buffer(); end

  def static_env(); end

  def tokenize(source_buffer, recover=T.unsafe(nil)); end
end

class Parser::Base
  def self.default_parser(); end

  def self.parse(string, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_file_with_comments(filename); end

  def self.parse_with_comments(string, file=T.unsafe(nil), line=T.unsafe(nil)); end
end

module Parser::Builders
end

class Parser::Builders::Default
  def __ENCODING__(__ENCODING__t); end

  def __FILE__(__FILE__t); end

  def __LINE__(__LINE__t); end

  def accessible(node); end

  def alias(alias_t, to, from); end

  def arg(name_t); end

  def arg_expr(expr); end

  def args(begin_t, args, end_t, check_args=T.unsafe(nil)); end

  def array(begin_t, elements, end_t); end

  def array_pattern(lbrack_t, elements, rbrack_t); end

  def assign(lhs, eql_t, rhs); end

  def assignable(node); end

  def associate(begin_t, pairs, end_t); end

  def attr_asgn(receiver, dot_t, selector_t); end

  def back_ref(token); end

  def begin(begin_t, body, end_t); end

  def begin_body(compound_stmt, rescue_bodies=T.unsafe(nil), else_t=T.unsafe(nil), else_=T.unsafe(nil), ensure_t=T.unsafe(nil), ensure_=T.unsafe(nil)); end

  def begin_keyword(begin_t, body, end_t); end

  def binary_op(receiver, operator_t, arg); end

  def block(method_call, begin_t, args, body, end_t); end

  def block_pass(amper_t, arg); end

  def blockarg(amper_t, name_t); end

  def blockarg_expr(amper_t, expr); end

  def call_lambda(lambda_t); end

  def call_method(receiver, dot_t, selector_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def call_type_for_dot(dot_t); end

  def case(case_t, expr, when_bodies, else_t, else_body, end_t); end

  def case_match(case_t, expr, in_bodies, else_t, else_body, end_t); end

  def character(char_t); end

  def complex(complex_t); end

  def compstmt(statements); end

  def condition(cond_t, cond, then_t, if_true, else_t, if_false, end_t); end

  def condition_mod(if_true, if_false, cond_t, cond); end

  def const(name_t); end

  def const_fetch(scope, t_colon2, name_t); end

  def const_global(t_colon3, name_t); end

  def const_op_assignable(node); end

  def const_pattern(const, ldelim_t, pattern, rdelim_t); end

  def cvar(token); end

  def dedent_string(node, dedent_level); end

  def def_class(class_t, name, lt_t, superclass, body, end_t); end

  def def_endless_method(def_t, name_t, args, assignment_t, body); end

  def def_endless_singleton(def_t, definee, dot_t, name_t, args, assignment_t, body); end

  def def_method(def_t, name_t, args, body, end_t); end

  def def_module(module_t, name, body, end_t); end

  def def_sclass(class_t, lshft_t, expr, body, end_t); end

  def def_singleton(def_t, definee, dot_t, name_t, args, body, end_t); end

  def emit_file_line_as_literals(); end

  def emit_file_line_as_literals=(emit_file_line_as_literals); end

  def false(false_t); end

  def find_pattern(lbrack_t, elements, rbrack_t); end

  def float(float_t); end

  def for(for_t, iterator, in_t, iteratee, do_t, body, end_t); end

  def forward_arg(dots_t); end

  def forward_only_args(begin_t, dots_t, end_t); end

  def forwarded_args(dots_t); end

  def gvar(token); end

  def hash_pattern(lbrace_t, kwargs, rbrace_t); end

  def ident(token); end

  def if_guard(if_t, if_body); end

  def in_match(lhs, in_t, rhs); end

  def in_pattern(in_t, pattern, guard, then_t, body); end

  def index(receiver, lbrack_t, indexes, rbrack_t); end

  def index_asgn(receiver, lbrack_t, indexes, rbrack_t); end

  def integer(integer_t); end

  def ivar(token); end

  def keyword_cmd(type, keyword_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def kwarg(name_t); end

  def kwnilarg(dstar_t, nil_t); end

  def kwoptarg(name_t, value); end

  def kwrestarg(dstar_t, name_t=T.unsafe(nil)); end

  def kwsplat(dstar_t, arg); end

  def logical_op(type, lhs, op_t, rhs); end

  def loop(type, keyword_t, cond, do_t, body, end_t); end

  def loop_mod(type, body, keyword_t, cond); end

  def match_alt(left, pipe_t, right); end

  def match_as(value, assoc_t, as); end

  def match_hash_var(name_t); end

  def match_hash_var_from_str(begin_t, strings, end_t); end

  def match_label(label_type, label); end

  def match_nil_pattern(dstar_t, nil_t); end

  def match_op(receiver, match_t, arg); end

  def match_pair(label_type, label, value); end

  def match_pattern(lhs, match_t, rhs); end

  def match_pattern_p(lhs, match_t, rhs); end

  def match_rest(star_t, name_t=T.unsafe(nil)); end

  def match_var(name_t); end

  def match_with_trailing_comma(match, comma_t); end

  def multi_assign(lhs, eql_t, rhs); end

  def multi_lhs(begin_t, items, end_t); end

  def nil(nil_t); end

  def not_op(not_t, begin_t=T.unsafe(nil), receiver=T.unsafe(nil), end_t=T.unsafe(nil)); end

  def nth_ref(token); end

  def numargs(max_numparam); end

  def objc_kwarg(kwname_t, assoc_t, name_t); end

  def objc_restarg(star_t, name=T.unsafe(nil)); end

  def objc_varargs(pair, rest_of_varargs); end

  def op_assign(lhs, op_t, rhs); end

  def optarg(name_t, eql_t, value); end

  def pair(key, assoc_t, value); end

  def pair_keyword(key_t, value); end

  def pair_label(key_t); end

  def pair_list_18(list); end

  def pair_quoted(begin_t, parts, end_t, value); end

  def parser(); end

  def parser=(parser); end

  def pin(pin_t, var); end

  def postexe(postexe_t, lbrace_t, compstmt, rbrace_t); end

  def preexe(preexe_t, lbrace_t, compstmt, rbrace_t); end

  def procarg0(arg); end

  def range_exclusive(lhs, dot3_t, rhs); end

  def range_inclusive(lhs, dot2_t, rhs); end

  def rational(rational_t); end

  def regexp_compose(begin_t, parts, end_t, options); end

  def regexp_options(regopt_t); end

  def rescue_body(rescue_t, exc_list, assoc_t, exc_var, then_t, compound_stmt); end

  def restarg(star_t, name_t=T.unsafe(nil)); end

  def restarg_expr(star_t, expr=T.unsafe(nil)); end

  def self(token); end

  def shadowarg(name_t); end

  def splat(star_t, arg=T.unsafe(nil)); end

  def string(string_t); end

  def string_compose(begin_t, parts, end_t); end

  def string_internal(string_t); end

  def symbol(symbol_t); end

  def symbol_compose(begin_t, parts, end_t); end

  def symbol_internal(symbol_t); end

  def symbols_compose(begin_t, parts, end_t); end

  def ternary(cond, question_t, if_true, colon_t, if_false); end

  def true(true_t); end

  def unary_num(unary_t, numeric); end

  def unary_op(op_t, receiver); end

  def undef_method(undef_t, names); end

  def unless_guard(unless_t, unless_body); end

  def when(when_t, patterns, then_t, body); end

  def word(parts); end

  def words_compose(begin_t, parts, end_t); end

  def xstring_compose(begin_t, parts, end_t); end
end

class Parser::Builders::Default
  def self.emit_arg_inside_procarg0(); end

  def self.emit_arg_inside_procarg0=(emit_arg_inside_procarg0); end

  def self.emit_encoding(); end

  def self.emit_encoding=(emit_encoding); end

  def self.emit_forward_arg(); end

  def self.emit_forward_arg=(emit_forward_arg); end

  def self.emit_index(); end

  def self.emit_index=(emit_index); end

  def self.emit_kwargs(); end

  def self.emit_kwargs=(emit_kwargs); end

  def self.emit_lambda(); end

  def self.emit_lambda=(emit_lambda); end

  def self.emit_match_pattern(); end

  def self.emit_match_pattern=(emit_match_pattern); end

  def self.emit_procarg0(); end

  def self.emit_procarg0=(emit_procarg0); end

  def self.modernize(); end
end

module Parser::Builders
end

class Parser::ClobberingError
end

class Parser::ClobberingError
end

class Parser::Context
  def class_definition_allowed?(); end

  def dynamic_const_definition_allowed?(); end

  def empty?(); end

  def in_block?(); end

  def in_class?(); end

  def in_def_open_args?(); end

  def in_dynamic_block?(); end

  def in_lambda?(); end

  def indirectly_in_def?(); end

  def module_definition_allowed?(); end

  def pop(); end

  def push(state); end

  def reset(); end

  def stack(); end
end

class Parser::Context
end

class Parser::CurrentArgStack
  def empty?(); end

  def pop(); end

  def push(value); end

  def reset(); end

  def set(value); end

  def stack(); end

  def top(); end
end

class Parser::CurrentArgStack
end

module Parser::Deprecation
  def warn_of_deprecation(); end

  def warned_of_deprecation=(warned_of_deprecation); end
end

module Parser::Deprecation
end

class Parser::Diagnostic
  def arguments(); end

  def highlights(); end

  def initialize(level, reason, arguments, location, highlights=T.unsafe(nil)); end

  def level(); end

  def location(); end

  def message(); end

  def reason(); end

  def render(); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Parser::Diagnostic::Engine
  def all_errors_are_fatal(); end

  def all_errors_are_fatal=(all_errors_are_fatal); end

  def consumer(); end

  def consumer=(consumer); end

  def ignore?(diagnostic); end

  def ignore_warnings(); end

  def ignore_warnings=(ignore_warnings); end

  def initialize(consumer=T.unsafe(nil)); end

  def process(diagnostic); end

  def raise?(diagnostic); end
end

class Parser::Diagnostic::Engine
end

class Parser::Diagnostic
end

class Parser::Lexer
  def advance(); end

  def arg_or_cmdarg(cmd_state); end

  def cmdarg(); end

  def cmdarg=(cmdarg); end

  def cmdarg_stack(); end

  def command_start(); end

  def command_start=(command_start); end

  def comments(); end

  def comments=(comments); end

  def cond(); end

  def cond=(cond); end

  def cond_stack(); end

  def context(); end

  def context=(context); end

  def dedent_level(); end

  def diagnostic(type, reason, arguments=T.unsafe(nil), location=T.unsafe(nil), highlights=T.unsafe(nil)); end

  def diagnostics(); end

  def diagnostics=(diagnostics); end

  def emit(type, value=T.unsafe(nil), s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_comment(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_do(do_block=T.unsafe(nil)); end

  def emit_table(table, s=T.unsafe(nil), e=T.unsafe(nil)); end

  def encode_escape(ord); end

  def encoding(); end

  def eof_codepoint?(point); end

  def force_utf32(); end

  def force_utf32=(force_utf32); end

  def in_kwarg(); end

  def in_kwarg=(in_kwarg); end

  def initialize(version); end

  def lambda_stack(); end

  def literal(); end

  def next_state_for_literal(literal); end

  def paren_nest(); end

  def pop_cmdarg(); end

  def pop_cond(); end

  def pop_literal(); end

  def push_cmdarg(); end

  def push_cond(); end

  def push_literal(*args); end

  def range(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def reset(reset_state=T.unsafe(nil)); end

  def source_buffer(); end

  def source_buffer=(source_buffer); end

  def stack_pop(); end

  def state(); end

  def state=(state); end

  def static_env(); end

  def static_env=(static_env); end

  def tok(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def tokens(); end

  def tokens=(tokens); end

  def version?(*versions); end
  ESCAPES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_BEGIN = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  PUNCTUATION = ::T.let(nil, ::T.untyped)
  PUNCTUATION_BEGIN = ::T.let(nil, ::T.untyped)
  REGEXP_META_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
  def dedent(string); end

  def initialize(dedent_level); end

  def interrupt(); end
  TAB_WIDTH = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
end

class Parser::Lexer::Literal
  def backslash_delimited?(); end

  def clear_buffer(); end

  def coerce_encoding(string); end

  def dedent_level(); end

  def delimiter?(delimiter); end

  def emit(token, type, s, e); end

  def emit_start_tok(); end

  def end_interp_brace_and_try_closing(); end

  def extend_content(); end

  def extend_space(ts, te); end

  def extend_string(string, ts, te); end

  def flush_string(); end

  def heredoc?(); end

  def heredoc_e(); end

  def infer_indent_level(line); end

  def initialize(lexer, str_type, delimiter, str_s, heredoc_e=T.unsafe(nil), indent=T.unsafe(nil), dedent_body=T.unsafe(nil), label_allowed=T.unsafe(nil)); end

  def interpolate?(); end

  def munge_escape?(character); end

  def nest_and_try_closing(delimiter, ts, te, lookahead=T.unsafe(nil)); end

  def plain_heredoc?(); end

  def regexp?(); end

  def saved_herebody_s(); end

  def saved_herebody_s=(saved_herebody_s); end

  def squiggly_heredoc?(); end

  def start_interp_brace(); end

  def str_s(); end

  def supports_line_continuation_via_slash?(); end

  def type(); end

  def words?(); end
  DELIMITERS = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Literal
end

class Parser::Lexer::StackState
  def active?(); end

  def clear(); end

  def empty?(); end

  def initialize(name); end

  def lexpop(); end

  def pop(); end

  def push(bit); end
end

class Parser::Lexer::StackState
end

class Parser::Lexer
  def self.lex_en_expr_arg(); end

  def self.lex_en_expr_arg=(lex_en_expr_arg); end

  def self.lex_en_expr_beg(); end

  def self.lex_en_expr_beg=(lex_en_expr_beg); end

  def self.lex_en_expr_cmdarg(); end

  def self.lex_en_expr_cmdarg=(lex_en_expr_cmdarg); end

  def self.lex_en_expr_dot(); end

  def self.lex_en_expr_dot=(lex_en_expr_dot); end

  def self.lex_en_expr_end(); end

  def self.lex_en_expr_end=(lex_en_expr_end); end

  def self.lex_en_expr_endarg(); end

  def self.lex_en_expr_endarg=(lex_en_expr_endarg); end

  def self.lex_en_expr_endfn(); end

  def self.lex_en_expr_endfn=(lex_en_expr_endfn); end

  def self.lex_en_expr_fname(); end

  def self.lex_en_expr_fname=(lex_en_expr_fname); end

  def self.lex_en_expr_labelarg(); end

  def self.lex_en_expr_labelarg=(lex_en_expr_labelarg); end

  def self.lex_en_expr_mid(); end

  def self.lex_en_expr_mid=(lex_en_expr_mid); end

  def self.lex_en_expr_value(); end

  def self.lex_en_expr_value=(lex_en_expr_value); end

  def self.lex_en_expr_variable(); end

  def self.lex_en_expr_variable=(lex_en_expr_variable); end

  def self.lex_en_interp_backslash_delimited(); end

  def self.lex_en_interp_backslash_delimited=(lex_en_interp_backslash_delimited); end

  def self.lex_en_interp_backslash_delimited_words(); end

  def self.lex_en_interp_backslash_delimited_words=(lex_en_interp_backslash_delimited_words); end

  def self.lex_en_interp_string(); end

  def self.lex_en_interp_string=(lex_en_interp_string); end

  def self.lex_en_interp_words(); end

  def self.lex_en_interp_words=(lex_en_interp_words); end

  def self.lex_en_leading_dot(); end

  def self.lex_en_leading_dot=(lex_en_leading_dot); end

  def self.lex_en_line_begin(); end

  def self.lex_en_line_begin=(lex_en_line_begin); end

  def self.lex_en_line_comment(); end

  def self.lex_en_line_comment=(lex_en_line_comment); end

  def self.lex_en_plain_backslash_delimited(); end

  def self.lex_en_plain_backslash_delimited=(lex_en_plain_backslash_delimited); end

  def self.lex_en_plain_backslash_delimited_words(); end

  def self.lex_en_plain_backslash_delimited_words=(lex_en_plain_backslash_delimited_words); end

  def self.lex_en_plain_string(); end

  def self.lex_en_plain_string=(lex_en_plain_string); end

  def self.lex_en_plain_words(); end

  def self.lex_en_plain_words=(lex_en_plain_words); end

  def self.lex_en_regexp_modifiers(); end

  def self.lex_en_regexp_modifiers=(lex_en_regexp_modifiers); end

  def self.lex_error(); end

  def self.lex_error=(lex_error); end

  def self.lex_start(); end

  def self.lex_start=(lex_start); end
end

class Parser::MaxNumparamStack
  def empty?(); end

  def has_numparams?(); end

  def has_ordinary_params!(); end

  def has_ordinary_params?(); end

  def pop(); end

  def push(); end

  def register(numparam); end

  def stack(); end

  def top(); end
  ORDINARY_PARAMS = ::T.let(nil, ::T.untyped)
end

class Parser::MaxNumparamStack
end

module Parser::Messages
end

module Parser::Messages
  def self.compile(reason, arguments); end
end

module Parser::Meta
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

module Parser::Meta
end

class Parser::Rewriter
  def assignment?(node); end

  def initialize(*arg); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Rewriter
  extend ::Parser::Deprecation
end

module Parser::Source
end

class Parser::Source::Buffer
  def column_for_position(position); end

  def decompose_position(position); end

  def first_line(); end

  def initialize(name, first_line=T.unsafe(nil), source: T.unsafe(nil)); end

  def last_line(); end

  def line_for_position(position); end

  def line_range(lineno); end

  def name(); end

  def raw_source=(input); end

  def read(); end

  def slice(range); end

  def source(); end

  def source=(input); end

  def source_line(lineno); end

  def source_lines(); end

  def source_range(); end
  ENCODING_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  def self.recognize_encoding(string); end

  def self.reencode_string(input); end
end

class Parser::Source::Comment
  def ==(other); end

  def document?(); end

  def initialize(range); end

  def inline?(); end

  def loc(); end

  def location(); end

  def text(); end

  def type(); end
end

class Parser::Source::Comment::Associator
  def associate(); end

  def associate_by_identity(); end

  def associate_locations(); end

  def initialize(ast, comments); end

  def skip_directives(); end

  def skip_directives=(skip_directives); end
  MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
  POSTFIX_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Comment::Associator
end

class Parser::Source::Comment
  def self.associate(ast, comments); end

  def self.associate_by_identity(ast, comments); end

  def self.associate_locations(ast, comments); end
end

class Parser::Source::Map
  def ==(other); end

  def column(); end

  def expression(); end

  def first_line(); end

  def initialize(expression); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def node(); end

  def node=(node); end

  def to_hash(); end

  def update_expression(expression_l); end

  def with(&block); end

  def with_expression(expression_l); end
end

class Parser::Source::Map::Collection
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end
end

class Parser::Source::Map::Collection
end

class Parser::Source::Map::Condition
  def begin(); end

  def else(); end

  def end(); end

  def initialize(keyword_l, begin_l, else_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Condition
end

class Parser::Source::Map::Constant
  def double_colon(); end

  def initialize(double_colon, name, expression); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Constant
end

class Parser::Source::Map::Definition
  def end(); end

  def initialize(keyword_l, operator_l, name_l, end_l); end

  def keyword(); end

  def name(); end

  def operator(); end
end

class Parser::Source::Map::Definition
end

class Parser::Source::Map::For
  def begin(); end

  def end(); end

  def in(); end

  def initialize(keyword_l, in_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::For
end

class Parser::Source::Map::Heredoc
  def heredoc_body(); end

  def heredoc_end(); end

  def initialize(begin_l, body_l, end_l); end
end

class Parser::Source::Map::Heredoc
end

class Parser::Source::Map::Index
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Index
end

class Parser::Source::Map::Keyword
  def begin(); end

  def end(); end

  def initialize(keyword_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Keyword
end

class Parser::Source::Map::MethodDefinition
  def assignment(); end

  def end(); end

  def initialize(keyword_l, operator_l, name_l, end_l, assignment_l, body_l); end

  def keyword(); end

  def name(); end

  def operator(); end
end

class Parser::Source::Map::MethodDefinition
end

class Parser::Source::Map::ObjcKwarg
  def argument(); end

  def initialize(keyword_l, operator_l, argument_l, expression_l); end

  def keyword(); end

  def operator(); end
end

class Parser::Source::Map::ObjcKwarg
end

class Parser::Source::Map::Operator
  def initialize(operator, expression); end

  def operator(); end
end

class Parser::Source::Map::Operator
end

class Parser::Source::Map::RescueBody
  def assoc(); end

  def begin(); end

  def initialize(keyword_l, assoc_l, begin_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::RescueBody
end

class Parser::Source::Map::Send
  def begin(); end

  def dot(); end

  def end(); end

  def initialize(dot_l, selector_l, begin_l, end_l, expression_l); end

  def operator(); end

  def selector(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Send
end

class Parser::Source::Map::Ternary
  def colon(); end

  def initialize(question_l, colon_l, expression_l); end

  def question(); end
end

class Parser::Source::Map::Ternary
end

class Parser::Source::Map::Variable
  def initialize(name_l, expression_l=T.unsafe(nil)); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Variable
end

class Parser::Source::Map
end

class Parser::Source::Range
  include ::Comparable
  def adjust(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end

  def begin(); end

  def begin_pos(); end

  def column(); end

  def column_range(); end

  def contained?(other); end

  def contains?(other); end

  def crossing?(other); end

  def disjoint?(other); end

  def empty?(); end

  def end(); end

  def end_pos(); end

  def first_line(); end

  def initialize(source_buffer, begin_pos, end_pos); end

  def intersect(other); end

  def is?(*what); end

  def join(other); end

  def last_column(); end

  def last_line(); end

  def length(); end

  def line(); end

  def overlaps?(other); end

  def resize(new_size); end

  def size(); end

  def source(); end

  def source_buffer(); end

  def source_line(); end

  def to_a(); end

  def to_range(); end

  def with(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end
end

class Parser::Source::Range
end

class Parser::Source::Rewriter
  def diagnostics(); end

  def initialize(source_buffer); end

  def insert_after(range, content); end

  def insert_after_multi(range, content); end

  def insert_before(range, content); end

  def insert_before_multi(range, content); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Rewriter::Action
  include ::Comparable
  def allow_multiple_insertions(); end

  def allow_multiple_insertions?(); end

  def initialize(range, replacement=T.unsafe(nil), allow_multiple_insertions=T.unsafe(nil), order=T.unsafe(nil)); end

  def order(); end

  def range(); end

  def replacement(); end
end

class Parser::Source::Rewriter::Action
end

class Parser::Source::Rewriter
  extend ::Parser::Deprecation
end

class Parser::Source::TreeRewriter
  def action_root(); end

  def as_nested_actions(); end

  def as_replacements(); end

  def diagnostics(); end

  def empty?(); end

  def import!(foreign_rewriter, offset: T.unsafe(nil)); end

  def in_transaction?(); end

  def initialize(source_buffer, crossing_deletions: T.unsafe(nil), different_replacements: T.unsafe(nil), swallowed_insertions: T.unsafe(nil)); end

  def insert_after(range, content); end

  def insert_after_multi(range, text); end

  def insert_before(range, content); end

  def insert_before_multi(range, text); end

  def merge(with); end

  def merge!(with); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, insert_before, insert_after); end
  ACTIONS = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  POLICY_TO_LEVEL = ::T.let(nil, ::T.untyped)
end

class Parser::Source::TreeRewriter::Action
  def analyse_hierarchy(action); end

  def bsearch_child_index(from=T.unsafe(nil)); end

  def call_enforcer_for_merge(action); end

  def check_fusible(action, *fusible); end

  def children(); end

  def combine(action); end

  def combine_children(more_children); end

  def contract(); end

  def do_combine(action); end

  def empty?(); end

  def fuse_deletions(action, fusible, other_sibblings); end

  def initialize(range, enforcer, insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil), children: T.unsafe(nil)); end

  def insert_after(); end

  def insert_before(); end

  def insertion?(); end

  def merge(action); end

  def moved(source_buffer, offset); end

  def nested_actions(); end

  def ordered_replacements(); end

  def place_in_hierarchy(action); end

  def range(); end

  def replacement(); end

  def swallow(children); end

  def with(range: T.unsafe(nil), enforcer: T.unsafe(nil), children: T.unsafe(nil), insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil)); end
end

class Parser::Source::TreeRewriter::Action
end

class Parser::Source::TreeRewriter
  extend ::Parser::Deprecation
end

module Parser::Source
end

class Parser::StaticEnvironment
  def declare(name); end

  def declare_anonymous_blockarg(); end

  def declare_forward_args(); end

  def declared?(name); end

  def declared_anonymous_blockarg?(); end

  def declared_forward_args?(); end

  def empty?(); end

  def extend_dynamic(); end

  def extend_static(); end

  def reset(); end

  def unextend(); end
  ANONYMOUS_BLOCKARG = ::T.let(nil, ::T.untyped)
  FORWARD_ARGS = ::T.let(nil, ::T.untyped)
end

class Parser::StaticEnvironment
end

class Parser::SyntaxError
  def diagnostic(); end

  def initialize(diagnostic); end
end

class Parser::SyntaxError
end

class Parser::TreeRewriter
  def assignment?(node); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast, **policy); end

  def wrap(range, before, after); end
end

class Parser::TreeRewriter
end

class Parser::VariablesStack
  def declare(name); end

  def declared?(name); end

  def empty?(); end

  def pop(); end

  def push(); end

  def reset(); end
end

class Parser::VariablesStack
end

module Parser
end

class Pathname
  def fnmatch?(*arg); end

  def make_symlink(arg); end
end

class Proc
  include ::MethodSource::SourceLocation::ProcExtensions
  include ::MethodSource::MethodExtensions
  def <<(arg); end

  def >>(arg); end

  def clone(); end
end

class Pry
  def add_sticky_local(name, &block); end

  def backtrace(); end

  def backtrace=(backtrace); end

  def binding_stack(); end

  def binding_stack=(binding_stack); end

  def color(*args, &block); end

  def color=(*args, &block); end

  def commands(*args, &block); end

  def commands=(*args, &block); end

  def complete(str); end

  def config(); end

  def current_binding(); end

  def current_context(); end

  def custom_completions(); end

  def custom_completions=(custom_completions); end

  def editor(*args, &block); end

  def editor=(*args, &block); end

  def eval(line, options=T.unsafe(nil)); end

  def eval_string(); end

  def eval_string=(eval_string); end

  def evaluate_ruby(code); end

  def exception_handler(*args, &block); end

  def exception_handler=(*args, &block); end

  def exec_hook(name, *args, &block); end

  def exit_value(); end

  def extra_sticky_locals(*args, &block); end

  def extra_sticky_locals=(*args, &block); end

  def hooks(*args, &block); end

  def hooks=(*args, &block); end

  def initialize(options=T.unsafe(nil)); end

  def inject_local(name, value, binding); end

  def inject_sticky_locals!(); end

  def input(*args, &block); end

  def input=(*args, &block); end

  def input_ring(); end

  def last_dir(); end

  def last_dir=(last_dir); end

  def last_exception(); end

  def last_exception=(exception); end

  def last_file(); end

  def last_file=(last_file); end

  def last_result(); end

  def last_result=(last_result); end

  def last_result_is_exception?(); end

  def memory_size(); end

  def memory_size=(size); end

  def output(); end

  def output=(*args, &block); end

  def output_ring(); end

  def pager(); end

  def pager=(*args, &block); end

  def pop_prompt(); end

  def print(*args, &block); end

  def print=(*args, &block); end

  def process_command(val); end

  def process_command_safely(val); end

  def prompt(); end

  def prompt=(new_prompt); end

  def push_binding(object); end

  def push_initial_binding(target=T.unsafe(nil)); end

  def push_prompt(new_prompt); end

  def quiet?(); end

  def raise_up(*args); end

  def raise_up!(*args); end

  def raise_up_common(force, *args); end

  def repl(target=T.unsafe(nil)); end

  def reset_eval_string(); end

  def run_command(val); end

  def select_prompt(); end

  def set_last_result(result, code=T.unsafe(nil)); end

  def should_print?(); end

  def show_result(result); end

  def sticky_locals(); end

  def suppress_output(); end

  def suppress_output=(suppress_output); end

  def update_input_history(code); end
  BINDING_METHOD_IMPL = ::T.let(nil, ::T.untyped)
  Commands = ::T.let(nil, ::T.untyped)
  EMPTY_COMPLETIONS = ::T.let(nil, ::T.untyped)
  HAS_SAFE_LEVEL = ::T.let(nil, ::T.untyped)
  LOCAL_RC_FILE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::BasicObject
  include ::Kernel
  ENV = ::T.let(nil, ::T.untyped)
end

Pry::BasicObject::Dir = Dir

Pry::BasicObject::File = File

Pry::BasicObject::Kernel = Kernel

Pry::BasicObject::LoadError = LoadError

Pry::BasicObject::Pry = Pry

class Pry::BasicObject
end

class Pry::BlockCommand
  def call(*args); end

  def help(); end
end

class Pry::BlockCommand
end

module Pry::Byebug
end

module Pry::Byebug::Breakpoints
  def add_file(file, line, expression=T.unsafe(nil)); end

  def add_method(method, expression=T.unsafe(nil)); end

  def breakpoints(); end

  def change(id, expression=T.unsafe(nil)); end

  def delete(id); end

  def delete_all(); end

  def disable(id); end

  def disable_all(); end

  def each(&block); end

  def enable(id); end

  def find_by_id(id); end

  def last(); end

  def size(); end

  def to_a(); end
end

class Pry::Byebug::Breakpoints::FileBreakpoint
  def source_code(); end

  def to_s(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Pry::Byebug::Breakpoints::FileBreakpoint
end

class Pry::Byebug::Breakpoints::MethodBreakpoint
  def initialize(byebug_bp, method); end

  def source_code(); end

  def to_s(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Pry::Byebug::Breakpoints::MethodBreakpoint
end

module Pry::Byebug::Breakpoints
  extend ::Enumerable
  extend ::Pry::Byebug::Breakpoints
end

module Pry::Byebug
end

class Pry::CLI
end

class Pry::CLI::NoOptionsError
end

class Pry::CLI::NoOptionsError
end

class Pry::CLI
  def self.add_option_processor(&block); end

  def self.add_options(&block); end

  def self.add_plugin_options(); end

  def self.input_args(); end

  def self.input_args=(input_args); end

  def self.option_processors(); end

  def self.option_processors=(option_processors); end

  def self.options(); end

  def self.options=(options); end

  def self.parse_options(args=T.unsafe(nil)); end

  def self.reset(); end

  def self.start(opts); end
end

class Pry::ClassCommand
  def args(); end

  def args=(args); end

  def call(*args); end

  def complete(search); end

  def help(); end

  def options(opt); end

  def opts(); end

  def opts=(opts); end

  def process(); end

  def setup(); end

  def slop(); end

  def subcommands(cmd); end
end

class Pry::ClassCommand
  def self.inherited(klass); end

  def self.source_location(); end
end

class Pry::Code
  def <<(line); end

  def ==(other); end

  def after(lineno, lines=T.unsafe(nil)); end

  def alter(&block); end

  def around(lineno, lines=T.unsafe(nil)); end

  def before(lineno, lines=T.unsafe(nil)); end

  def between(start_line, end_line=T.unsafe(nil)); end

  def code_type(); end

  def code_type=(code_type); end

  def comment_describing(line_number); end

  def expression_at(line_number, consume=T.unsafe(nil)); end

  def grep(pattern); end

  def highlighted(); end

  def initialize(lines=T.unsafe(nil), start_line=T.unsafe(nil), code_type=T.unsafe(nil)); end

  def length(); end

  def max_lineno_width(); end

  def method_missing(method_name, *args, &block); end

  def nesting_at(line_number); end

  def print_to_output(output, color=T.unsafe(nil)); end

  def push(line); end

  def raw(); end

  def reject(&block); end

  def select(&block); end

  def take_lines(start_line, num_lines); end

  def with_indentation(spaces=T.unsafe(nil)); end

  def with_line_numbers(y_n=T.unsafe(nil)); end

  def with_marker(lineno=T.unsafe(nil)); end
end

class Pry::Code::CodeRange
  def indices_range(lines); end

  def initialize(start_line, end_line=T.unsafe(nil)); end
end

class Pry::Code::CodeRange
end

class Pry::Code::LOC
  def ==(other); end

  def add_line_number(max_width=T.unsafe(nil), color=T.unsafe(nil)); end

  def add_marker(marker_lineno); end

  def colorize(code_type); end

  def handle_multiline_entries_from_edit_command(line, max_width); end

  def indent(distance); end

  def initialize(line, lineno); end

  def line(); end

  def lineno(); end

  def tuple(); end
end

class Pry::Code::LOC
end

class Pry::Code
  extend ::MethodSource::CodeHelpers
  def self.from_file(filename, code_type=T.unsafe(nil)); end

  def self.from_method(meth, start_line=T.unsafe(nil)); end

  def self.from_module(mod, candidate_rank=T.unsafe(nil), start_line=T.unsafe(nil)); end
end

class Pry::CodeFile
  def code(); end

  def code_type(); end

  def initialize(filename, code_type=T.unsafe(nil)); end
  DEFAULT_EXT = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  FILES = ::T.let(nil, ::T.untyped)
  INITIAL_PWD = ::T.let(nil, ::T.untyped)
end

class Pry::CodeFile
end

class Pry::CodeObject
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def command_lookup(); end

  def default_lookup(); end

  def empty_lookup(); end

  def initialize(str, pry_instance, options=T.unsafe(nil)); end

  def method_or_class_lookup(); end

  def pry_instance(); end

  def pry_instance=(pry_instance); end

  def str(); end

  def str=(str); end

  def super_level(); end

  def super_level=(super_level); end

  def target(); end

  def target=(target); end
end

module Pry::CodeObject::Helpers
  def c_method?(); end

  def c_module?(); end

  def command?(); end

  def module_with_yard_docs?(); end

  def real_method_object?(); end
end

module Pry::CodeObject::Helpers
end

class Pry::CodeObject
  def self.lookup(str, pry_instance, options=T.unsafe(nil)); end
end

class Pry::ColorPrinter
  def pp(object); end

  def text(str, max_width=T.unsafe(nil)); end
end

class Pry::ColorPrinter
  def self.default(_output, value, pry_instance); end

  def self.pp(obj, output=T.unsafe(nil), max_width=T.unsafe(nil)); end
end

class Pry::Command
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  include ::Pry::Helpers::Text
  def _pry_(); end

  def _pry_=(_pry_); end

  def arg_string(); end

  def arg_string=(arg_string); end

  def block(); end

  def captures(); end

  def captures=(captures); end

  def check_for_command_collision(command_match, arg_string); end

  def command_block(); end

  def command_block=(command_block); end

  def command_name(); end

  def command_options(); end

  def command_set(); end

  def command_set=(command_set); end

  def commands(); end

  def complete(_search); end

  def context(); end

  def context=(context); end

  def description(); end

  def eval_string(); end

  def eval_string=(eval_string); end

  def hooks(); end

  def hooks=(hooks); end

  def initialize(context=T.unsafe(nil)); end

  def interpolate_string(str); end

  def match(); end

  def name(); end

  def output(); end

  def output=(output); end

  def process_line(line); end

  def pry_instance(); end

  def pry_instance=(pry_instance); end

  def run(command_string, *args); end

  def source(); end

  def state(); end

  def target(); end

  def target=(target); end

  def target_self(); end

  def tokenize(val); end

  def void(); end
  VOID_VALUE = ::T.let(nil, ::T.untyped)
end

class Pry::Command::AmendLine
end

class Pry::Command::AmendLine
end

class Pry::Command::Bang
end

class Pry::Command::Bang
end

class Pry::Command::BangPry
end

class Pry::Command::BangPry
end

class Pry::Command::Cat
  def load_path_completions(); end
end

class Pry::Command::Cat::AbstractFormatter
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  include ::Pry::Helpers::BaseHelpers
end

class Pry::Command::Cat::AbstractFormatter
end

class Pry::Command::Cat::ExceptionFormatter
  include ::Pry::Helpers::Text
  def ex(); end

  def format(); end

  def initialize(exception, pry_instance, opts); end

  def opts(); end

  def pry_instance(); end
end

class Pry::Command::Cat::ExceptionFormatter
end

class Pry::Command::Cat::FileFormatter
  def file_and_line(); end

  def file_with_embedded_line(); end

  def format(); end

  def initialize(file_with_embedded_line, pry_instance, opts); end

  def opts(); end

  def pry_instance(); end
end

class Pry::Command::Cat::FileFormatter
end

class Pry::Command::Cat::InputExpressionFormatter
  def format(); end

  def initialize(input_expressions, opts); end

  def input_expressions(); end

  def input_expressions=(input_expressions); end

  def opts(); end

  def opts=(opts); end
end

class Pry::Command::Cat::InputExpressionFormatter
end

class Pry::Command::Cat
end

class Pry::Command::Cd
end

class Pry::Command::Cd
end

class Pry::Command::ChangeInspector
  def process(inspector); end
end

class Pry::Command::ChangeInspector
end

class Pry::Command::ChangePrompt
  def process(prompt); end
end

class Pry::Command::ChangePrompt
end

class Pry::Command::ClearScreen
end

class Pry::Command::ClearScreen
end

class Pry::Command::CodeCollector
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def args(); end

  def code_object(); end

  def content(); end

  def file(); end

  def file=(file); end

  def initialize(args, opts, pry_instance); end

  def line_range(); end

  def obj_name(); end

  def opts(); end

  def pry_input_content(); end

  def pry_instance(); end

  def pry_output_content(); end

  def restrict_to_lines(content, range); end
end

class Pry::Command::CodeCollector
  def self.inject_options(opt); end

  def self.input_expression_ranges(); end

  def self.input_expression_ranges=(input_expression_ranges); end

  def self.output_result_ranges(); end

  def self.output_result_ranges=(output_result_ranges); end
end

class Pry::Command::DisablePry
end

class Pry::Command::DisablePry
end

class Pry::Command::Edit
  def apply_runtime_patch(); end

  def bad_option_combination?(); end

  def code_object(); end

  def ensure_file_name_is_valid(file_name); end

  def file_and_line(); end

  def file_and_line_for_current_exception(); end

  def file_based_exception?(); end

  def file_edit(); end

  def filename_argument(); end

  def initial_temp_file_content(); end

  def input_expression(); end

  def never_reload?(); end

  def patch_exception?(); end

  def previously_patched?(code_object); end

  def probably_a_file?(str); end

  def pry_method?(code_object); end

  def reload?(file_name=T.unsafe(nil)); end

  def reloadable?(); end

  def repl_edit(); end

  def repl_edit?(); end

  def runtime_patch?(); end
end

class Pry::Command::Edit::ExceptionPatcher
  def file_and_line(); end

  def file_and_line=(file_and_line); end

  def initialize(pry_instance, state, exception_file_and_line); end

  def perform_patch(); end

  def pry_instance(); end

  def pry_instance=(pry_instance); end

  def state(); end

  def state=(state); end
end

class Pry::Command::Edit::ExceptionPatcher
end

module Pry::Command::Edit::FileAndLineLocator
end

module Pry::Command::Edit::FileAndLineLocator
  def self.from_binding(target); end

  def self.from_code_object(code_object, filename_argument); end

  def self.from_exception(exception, backtrace_level); end

  def self.from_filename_argument(filename_argument); end
end

class Pry::Command::Edit
end

class Pry::Command::Exit
  def process_pop_and_return(); end
end

class Pry::Command::Exit
end

class Pry::Command::ExitAll
end

class Pry::Command::ExitAll
end

class Pry::Command::ExitProgram
end

class Pry::Command::ExitProgram
end

class Pry::Command::FindMethod
end

class Pry::Command::FindMethod
  extend ::Pry::Helpers::BaseHelpers
end

class Pry::Command::FixIndent
end

class Pry::Command::FixIndent
end

class Pry::Command::Help
  def command_groups(); end

  def display_command(command); end

  def display_filtered_commands(search); end

  def display_filtered_search_results(search); end

  def display_index(groups); end

  def display_search(search); end

  def group_sort_key(group_name); end

  def help_text_for_commands(name, commands); end

  def normalize(key); end

  def search_hash(search, hash); end

  def sorted_commands(commands); end

  def sorted_group_names(groups); end

  def visible_commands(); end
end

class Pry::Command::Help
end

class Pry::Command::Hist
end

class Pry::Command::Hist
end

class Pry::Command::ImportSet
  def process(_command_set_name); end
end

class Pry::Command::ImportSet
end

class Pry::Command::JumpTo
  def process(break_level); end
end

class Pry::Command::JumpTo
end

class Pry::Command::ListInspectors
end

class Pry::Command::ListInspectors
end

class Pry::Command::Ls
  def no_user_opts?(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
  include ::Pry::Command::Ls::Interrogatable
  def initialize(interrogatee, no_user_opts, opts, pry_instance); end
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
end

class Pry::Command::Ls::Formatter
  def grep=(grep); end

  def initialize(pry_instance); end

  def pry_instance(); end

  def write_out(); end
end

class Pry::Command::Ls::Formatter
end

class Pry::Command::Ls::Globals
  def initialize(opts, pry_instance); end
  BUILTIN_GLOBALS = ::T.let(nil, ::T.untyped)
  PSEUDO_GLOBALS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Globals
end

class Pry::Command::Ls::Grep
  def initialize(grep_regexp); end

  def regexp(); end
end

class Pry::Command::Ls::Grep
end

class Pry::Command::Ls::InstanceVars
  include ::Pry::Command::Ls::Interrogatable
  def initialize(interrogatee, no_user_opts, opts, pry_instance); end
end

class Pry::Command::Ls::InstanceVars
end

module Pry::Command::Ls::Interrogatable
end

module Pry::Command::Ls::Interrogatable
end

module Pry::Command::Ls::JRubyHacks
end

module Pry::Command::Ls::JRubyHacks
end

class Pry::Command::Ls::LocalNames
  def initialize(no_user_opts, args, pry_instance); end
end

class Pry::Command::Ls::LocalNames
end

class Pry::Command::Ls::LocalVars
  def initialize(opts, pry_instance); end
end

class Pry::Command::Ls::LocalVars
end

class Pry::Command::Ls::LsEntity
  def entities_table(); end

  def initialize(opts); end

  def pry_instance(); end
end

class Pry::Command::Ls::LsEntity
end

class Pry::Command::Ls::Methods
  include ::Pry::Command::Ls::Interrogatable
  include ::Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
  def initialize(interrogatee, no_user_opts, opts, pry_instance); end
end

class Pry::Command::Ls::Methods
end

module Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
end

module Pry::Command::Ls::MethodsHelper
end

class Pry::Command::Ls::SelfMethods
  include ::Pry::Command::Ls::Interrogatable
  include ::Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
  def initialize(interrogatee, no_user_opts, opts, pry_instance); end
end

class Pry::Command::Ls::SelfMethods
end

class Pry::Command::Ls
end

class Pry::Command::Nesting
end

class Pry::Command::Nesting
end

class Pry::Command::Play
  def code_object(); end

  def content(); end

  def content_after_options(); end

  def content_at_expression(); end

  def default_file(); end

  def file_content(); end

  def perform_play(); end

  def should_use_default_file?(); end

  def show_input(); end
end

class Pry::Command::Play
end

class Pry::Command::PryBacktrace
end

class Pry::Command::PryBacktrace
end

class Pry::Command::RaiseUp
end

class Pry::Command::RaiseUp
end

class Pry::Command::ReloadCode
end

class Pry::Command::ReloadCode
end

class Pry::Command::Reset
end

class Pry::Command::Reset
end

class Pry::Command::Ri
  def process(spec); end
end

class Pry::Command::Ri
end

class Pry::Command::SaveFile
  def display_content(); end

  def file_name(); end

  def mode(); end

  def save_file(); end
end

class Pry::Command::SaveFile
end

class Pry::Command::ShellCommand
  def process(cmd); end
end

class Pry::Command::ShellCommand
end

class Pry::Command::ShellMode
end

class Pry::Command::ShellMode
end

class Pry::Command::ShowDoc
  include ::Pry::Helpers::DocumentationHelpers
  def content_for(code_object); end

  def docs_for(code_object); end

  def render_doc_markup_for(code_object); end
end

class Pry::Command::ShowDoc
end

class Pry::Command::ShowInfo
  def code_object_header(code_object, line_num); end

  def code_object_with_accessible_source(code_object); end

  def complete(input); end

  def content_and_header_for_code_object(code_object); end

  def content_and_headers_for_all_module_candidates(mod); end

  def file_and_line_for(code_object); end

  def header(code_object); end

  def header_options(); end

  def initialize(*arg); end

  def method_header(code_object, line_num); end

  def method_sections(code_object); end

  def module_header(code_object, line_num); end

  def no_definition_message(); end

  def obj_name(); end

  def show_all_modules?(code_object); end

  def start_line_for(code_object); end

  def use_line_numbers?(); end

  def valid_superclass?(code_object); end
end

class Pry::Command::ShowInfo
  extend ::Pry::Helpers::BaseHelpers
end

class Pry::Command::ShowInput
end

class Pry::Command::ShowInput
end

class Pry::Command::ShowSource
  include ::Pry::Helpers::DocumentationHelpers
  def content_for(code_object); end

  def docs_for(code_object); end

  def render_doc_markup_for(code_object); end
end

class Pry::Command::ShowSource
end

class Pry::Command::Stat
end

class Pry::Command::Stat
end

class Pry::Command::SwitchTo
  def process(selection); end
end

class Pry::Command::SwitchTo
end

class Pry::Command::ToggleColor
  def color_toggle(); end
end

class Pry::Command::ToggleColor
end

class Pry::Command::Version
end

class Pry::Command::Version
end

class Pry::Command::WatchExpression
end

class Pry::Command::WatchExpression::Expression
  def changed?(); end

  def eval!(); end

  def initialize(pry_instance, target, source); end

  def previous_value(); end

  def pry_instance(); end

  def source(); end

  def target(); end

  def value(); end
end

class Pry::Command::WatchExpression::Expression
end

class Pry::Command::WatchExpression
end

class Pry::Command::Whereami
  def bad_option_combination?(); end

  def code(); end

  def code?(); end

  def initialize(*arg); end

  def location(); end
end

class Pry::Command::Whereami
  def self.method_size_cutoff(); end

  def self.method_size_cutoff=(method_size_cutoff); end
end

class Pry::Command::Wtf
  RUBY_FRAME_PATTERN = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Wtf
end

class Pry::Command
  extend ::Pry::Helpers::DocumentationHelpers
  extend ::Pry::CodeObject::Helpers
  def self.banner(arg=T.unsafe(nil)); end

  def self.block(); end

  def self.block=(block); end

  def self.command_name(); end

  def self.command_options(arg=T.unsafe(nil)); end

  def self.command_options=(command_options); end

  def self.command_regex(); end

  def self.convert_to_regex(obj); end

  def self.default_options(match); end

  def self.description(arg=T.unsafe(nil)); end

  def self.description=(description); end

  def self.doc(); end

  def self.file(); end

  def self.group(name=T.unsafe(nil)); end

  def self.line(); end

  def self.match(arg=T.unsafe(nil)); end

  def self.match=(match); end

  def self.match_score(val); end

  def self.matches?(val); end

  def self.options(arg=T.unsafe(nil)); end

  def self.options=(options); end

  def self.source(); end

  def self.source_file(); end

  def self.source_line(); end

  def self.state(); end

  def self.subclass(match, description, options, helpers, &block); end
end

class Pry::CommandError
end

class Pry::CommandError
end

class Pry::CommandSet
  include ::Enumerable
  include ::Pry::Helpers::BaseHelpers
  def [](pattern); end

  def []=(pattern, command); end

  def add_command(command); end

  def alias_command(match, action, options=T.unsafe(nil)); end

  def block_command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def complete(search, context=T.unsafe(nil)); end

  def create_command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def delete(*searches); end

  def desc(search, description=T.unsafe(nil)); end

  def each(&block); end

  def find_command(pattern); end

  def find_command_by_match_or_listing(match_or_listing); end

  def find_command_for_help(search); end

  def helper_module(); end

  def import(*sets); end

  def import_from(set, *matches); end

  def initialize(*imported_sets, &block); end

  def keys(); end

  def list_commands(); end

  def process_line(val, context=T.unsafe(nil)); end

  def rename_command(new_match, search, options=T.unsafe(nil)); end

  def to_h(); end

  def to_hash(); end

  def valid_command?(val); end
end

class Pry::CommandSet
end

class Pry::CommandState
  def reset(command_name); end

  def state_for(command_name); end
end

class Pry::CommandState
  def self.default(); end
end

class Pry::Config
  def [](attr); end

  def []=(attr, value); end

  def auto_indent(); end

  def auto_indent=(auto_indent); end

  def collision_warning(); end

  def collision_warning=(collision_warning); end

  def color(); end

  def color=(color); end

  def command_completions(); end

  def command_completions=(command_completions); end

  def command_prefix(); end

  def command_prefix=(command_prefix); end

  def commands(); end

  def commands=(commands); end

  def completer(); end

  def completer=(completer); end

  def control_d_handler(); end

  def control_d_handler=(value); end

  def correct_indent(); end

  def correct_indent=(correct_indent); end

  def default_window_size(); end

  def default_window_size=(default_window_size); end

  def disable_auto_reload(); end

  def disable_auto_reload=(disable_auto_reload); end

  def editor(); end

  def editor=(editor); end

  def exception_handler(); end

  def exception_handler=(exception_handler); end

  def exception_whitelist(); end

  def exception_whitelist=(exception_whitelist); end

  def exec_string(); end

  def exec_string=(exec_string); end

  def extra_sticky_locals(); end

  def extra_sticky_locals=(extra_sticky_locals); end

  def file_completions(); end

  def file_completions=(file_completions); end

  def history(); end

  def history=(history); end

  def history_file(); end

  def history_file=(history_file); end

  def history_ignorelist(); end

  def history_ignorelist=(history_ignorelist); end

  def history_load(); end

  def history_load=(history_load); end

  def history_save(); end

  def history_save=(history_save); end

  def hooks(); end

  def hooks=(hooks); end

  def input(); end

  def input=(input); end

  def ls(); end

  def ls=(ls); end

  def memory_size(); end

  def memory_size=(memory_size); end

  def merge(config_hash); end

  def merge!(config_hash); end

  def method_missing(method_name, *args, &_block); end

  def output(); end

  def output=(output); end

  def output_prefix(); end

  def output_prefix=(output_prefix); end

  def pager(); end

  def pager=(pager); end

  def print(); end

  def print=(print); end

  def prompt(); end

  def prompt=(prompt); end

  def prompt_name(); end

  def prompt_name=(prompt_name); end

  def prompt_safe_contexts(); end

  def prompt_safe_contexts=(prompt_safe_contexts); end

  def quiet(); end

  def quiet=(quiet); end

  def rc_file(); end

  def rc_file=(rc_file); end

  def requires(); end

  def requires=(requires); end

  def should_load_local_rc(); end

  def should_load_local_rc=(should_load_local_rc); end

  def should_load_plugins(); end

  def should_load_plugins=(should_load_plugins); end

  def should_load_rc(); end

  def should_load_rc=(should_load_rc); end

  def should_load_requires(); end

  def should_load_requires=(should_load_requires); end

  def should_trap_interrupts(); end

  def should_trap_interrupts=(should_trap_interrupts); end

  def system(); end

  def system=(system); end

  def unrescued_exceptions(); end

  def unrescued_exceptions=(unrescued_exceptions); end

  def windows_console_warning(); end

  def windows_console_warning=(windows_console_warning); end
end

module Pry::Config::Attributable
  def attribute(attr_name); end
end

module Pry::Config::Attributable
end

class Pry::Config::LazyValue
  def call(); end

  def initialize(&block); end
end

class Pry::Config::LazyValue
end

class Pry::Config::MemoizedValue
  def call(); end

  def initialize(&block); end
end

class Pry::Config::MemoizedValue
end

class Pry::Config::Value
  def call(); end

  def initialize(value); end
end

class Pry::Config::Value
end

class Pry::Config
  extend ::Pry::Config::Attributable
end

module Pry::ControlDHandler
end

module Pry::ControlDHandler
  def self.default(pry_instance); end
end

class Pry::Editor
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def build_editor_invocation_string(file, line, blocking); end

  def edit_tempfile_with_content(initial_content, line=T.unsafe(nil)); end

  def initialize(pry_instance); end

  def invoke_editor(file, line, blocking=T.unsafe(nil)); end

  def pry_instance(); end
end

class Pry::Editor
  def self.default(); end
end

module Pry::Env
end

module Pry::Env
  def self.[](key); end
end

module Pry::ExceptionHandler
end

module Pry::ExceptionHandler
  def self.handle_exception(output, exception, _pry_instance); end
end

module Pry::Forwardable
  include ::Forwardable
  def def_private_delegators(target, *private_delegates); end
end

module Pry::Forwardable
end

module Pry::FrozenObjectException
end

module Pry::FrozenObjectException
  def self.===(exception); end
end

module Pry::Helpers
end

module Pry::Helpers::BaseHelpers
  def colorize_code(code); end

  def find_command(name, set=T.unsafe(nil)); end

  def heading(text); end

  def highlight(string, regexp, highlight_color=T.unsafe(nil)); end

  def not_a_real_file?(file); end

  def safe_send(obj, method, *args, &block); end

  def silence_warnings(); end

  def stagger_output(text, _out=T.unsafe(nil)); end

  def use_ansi_codes?(); end
end

module Pry::Helpers::BaseHelpers
  extend ::Pry::Helpers::BaseHelpers
end

module Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def absolute_index_number(line_number, array_length); end

  def absolute_index_range(range_or_number, array_length); end

  def get_method_or_raise(method_name, context, opts=T.unsafe(nil)); end

  def internal_binding?(context); end

  def one_index_number(line_number); end

  def one_index_range(range); end

  def one_index_range_or_number(range_or_number); end

  def restrict_to_lines(content, lines); end

  def set_file_and_dir_locals(file_name, pry=T.unsafe(nil), ctx=T.unsafe(nil)); end

  def temp_file(ext=T.unsafe(nil)); end

  def unindent(dirty_text, left_padding=T.unsafe(nil)); end
end

module Pry::Helpers::CommandHelpers
  extend ::Pry::Helpers::CommandHelpers
  extend ::Pry::Helpers::OptionsHelpers
end

module Pry::Helpers::DocumentationHelpers
  YARD_TAGS = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::DocumentationHelpers
  def self.get_comment_content(comment); end

  def self.process_comment_markup(comment); end

  def self.process_rdoc(comment); end

  def self.process_yardoc(comment); end

  def self.process_yardoc_tag(comment, tag); end

  def self.strip_comments_from_c_code(code); end

  def self.strip_leading_whitespace(text); end
end

module Pry::Helpers::OptionsHelpers
end

module Pry::Helpers::OptionsHelpers
  def self.method_object(); end

  def self.method_options(opt); end
end

module Pry::Helpers::Platform
end

module Pry::Helpers::Platform
  def self.jruby?(); end

  def self.jruby_19?(); end

  def self.linux?(); end

  def self.mac_osx?(); end

  def self.mri?(); end

  def self.mri_19?(); end

  def self.mri_2?(); end

  def self.windows?(); end

  def self.windows_ansi?(); end
end

class Pry::Helpers::Table
  def ==(other); end

  def column_count(); end

  def column_count=(count); end

  def columns(); end

  def fits_on_line?(line_length); end

  def initialize(items, args, pry_instance=T.unsafe(nil)); end

  def items(); end

  def items=(items); end

  def rows_to_s(style=T.unsafe(nil)); end

  def to_a(); end
end

class Pry::Helpers::Table
end

module Pry::Helpers::Text
  def black(text); end

  def black_on_black(text); end

  def black_on_blue(text); end

  def black_on_cyan(text); end

  def black_on_green(text); end

  def black_on_magenta(text); end

  def black_on_purple(text); end

  def black_on_red(text); end

  def black_on_white(text); end

  def black_on_yellow(text); end

  def blue(text); end

  def blue_on_black(text); end

  def blue_on_blue(text); end

  def blue_on_cyan(text); end

  def blue_on_green(text); end

  def blue_on_magenta(text); end

  def blue_on_purple(text); end

  def blue_on_red(text); end

  def blue_on_white(text); end

  def blue_on_yellow(text); end

  def bold(text); end

  def bright_black(text); end

  def bright_black_on_black(text); end

  def bright_black_on_blue(text); end

  def bright_black_on_cyan(text); end

  def bright_black_on_green(text); end

  def bright_black_on_magenta(text); end

  def bright_black_on_purple(text); end

  def bright_black_on_red(text); end

  def bright_black_on_white(text); end

  def bright_black_on_yellow(text); end

  def bright_blue(text); end

  def bright_blue_on_black(text); end

  def bright_blue_on_blue(text); end

  def bright_blue_on_cyan(text); end

  def bright_blue_on_green(text); end

  def bright_blue_on_magenta(text); end

  def bright_blue_on_purple(text); end

  def bright_blue_on_red(text); end

  def bright_blue_on_white(text); end

  def bright_blue_on_yellow(text); end

  def bright_cyan(text); end

  def bright_cyan_on_black(text); end

  def bright_cyan_on_blue(text); end

  def bright_cyan_on_cyan(text); end

  def bright_cyan_on_green(text); end

  def bright_cyan_on_magenta(text); end

  def bright_cyan_on_purple(text); end

  def bright_cyan_on_red(text); end

  def bright_cyan_on_white(text); end

  def bright_cyan_on_yellow(text); end

  def bright_green(text); end

  def bright_green_on_black(text); end

  def bright_green_on_blue(text); end

  def bright_green_on_cyan(text); end

  def bright_green_on_green(text); end

  def bright_green_on_magenta(text); end

  def bright_green_on_purple(text); end

  def bright_green_on_red(text); end

  def bright_green_on_white(text); end

  def bright_green_on_yellow(text); end

  def bright_magenta(text); end

  def bright_magenta_on_black(text); end

  def bright_magenta_on_blue(text); end

  def bright_magenta_on_cyan(text); end

  def bright_magenta_on_green(text); end

  def bright_magenta_on_magenta(text); end

  def bright_magenta_on_purple(text); end

  def bright_magenta_on_red(text); end

  def bright_magenta_on_white(text); end

  def bright_magenta_on_yellow(text); end

  def bright_purple(text); end

  def bright_purple_on_black(text); end

  def bright_purple_on_blue(text); end

  def bright_purple_on_cyan(text); end

  def bright_purple_on_green(text); end

  def bright_purple_on_magenta(text); end

  def bright_purple_on_purple(text); end

  def bright_purple_on_red(text); end

  def bright_purple_on_white(text); end

  def bright_purple_on_yellow(text); end

  def bright_red(text); end

  def bright_red_on_black(text); end

  def bright_red_on_blue(text); end

  def bright_red_on_cyan(text); end

  def bright_red_on_green(text); end

  def bright_red_on_magenta(text); end

  def bright_red_on_purple(text); end

  def bright_red_on_red(text); end

  def bright_red_on_white(text); end

  def bright_red_on_yellow(text); end

  def bright_white(text); end

  def bright_white_on_black(text); end

  def bright_white_on_blue(text); end

  def bright_white_on_cyan(text); end

  def bright_white_on_green(text); end

  def bright_white_on_magenta(text); end

  def bright_white_on_purple(text); end

  def bright_white_on_red(text); end

  def bright_white_on_white(text); end

  def bright_white_on_yellow(text); end

  def bright_yellow(text); end

  def bright_yellow_on_black(text); end

  def bright_yellow_on_blue(text); end

  def bright_yellow_on_cyan(text); end

  def bright_yellow_on_green(text); end

  def bright_yellow_on_magenta(text); end

  def bright_yellow_on_purple(text); end

  def bright_yellow_on_red(text); end

  def bright_yellow_on_white(text); end

  def bright_yellow_on_yellow(text); end

  def cyan(text); end

  def cyan_on_black(text); end

  def cyan_on_blue(text); end

  def cyan_on_cyan(text); end

  def cyan_on_green(text); end

  def cyan_on_magenta(text); end

  def cyan_on_purple(text); end

  def cyan_on_red(text); end

  def cyan_on_white(text); end

  def cyan_on_yellow(text); end

  def default(text); end

  def green(text); end

  def green_on_black(text); end

  def green_on_blue(text); end

  def green_on_cyan(text); end

  def green_on_green(text); end

  def green_on_magenta(text); end

  def green_on_purple(text); end

  def green_on_red(text); end

  def green_on_white(text); end

  def green_on_yellow(text); end

  def indent(text, chars); end

  def magenta(text); end

  def magenta_on_black(text); end

  def magenta_on_blue(text); end

  def magenta_on_cyan(text); end

  def magenta_on_green(text); end

  def magenta_on_magenta(text); end

  def magenta_on_purple(text); end

  def magenta_on_red(text); end

  def magenta_on_white(text); end

  def magenta_on_yellow(text); end

  def no_color(); end

  def no_pager(); end

  def purple(text); end

  def purple_on_black(text); end

  def purple_on_blue(text); end

  def purple_on_cyan(text); end

  def purple_on_green(text); end

  def purple_on_magenta(text); end

  def purple_on_purple(text); end

  def purple_on_red(text); end

  def purple_on_white(text); end

  def purple_on_yellow(text); end

  def red(text); end

  def red_on_black(text); end

  def red_on_blue(text); end

  def red_on_cyan(text); end

  def red_on_green(text); end

  def red_on_magenta(text); end

  def red_on_purple(text); end

  def red_on_red(text); end

  def red_on_white(text); end

  def red_on_yellow(text); end

  def strip_color(text); end

  def white(text); end

  def white_on_black(text); end

  def white_on_blue(text); end

  def white_on_cyan(text); end

  def white_on_green(text); end

  def white_on_magenta(text); end

  def white_on_purple(text); end

  def white_on_red(text); end

  def white_on_white(text); end

  def white_on_yellow(text); end

  def with_line_numbers(text, offset, color=T.unsafe(nil)); end

  def yellow(text); end

  def yellow_on_black(text); end

  def yellow_on_blue(text); end

  def yellow_on_cyan(text); end

  def yellow_on_green(text); end

  def yellow_on_magenta(text); end

  def yellow_on_purple(text); end

  def yellow_on_red(text); end

  def yellow_on_white(text); end

  def yellow_on_yellow(text); end
  COLORS = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::Text
  extend ::Pry::Helpers::Text
end

module Pry::Helpers
  def self.tablify(things, line_length, pry_instance=T.unsafe(nil)); end

  def self.tablify_or_one_line(heading, things, pry_instance=T.unsafe(nil)); end

  def self.tablify_to_screen_width(things, options, pry_instance=T.unsafe(nil)); end
end

class Pry::History
  def <<(line); end

  def clear(); end

  def filter(history); end

  def history_line_count(); end

  def initialize(options=T.unsafe(nil)); end

  def load(); end

  def loader(); end

  def loader=(loader); end

  def original_lines(); end

  def push(line); end

  def saver(); end

  def saver=(saver); end

  def session_line_count(); end

  def to_a(); end
end

class Pry::History
  def self.default_file(); end
end

class Pry::Hooks
  def add_hook(event_name, hook_name, callable=T.unsafe(nil), &block); end

  def clear_event_hooks(event_name); end

  def delete_hook(event_name, hook_name); end

  def errors(); end

  def exec_hook(event_name, *args, &block); end

  def get_hook(event_name, hook_name); end

  def get_hooks(event_name); end

  def hook_count(event_name); end

  def hook_exists?(event_name, hook_name); end

  def hooks(); end

  def merge(other); end

  def merge!(other); end
end

class Pry::Hooks
  def self.default(); end
end

class Pry::Indent
  include ::Pry::Helpers::BaseHelpers
  def correct_indentation(prompt, code, overhang=T.unsafe(nil)); end

  def current_prefix(); end

  def end_of_statement?(last_token, last_kind); end

  def in_string?(); end

  def indent(input); end

  def indent_level(); end

  def indentation_delta(tokens); end

  def initialize(pry_instance=T.unsafe(nil)); end

  def module_nesting(); end

  def open_delimiters(); end

  def open_delimiters_line(); end

  def reset(); end

  def stack(); end

  def tokenize(string); end

  def track_delimiter(token); end

  def track_module_nesting(token, kind); end

  def track_module_nesting_end(token, kind=T.unsafe(nil)); end
  IGNORE_TOKENS = ::T.let(nil, ::T.untyped)
  MIDWAY_TOKENS = ::T.let(nil, ::T.untyped)
  OPEN_TOKENS = ::T.let(nil, ::T.untyped)
  OPTIONAL_DO_TOKENS = ::T.let(nil, ::T.untyped)
  SINGLELINE_TOKENS = ::T.let(nil, ::T.untyped)
  SPACES = ::T.let(nil, ::T.untyped)
  STATEMENT_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Pry::Indent::UnparseableNestingError
end

class Pry::Indent::UnparseableNestingError
end

class Pry::Indent
  def self.indent(str); end

  def self.nesting_at(str, line_number); end
end

class Pry::InputCompleter
  def build_path(input); end

  def call(str, options=T.unsafe(nil)); end

  def ignored_modules(); end

  def initialize(input, pry=T.unsafe(nil)); end

  def select_message(path, receiver, message, candidates); end
  ARRAY_REGEXP = ::T.let(nil, ::T.untyped)
  CONSTANT_OR_METHOD_REGEXP = ::T.let(nil, ::T.untyped)
  CONSTANT_REGEXP = ::T.let(nil, ::T.untyped)
  GLOBALVARIABLE_REGEXP = ::T.let(nil, ::T.untyped)
  HEX_REGEXP = ::T.let(nil, ::T.untyped)
  NUMERIC_REGEXP = ::T.let(nil, ::T.untyped)
  PROC_OR_HASH_REGEXP = ::T.let(nil, ::T.untyped)
  REGEX_REGEXP = ::T.let(nil, ::T.untyped)
  RESERVED_WORDS = ::T.let(nil, ::T.untyped)
  SYMBOL_METHOD_CALL_REGEXP = ::T.let(nil, ::T.untyped)
  SYMBOL_REGEXP = ::T.let(nil, ::T.untyped)
  TOPLEVEL_LOOKUP_REGEXP = ::T.let(nil, ::T.untyped)
  VARIABLE_REGEXP = ::T.let(nil, ::T.untyped)
  WORD_ESCAPE_STR = ::T.let(nil, ::T.untyped)
end

class Pry::InputCompleter
end

class Pry::InputLock
  def __with_ownership(); end

  def enter_interruptible_region(); end

  def interruptible_region(); end

  def leave_interruptible_region(); end

  def with_ownership(&block); end
end

class Pry::InputLock::Interrupt
end

class Pry::InputLock::Interrupt
end

class Pry::InputLock
  def self.for(input); end

  def self.global_lock(); end

  def self.global_lock=(global_lock); end

  def self.input_locks(); end

  def self.input_locks=(input_locks); end
end

class Pry::Inspector
  MAP = ::T.let(nil, ::T.untyped)
end

class Pry::Inspector
end

class Pry::LastException
  def bt_index(); end

  def bt_index=(bt_index); end

  def bt_source_location_for(index); end

  def file(); end

  def inc_bt_index(); end

  def initialize(exception); end

  def line(); end

  def method_missing(name, *args, &block); end

  def wrapped_exception(); end
end

class Pry::LastException
end

class Pry::Method
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::Helpers::DocumentationHelpers
  include ::Pry::CodeObject::Helpers
  def ==(other); end

  def alias?(); end

  def aliases(); end

  def bound_method?(); end

  def comment(); end

  def doc(); end

  def dynamically_defined?(); end

  def initialize(method, known_info=T.unsafe(nil)); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def method_missing(method_name, *args, &block); end

  def name(); end

  def name_with_owner(); end

  def original_name(); end

  def owner(*args, &block); end

  def parameters(*args, &block); end

  def pry_method?(); end

  def receiver(*args, &block); end

  def redefine(source); end

  def respond_to?(method_name, include_all=T.unsafe(nil)); end

  def signature(); end

  def singleton_method?(); end

  def source(); end

  def source?(); end

  def source_file(); end

  def source_line(); end

  def source_range(); end

  def source_type(); end

  def super(times=T.unsafe(nil)); end

  def unbound_method?(); end

  def undefined?(); end

  def visibility(); end

  def wrapped(); end

  def wrapped_owner(); end
end

class Pry::Method::Disowned
  def initialize(receiver, method_name); end

  def owner(); end

  def receiver(); end
end

class Pry::Method::Disowned
end

class Pry::Method::Patcher
  def initialize(method); end

  def method(); end

  def method=(method); end

  def patch_in_ram(source); end
end

class Pry::Method::Patcher
  def self.code_for(filename); end
end

class Pry::Method::WeirdMethodLocator
  def find_method(); end

  def initialize(method, target); end

  def lost_method?(); end

  def method(); end

  def method=(method); end

  def target(); end

  def target=(target); end
end

class Pry::Method::WeirdMethodLocator
  def self.normal_method?(method, binding); end

  def self.weird_method?(method, binding); end
end

class Pry::Method
  extend ::Pry::Helpers::BaseHelpers
  extend ::Pry::Forwardable
  extend ::Forwardable
  def self.all_from_class(klass, include_super=T.unsafe(nil)); end

  def self.all_from_obj(obj, include_super=T.unsafe(nil)); end

  def self.from_binding(binding); end

  def self.from_class(klass, name, target=T.unsafe(nil)); end

  def self.from_module(klass, name, target=T.unsafe(nil)); end

  def self.from_obj(obj, name, target=T.unsafe(nil)); end

  def self.from_str(name, target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.instance_method_definition?(name, definition_line); end

  def self.instance_resolution_order(klass); end

  def self.lookup_method_via_binding(obj, method_name, method_type, target=T.unsafe(nil)); end

  def self.method_definition?(name, definition_line); end

  def self.resolution_order(obj); end

  def self.singleton_class_of(obj); end

  def self.singleton_class_resolution_order(klass); end

  def self.singleton_method_definition?(name, definition_line); end
end

class Pry::MethodNotFound
end

class Pry::MethodNotFound
end

class Pry::NoCommandError
  def initialize(match, owner); end
end

class Pry::NoCommandError
end

class Pry::ObjectPath
  def initialize(path_string, current_stack); end

  def resolve(); end
  SPECIAL_TERMS = ::T.let(nil, ::T.untyped)
end

class Pry::ObjectPath
end

class Pry::ObsoleteError
end

class Pry::ObsoleteError
end

class Pry::Output
  def <<(*objs); end

  def decolorize_maybe(str); end

  def height(); end

  def initialize(pry_instance); end

  def method_missing(method_name, *args, &block); end

  def print(*objs); end

  def pry_instance(); end

  def puts(*objs); end

  def size(); end

  def tty?(); end

  def width(); end

  def write(*objs); end
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
end

class Pry::Output
end

class Pry::Pager
  def initialize(pry_instance); end

  def open(); end

  def page(text); end

  def pry_instance(); end
end

class Pry::Pager::NullPager
  def <<(str); end

  def close(); end

  def initialize(out); end

  def print(str); end

  def puts(str); end

  def write(str); end
end

class Pry::Pager::NullPager
end

class Pry::Pager::PageTracker
  def initialize(rows, cols); end

  def page?(); end

  def record(str); end

  def reset(); end
end

class Pry::Pager::PageTracker
end

class Pry::Pager::SimplePager
  def initialize(*arg); end
end

class Pry::Pager::SimplePager
end

class Pry::Pager::StopPaging
end

class Pry::Pager::StopPaging
end

class Pry::Pager::SystemPager
  def initialize(*arg); end
end

class Pry::Pager::SystemPager
  def self.available?(); end

  def self.default_pager(); end
end

class Pry::Pager
end

class Pry::PluginManager
  def load_plugins(); end

  def locate_plugins(); end

  def plugins(); end
  PRY_PLUGIN_PREFIX = ::T.let(nil, ::T.untyped)
end

class Pry::PluginManager::NoPlugin
  def initialize(name); end
end

class Pry::PluginManager::NoPlugin
end

class Pry::PluginManager::Plugin
  def activate!(); end

  def active(); end

  def active=(active); end

  def active?(); end

  def disable!(); end

  def enable!(); end

  def enabled(); end

  def enabled=(enabled); end

  def enabled?(); end

  def gem_name(); end

  def gem_name=(gem_name); end

  def initialize(name, gem_name, spec, enabled); end

  def load_cli_options(); end

  def name(); end

  def name=(name); end

  def spec(); end

  def spec=(spec); end

  def supported?(); end
end

class Pry::PluginManager::Plugin
end

class Pry::PluginManager
end

class Pry::Prompt
  def [](key); end

  def description(); end

  def incomplete_proc(); end

  def initialize(name, description, prompt_procs); end

  def name(); end

  def prompt_procs(); end

  def wait_proc(); end
end

class Pry::Prompt
  def self.[](name); end

  def self.add(name, description=T.unsafe(nil), separators=T.unsafe(nil)); end

  def self.all(); end
end

class Pry::REPL
  def initialize(pry, options=T.unsafe(nil)); end

  def input(*args, &block); end

  def output(*args, &block); end

  def pry(); end

  def pry=(pry); end

  def start(); end
end

class Pry::REPL
  extend ::Pry::Forwardable
  extend ::Forwardable
  def self.start(options); end
end

class Pry::REPLFileLoader
  def define_additional_commands(); end

  def initialize(file_name); end

  def interactive_mode(pry_instance); end

  def load(); end

  def non_interactive_mode(pry_instance, content); end
end

class Pry::REPLFileLoader
end

module Pry::RescuableException
end

module Pry::RescuableException
  def self.===(exception); end
end

class Pry::Result
  def command?(); end

  def initialize(is_command, retval=T.unsafe(nil)); end

  def retval(); end

  def void_command?(); end
end

class Pry::Result
end

class Pry::Ring
  def <<(value); end

  def [](index); end

  def clear(); end

  def count(); end

  def initialize(max_size); end

  def max_size(); end

  def size(); end

  def to_a(); end
end

class Pry::Ring
end

class Pry::Slop
  include ::Enumerable
  def [](key); end

  def add_callback(label, &block); end

  def banner(banner=T.unsafe(nil)); end

  def banner=(banner); end

  def command(command, options=T.unsafe(nil), &block); end

  def config(); end

  def description(desc=T.unsafe(nil)); end

  def description=(desc); end

  def each(&block); end

  def fetch_command(command); end

  def fetch_option(key); end

  def get(key); end

  def help(); end

  def initialize(config=T.unsafe(nil), &block); end

  def missing(); end

  def on(*objects, &block); end

  def opt(*objects, &block); end

  def option(*objects, &block); end

  def options(); end

  def parse(items=T.unsafe(nil), &block); end

  def parse!(items=T.unsafe(nil), &block); end

  def present?(*keys); end

  def run(callable=T.unsafe(nil), &block); end

  def separator(text); end

  def strict?(); end

  def to_h(include_commands=T.unsafe(nil)); end

  def to_hash(include_commands=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Commands
  include ::Enumerable
  def [](key); end

  def arguments(); end

  def banner(banner=T.unsafe(nil)); end

  def banner=(banner); end

  def commands(); end

  def config(); end

  def default(config=T.unsafe(nil), &block); end

  def each(&block); end

  def get(key); end

  def global(config=T.unsafe(nil), &block); end

  def help(); end

  def initialize(config=T.unsafe(nil), &block); end

  def on(command, config=T.unsafe(nil), &block); end

  def parse(items=T.unsafe(nil)); end

  def parse!(items=T.unsafe(nil)); end

  def present?(key); end

  def to_hash(); end
end

class Pry::Slop::Commands
end

class Pry::Slop::Error
end

class Pry::Slop::Error
end

class Pry::Slop::InvalidArgumentError
end

class Pry::Slop::InvalidArgumentError
end

class Pry::Slop::InvalidCommandError
end

class Pry::Slop::InvalidCommandError
end

class Pry::Slop::InvalidOptionError
end

class Pry::Slop::InvalidOptionError
end

class Pry::Slop::MissingArgumentError
end

class Pry::Slop::MissingArgumentError
end

class Pry::Slop::MissingOptionError
end

class Pry::Slop::MissingOptionError
end

class Pry::Slop::Option
  def accepts_optional_argument?(); end

  def argument?(); end

  def argument_in_value(); end

  def argument_in_value=(argument_in_value); end

  def as?(); end

  def autocreated?(); end

  def call(*objects); end

  def callback?(); end

  def config(); end

  def count(); end

  def count=(count); end

  def default?(); end

  def delimiter?(); end

  def description(); end

  def expects_argument?(); end

  def help(); end

  def initialize(slop, short, long, description, config=T.unsafe(nil), &block); end

  def key(); end

  def limit?(); end

  def long(); end

  def match?(); end

  def optional?(); end

  def optional_argument?(); end

  def required?(); end

  def short(); end

  def tail?(); end

  def types(); end

  def value(); end

  def value=(new_value); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Option
end

class Pry::Slop
  def self.optspec(string, config=T.unsafe(nil)); end

  def self.parse(items=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def self.parse!(items=T.unsafe(nil), config=T.unsafe(nil), &block); end
end

class Pry::SyntaxHighlighter
end

class Pry::SyntaxHighlighter
  def self.highlight(code, language=T.unsafe(nil)); end

  def self.keyword_token_color(); end

  def self.overwrite_coderay_comment_token!(); end

  def self.tokenize(code, language=T.unsafe(nil)); end
end

module Pry::SystemCommandHandler
end

module Pry::SystemCommandHandler
  def self.default(output, command, _pry_instance); end
end

module Pry::TooSafeException
end

module Pry::TooSafeException
  def self.===(exception); end
end

module Pry::UserError
end

module Pry::UserError
end

module Pry::Warning
end

module Pry::Warning
  def self.warn(message); end
end

class Pry::WrappedModule
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::CodeObject::Helpers
  def candidate(rank); end

  def candidates(); end

  def class?(); end

  def constants(inherit=T.unsafe(nil)); end

  def doc(); end

  def file(); end

  def initialize(mod); end

  def line(); end

  def method_missing(method_name, *args, &block); end

  def method_prefix(); end

  def module?(); end

  def nonblank_name(); end

  def number_of_candidates(); end

  def singleton_class?(); end

  def singleton_instance(); end

  def source(); end

  def source_file(); end

  def source_line(); end

  def source_location(); end

  def super(times=T.unsafe(nil)); end

  def wrapped(); end

  def yard_doc(); end

  def yard_docs?(); end

  def yard_file(); end

  def yard_line(); end
end

class Pry::WrappedModule::Candidate
  include ::Pry::Helpers::DocumentationHelpers
  include ::Pry::CodeObject::Helpers
  def class?(*args, &block); end

  def doc(); end

  def file(); end

  def initialize(wrapper, rank); end

  def line(); end

  def module?(*args, &block); end

  def nonblank_name(*args, &block); end

  def number_of_candidates(*args, &block); end

  def source(); end

  def source_file(); end

  def source_line(); end

  def source_location(); end

  def wrapped(*args, &block); end
end

class Pry::WrappedModule::Candidate
  extend ::Pry::Forwardable
  extend ::Forwardable
end

class Pry::WrappedModule
  def self.from_str(mod_name, target=T.unsafe(nil)); end
end

class Pry
  extend ::Pry::Forwardable
  extend ::Forwardable
  def self.Code(obj); end

  def self.Method(obj); end

  def self.WrappedModule(obj); end

  def self.auto_resize!(); end

  def self.binding_for(target); end

  def self.cli(); end

  def self.cli=(cli); end

  def self.color(*args, &block); end

  def self.color=(*args, &block); end

  def self.commands(*args, &block); end

  def self.commands=(*args, &block); end

  def self.config(); end

  def self.config=(config); end

  def self.configure(); end

  def self.critical_section(); end

  def self.current(); end

  def self.current_line(); end

  def self.current_line=(current_line); end

  def self.custom_completions(); end

  def self.custom_completions=(custom_completions); end

  def self.editor(*args, &block); end

  def self.editor=(*args, &block); end

  def self.eval_path(); end

  def self.eval_path=(eval_path); end

  def self.exception_handler(*args, &block); end

  def self.exception_handler=(*args, &block); end

  def self.extra_sticky_locals(*args, &block); end

  def self.extra_sticky_locals=(*args, &block); end

  def self.final_session_setup(); end

  def self.history(*args, &block); end

  def self.history=(*args, &block); end

  def self.hooks(*args, &block); end

  def self.hooks=(*args, &block); end

  def self.in_critical_section?(); end

  def self.init(); end

  def self.initial_session?(); end

  def self.initial_session_setup(); end

  def self.input(*args, &block); end

  def self.input=(*args, &block); end

  def self.last_internal_error(); end

  def self.last_internal_error=(last_internal_error); end

  def self.line_buffer(); end

  def self.line_buffer=(line_buffer); end

  def self.load_file_at_toplevel(file); end

  def self.load_file_through_repl(file_name); end

  def self.load_history(); end

  def self.load_plugins(*args, &block); end

  def self.load_rc_files(); end

  def self.load_requires(); end

  def self.load_traps(); end

  def self.load_win32console(); end

  def self.locate_plugins(*args, &block); end

  def self.main(); end

  def self.memory_size(*args, &block); end

  def self.memory_size=(*args, &block); end

  def self.output(*args, &block); end

  def self.output=(*args, &block); end

  def self.pager(*args, &block); end

  def self.pager=(*args, &block); end

  def self.plugins(*args, &block); end

  def self.print(*args, &block); end

  def self.print=(*args, &block); end

  def self.prompt(*args, &block); end

  def self.prompt=(*args, &block); end

  def self.quiet(); end

  def self.quiet=(quiet); end

  def self.rc_files_to_load(); end

  def self.real_path_to(file); end

  def self.reset_defaults(); end

  def self.run_command(command_string, options=T.unsafe(nil)); end

  def self.start(target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.start_with_pry_byebug(target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.start_without_pry_byebug(target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.toplevel_binding(); end

  def self.toplevel_binding=(toplevel_binding); end

  def self.view_clip(obj, options=T.unsafe(nil)); end
end

module PryByebug
  def current_remote_server(); end

  def current_remote_server=(current_remote_server); end
end

class PryByebug::BacktraceCommand
  include ::PryByebug::Helpers::Navigation
end

class PryByebug::BacktraceCommand
end

class PryByebug::BreakCommand
  include ::PryByebug::Helpers::Breakpoints
  include ::PryByebug::Helpers::Location
  include ::PryByebug::Helpers::Multiline
end

class PryByebug::BreakCommand
end

class PryByebug::ContinueCommand
  include ::PryByebug::Helpers::Navigation
  include ::PryByebug::Helpers::Breakpoints
  include ::PryByebug::Helpers::Location
end

class PryByebug::ContinueCommand
end

class PryByebug::DownCommand
  include ::PryByebug::Helpers::Navigation
end

class PryByebug::DownCommand
end

class PryByebug::ExitAllCommand
end

class PryByebug::ExitAllCommand
end

class PryByebug::FinishCommand
  include ::PryByebug::Helpers::Navigation
end

class PryByebug::FinishCommand
end

class PryByebug::FrameCommand
  include ::PryByebug::Helpers::Navigation
end

class PryByebug::FrameCommand
end

module PryByebug::Helpers
end

module PryByebug::Helpers::Breakpoints
  def bold_puts(msg); end

  def breakpoints(); end

  def max_width(); end

  def print_breakpoints_header(); end

  def print_full_breakpoint(breakpoint); end

  def print_short_breakpoint(breakpoint); end
end

module PryByebug::Helpers::Breakpoints
end

module PryByebug::Helpers::Location
end

module PryByebug::Helpers::Location
  def self.current_file(source=T.unsafe(nil)); end
end

module PryByebug::Helpers::Multiline
  def check_multiline_context(); end
end

module PryByebug::Helpers::Multiline
end

module PryByebug::Helpers::Navigation
  def breakout_navigation(action, options=T.unsafe(nil)); end
end

module PryByebug::Helpers::Navigation
end

module PryByebug::Helpers
end

class PryByebug::NextCommand
  include ::PryByebug::Helpers::Navigation
  include ::PryByebug::Helpers::Multiline
end

class PryByebug::NextCommand
end

class PryByebug::StepCommand
  include ::PryByebug::Helpers::Navigation
end

class PryByebug::StepCommand
end

class PryByebug::UpCommand
  include ::PryByebug::Helpers::Navigation
end

class PryByebug::UpCommand
end

module PryByebug
  def self.check_file_context(target, msg=T.unsafe(nil)); end

  def self.file_context?(target); end
end

module Psych
  VERSION = ::T.let(nil, ::T.untyped)
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.remove_type(type_tag); end
end

class RDoc::Alias
  def initialize(text, old_name, new_name, comment, singleton=T.unsafe(nil)); end
end

class RDoc::Attr
  def initialize(text, name, rw, comment, singleton=T.unsafe(nil)); end
end

class RDoc::ClassModule
  def initialize(name, superclass=T.unsafe(nil)); end
end

class RDoc::CodeObject
  def initialize_visibility(); end
end

class RDoc::Comment
  def initialize(text=T.unsafe(nil), location=T.unsafe(nil), language=T.unsafe(nil)); end

  def line(); end

  def line=(line); end
end

class RDoc::Constant
  def initialize(name, value, comment); end
  MARSHAL_VERSION = ::T.let(nil, ::T.untyped)
end

class RDoc::Context
  def add_module_by_normal_module(mod); end

  def initialize_methods_etc(); end
end

class RDoc::Context::Section
  def initialize(parent, title, comment); end
end

class RDoc::CrossReference
  def initialize(context); end
end

class RDoc::ERBIO
  def initialize(str, safe_level=T.unsafe(nil), trim_mode=T.unsafe(nil), eoutvar=T.unsafe(nil)); end
end

module RDoc::Encoding
  HEADER_REGEXP = ::T.let(nil, ::T.untyped)
end

module RDoc::Encoding
  def self.detect_encoding(string); end

  def self.remove_magic_comment(string); end
end

class RDoc::Generator::Darkfish
  def initialize(store, options); end
end

class RDoc::Generator::JsonIndex
  def initialize(parent_generator, options); end
end

class RDoc::Generator::Markdown::ClassMember
  def self.[](*arg); end

  def self.members(); end
end

class RDoc::Generator::Markdown::DocClass
  def self.[](*arg); end

  def self.members(); end
end

class RDoc::Generator::POT
  def initialize(store, options); end
end

class RDoc::Generator::POT::MessageExtractor
  def initialize(store); end
end

class RDoc::Generator::POT::POEntry
  def initialize(msgid, options=T.unsafe(nil)); end
end

class RDoc::Generator::RI
  def initialize(store, options); end
end

class RDoc::I18n::Locale
  def initialize(name); end
end

class RDoc::I18n::Text
  def initialize(raw); end
end

class RDoc::Markdown
  def initialize(extensions=T.unsafe(nil), debug=T.unsafe(nil)); end
end

class RDoc::Markdown::Literals
  def initialize(str, debug=T.unsafe(nil)); end
end

class RDoc::Markdown::Literals::MemoEntry
  def initialize(ans, pos); end
end

class RDoc::Markdown::Literals::RuleInfo
  def initialize(name, rendered); end
end

class RDoc::Markdown::MemoEntry
  def initialize(ans, pos); end
end

class RDoc::Markdown::RuleInfo
  def initialize(name, rendered); end
end

class RDoc::Markup
  def add_regexp_handling(pattern, name); end

  def initialize(attribute_manager=T.unsafe(nil)); end
end

class RDoc::Markup::AttrSpan
  def initialize(length); end
end

class RDoc::Markup::AttributeManager
  def add_regexp_handling(pattern, name); end

  def convert_regexp_handlings(str, attrs); end

  def regexp_handlings(); end
end

class RDoc::Markup::Attributes
  def regexp_handling(); end
end

class RDoc::Markup::Document
  def initialize(*parts); end
end

class RDoc::Markup::Formatter
  def add_regexp_handling_RDOCLINK(); end

  def add_regexp_handling_TIDYLINK(); end

  def convert_regexp_handling(target); end

  def initialize(options, markup=T.unsafe(nil)); end
end

class RDoc::Markup::Include
  def initialize(file, include_path); end
end

class RDoc::Markup::IndentedParagraph
  def initialize(indent, *parts); end
end

class RDoc::Markup::List
  def initialize(type=T.unsafe(nil), *items); end
end

class RDoc::Markup::ListItem
  def initialize(label=T.unsafe(nil), *parts); end
end

class RDoc::Markup::Parser::MyStringScanner
  def [](i); end

  def eos?(); end

  def initialize(input); end

  def matched(); end

  def newline!(); end

  def pos(); end

  def scan(re); end

  def unscan(s); end
end

class RDoc::Markup::Parser::MyStringScanner
end

class RDoc::Markup::PreProcess
  def initialize(input_file_name, include_path); end
end

class RDoc::Markup::Raw
  def initialize(*parts); end
end

class RDoc::Markup::RegexpHandling
  def ==(o); end

  def initialize(type, text); end

  def text(); end

  def text=(text); end

  def type(); end
end

class RDoc::Markup::RegexpHandling
end

class RDoc::Markup::ToHtml
  def handle_regexp_HARD_BREAK(target); end

  def handle_regexp_HYPERLINK(target); end

  def handle_regexp_RDOCLINK(target); end

  def handle_regexp_TIDYLINK(target); end
end

class RDoc::Markup::ToHtmlCrossref
  def handle_regexp_CROSSREF(target); end

  def initialize(options, from_path, context, markup=T.unsafe(nil)); end
end

class RDoc::Markup::ToHtmlSnippet
  def handle_regexp_CROSSREF(target); end

  def initialize(options, characters=T.unsafe(nil), paragraphs=T.unsafe(nil), markup=T.unsafe(nil)); end
end

class RDoc::Markup::ToJoinedParagraph
  def initialize(); end
end

class RDoc::Markup::ToLabel
  def handle_regexp_CROSSREF(target); end

  def handle_regexp_HARD_BREAK(*node); end

  def handle_regexp_TIDYLINK(target); end

  def initialize(markup=T.unsafe(nil)); end
end

class RDoc::Markup::ToMarkdown
  def handle_regexp_RDOCLINK(target); end

  def handle_regexp_TIDYLINK(target); end
end

class RDoc::Markup::ToRdoc
  def handle_regexp_HARD_BREAK(target); end

  def handle_regexp_SUPPRESSED_CROSSREF(target); end

  def initialize(markup=T.unsafe(nil)); end
end

class RDoc::Markup::ToTableOfContents
  def initialize(); end
end

class RDoc::Markup::ToTtOnly
  def initialize(markup=T.unsafe(nil)); end
end

class RDoc::MethodAttr
  def initialize(text, name); end
end

class RDoc::Mixin
  def initialize(name, comment); end
end

class RDoc::Parser
  def initialize(top_level, file_name, content, options, stats); end
end

class RDoc::Parser::C
  def do_classes_and_modules(); end
end

class RDoc::Parser::RipperStateLex
  def get_squashed_tk(); end

  def initialize(code); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  RIPPER_HAS_LEX_STATE = ::T.let(nil, ::T.untyped)
end

class RDoc::Parser::RipperStateLex::InnerStateLex
  def initialize(code); end

  def on_default(event, tok, data); end
end

class RDoc::Parser::RipperStateLex::InnerStateLex
end

class RDoc::Parser::RipperStateLex::Token
  def char_no(); end

  def char_no=(_); end

  def kind(); end

  def kind=(_); end

  def line_no(); end

  def line_no=(_); end

  def state(); end

  def state=(_); end

  def text(); end

  def text=(_); end
end

class RDoc::Parser::RipperStateLex::Token
  def self.[](*arg); end

  def self.members(); end
end

class RDoc::Parser::RipperStateLex
  def self.end?(token); end

  def self.parse(code); end
end

class RDoc::Parser::Ruby
  def get_included_module_with_optional_parens(); end

  def retrieve_comment_body(tk); end
end

module RDoc::Parser::RubyTools
  def skip_tkspace_without_nl(); end
end

class RDoc::RD::BlockParser
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
end

class RDoc::RD::Inline
  def initialize(rdoc, reference); end
end

class RDoc::RD::InlineParser
  def initialize(block_parser); end
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
end

class RDoc::RI::Driver
  def initialize(initial_options=T.unsafe(nil)); end
end

class RDoc::RI::Driver::NotFoundError
  def initialize(klass, suggestions=T.unsafe(nil)); end
end

RDoc::RI::Store = RDoc::Store

class RDoc::Require
  def initialize(name, comment); end
end

class RDoc::Servlet
  def initialize(server, stores, cache, mount_path=T.unsafe(nil), extra_doc_dirs=T.unsafe(nil)); end
end

class RDoc::Stats
  def initialize(store, num_files, verbosity=T.unsafe(nil)); end
end

class RDoc::Stats::Quiet
  def initialize(num_files); end
end

class RDoc::Store
  def initialize(path=T.unsafe(nil), type=T.unsafe(nil)); end

  def unmatched_constant_alias(); end

  def update_parser_of_file(absolute_name, parser); end
end

class RDoc::Store::MissingFileError
  def initialize(store, file, name); end
end

class RDoc::Task
  def before_running_rdoc(&block); end

  def check_names(names); end

  def clobber_task_description(); end

  def defaults(); end

  def define(); end

  def external(); end

  def external=(external); end

  def generator(); end

  def generator=(generator); end

  def initialize(name=T.unsafe(nil)); end

  def inline_source(); end

  def inline_source=(value); end

  def main(); end

  def main=(main); end

  def markup(); end

  def markup=(markup); end

  def name(); end

  def name=(name); end

  def option_list(); end

  def options(); end

  def options=(options); end

  def rdoc_dir(); end

  def rdoc_dir=(rdoc_dir); end

  def rdoc_files(); end

  def rdoc_files=(rdoc_files); end

  def rdoc_task_description(); end

  def rerdoc_task_description(); end

  def template(); end

  def template=(template); end

  def title(); end

  def title=(title); end
end

class RDoc::Task
end

module RDoc::Text
  def language(); end

  def language=(language); end
end

class RDoc::TopLevel
  def initialize(absolute_name, relative_name=T.unsafe(nil)); end
end

module Racc
  Copyright = ::T.let(nil, ::T.untyped)
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

class Rails::Forms::Create
  def db(); end

  def db=(db); end

  def name(); end

  def name=(name); end

  def organization_id(); end

  def organization_id=(organization_id); end

  def shop_domain(); end

  def shop_domain=(shop_domain); end

  def type(); end

  def type=(type); end
end

class Rails::Gem
  include ::SmartProperties
end

class Rails::Gem
  extend ::SmartProperties::ClassMethods
end

class Rails::Ruby
  include ::SmartProperties
end

class Rails::Ruby
  extend ::SmartProperties::ClassMethods
end

module Rake
  EARLY = ::T.let(nil, ::T.untyped)
  EMPTY_TASK_ARGS = ::T.let(nil, ::T.untyped)
  LATE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rake::Application
  include ::Rake::TaskManager
  include ::Rake::TraceOutput
  def add_import(fn); end

  def add_loader(ext, loader); end

  def collect_command_line_tasks(args); end

  def default_task_name(); end

  def deprecate(old_usage, new_usage, call_site); end

  def display_cause_details(ex); end

  def display_error_message(ex); end

  def display_exception_backtrace(ex); end

  def display_exception_details(ex); end

  def display_exception_details_seen(); end

  def display_exception_message_details(ex); end

  def display_prerequisites(); end

  def display_tasks_and_comments(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def exit_because_of_exception(ex); end

  def find_rakefile_location(); end

  def handle_options(argv); end

  def has_cause?(ex); end

  def have_rakefile(); end

  def init(app_name=T.unsafe(nil), argv=T.unsafe(nil)); end

  def invoke_task(task_string); end

  def load_imports(); end

  def load_rakefile(); end

  def name(); end

  def options(); end

  def original_dir(); end

  def parse_task_string(string); end

  def print_rakefile_directory(location); end

  def rake_require(file_name, paths=T.unsafe(nil), loaded=T.unsafe(nil)); end

  def rakefile(); end

  def rakefile_location(backtrace=T.unsafe(nil)); end

  def raw_load_rakefile(); end

  def run(argv=T.unsafe(nil)); end

  def run_with_threads(); end

  def set_default_options(); end

  def standard_exception_handling(); end

  def standard_rake_options(); end

  def system_dir(); end

  def terminal_columns(); end

  def terminal_columns=(terminal_columns); end

  def terminal_width(); end

  def thread_pool(); end

  def top_level(); end

  def top_level_tasks(); end

  def trace(*strings); end

  def truncate(string, width); end

  def truncate_output?(); end

  def tty_output=(tty_output); end

  def tty_output?(); end

  def unix?(); end

  def windows?(); end
  DEFAULT_RAKEFILES = ::T.let(nil, ::T.untyped)
end

class Rake::Application
end

module Rake::Backtrace
  SUPPRESSED_PATHS = ::T.let(nil, ::T.untyped)
  SUPPRESSED_PATHS_RE = ::T.let(nil, ::T.untyped)
  SUPPRESS_PATTERN = ::T.let(nil, ::T.untyped)
  SYS_KEYS = ::T.let(nil, ::T.untyped)
  SYS_PATHS = ::T.let(nil, ::T.untyped)
end

module Rake::Backtrace
  def self.collapse(backtrace); end
end

module Rake::Cloneable
end

module Rake::Cloneable
end

class Rake::CommandLineOptionError
end

class Rake::CommandLineOptionError
end

class Rake::CpuCounter
  def count(); end

  def count_with_default(default=T.unsafe(nil)); end
end

class Rake::CpuCounter
  def self.count(); end
end

module Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Rake::DSL
end

class Rake::DefaultLoader
  def load(fn); end
end

class Rake::DefaultLoader
end

class Rake::EarlyTime
  include ::Comparable
  include ::Singleton
end

class Rake::EarlyTime
  extend ::Singleton::SingletonClassMethods
end

class Rake::FileCreationTask
end

class Rake::FileCreationTask
end

class Rake::FileList
  include ::Rake::Cloneable
  def &(*args, &block); end

  def *(other); end

  def +(*args, &block); end

  def -(*args, &block); end

  def <<(obj); end

  def ==(array); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def add(*filenames); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def clear_exclude(); end

  def collect(*args, &block); end

  def collect!(*args, &block); end

  def collect_concat(*args, &block); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def deconstruct(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def difference(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_index(*args, &block); end

  def each_slice(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def egrep(pattern, *options); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def exclude(*patterns, &block); end

  def excluded_from_list?(fn); end

  def existing(); end

  def existing!(); end

  def ext(newext=T.unsafe(nil)); end

  def fetch(*args, &block); end

  def fill(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def filter_map(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def gsub(pat, rep); end

  def gsub!(pat, rep); end

  def import(array); end

  def include(*filenames); end

  def include?(*args, &block); end

  def index(*args, &block); end

  def initialize(*patterns); end

  def inject(*args, &block); end

  def insert(*args, &block); end

  def inspect(*args, &block); end

  def intersection(*args, &block); end

  def is_a?(klass); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def kind_of?(klass); end

  def last(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def map(*args, &block); end

  def map!(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def pack(*args, &block); end

  def partition(&block); end

  def pathmap(spec=T.unsafe(nil), &block); end

  def permutation(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def resolve(); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shelljoin(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by(*args, &block); end

  def sort_by!(*args, &block); end

  def sub(pat, rep); end

  def sub!(pat, rep); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def tally(*args, &block); end

  def to_a(); end

  def to_ary(); end

  def to_h(*args, &block); end

  def to_set(*args, &block); end

  def transpose(*args, &block); end

  def union(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def values_at(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PROCS = ::T.let(nil, ::T.untyped)
  DELEGATING_METHODS = ::T.let(nil, ::T.untyped)
  GLOB_PATTERN = ::T.let(nil, ::T.untyped)
  MUST_DEFINE = ::T.let(nil, ::T.untyped)
  MUST_NOT_DEFINE = ::T.let(nil, ::T.untyped)
  SPECIAL_RETURN = ::T.let(nil, ::T.untyped)
end

class Rake::FileList
  def self.[](*args); end

  def self.glob(pattern, *args); end
end

class Rake::FileTask
end

class Rake::FileTask
end

module Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def cd(*args, **options, &block); end

  def chdir(*args, **options, &block); end

  def chmod(*args, **options, &block); end

  def chmod_R(*args, **options, &block); end

  def chown(*args, **options, &block); end

  def chown_R(*args, **options, &block); end

  def copy(*args, **options, &block); end

  def cp(*args, **options, &block); end

  def cp_lr(*args, **options, &block); end

  def cp_r(*args, **options, &block); end

  def install(*args, **options, &block); end

  def link(*args, **options, &block); end

  def ln(*args, **options, &block); end

  def ln_s(*args, **options, &block); end

  def ln_sf(*args, **options, &block); end

  def makedirs(*args, **options, &block); end

  def mkdir(*args, **options, &block); end

  def mkdir_p(*args, **options, &block); end

  def mkpath(*args, **options, &block); end

  def move(*args, **options, &block); end

  def mv(*args, **options, &block); end

  def nowrite(value=T.unsafe(nil)); end

  def rake_check_options(options, *optdecl); end

  def rake_output_message(message); end

  def remove(*args, **options, &block); end

  def rm(*args, **options, &block); end

  def rm_f(*args, **options, &block); end

  def rm_r(*args, **options, &block); end

  def rm_rf(*args, **options, &block); end

  def rmdir(*args, **options, &block); end

  def rmtree(*args, **options, &block); end

  def safe_unlink(*args, **options, &block); end

  def symlink(*args, **options, &block); end

  def touch(*args, **options, &block); end

  def verbose(value=T.unsafe(nil)); end

  def when_writing(msg=T.unsafe(nil)); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  def self.nowrite_flag(); end

  def self.nowrite_flag=(nowrite_flag); end

  def self.verbose_flag(); end

  def self.verbose_flag=(verbose_flag); end
end

class Rake::InvocationChain
  def append(invocation); end

  def member?(invocation); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::InvocationChain::EmptyInvocationChain
  def append(invocation); end

  def member?(obj); end
end

class Rake::InvocationChain::EmptyInvocationChain
end

class Rake::InvocationChain
  def self.append(invocation, chain); end
end

module Rake::InvocationExceptionMixin
  def chain(); end

  def chain=(value); end
end

module Rake::InvocationExceptionMixin
end

class Rake::LateTime
  include ::Comparable
  include ::Singleton
end

class Rake::LateTime
  extend ::Singleton::SingletonClassMethods
end

class Rake::LinkedList
  include ::Enumerable
  def ==(other); end

  def conj(item); end

  def each(&blk); end

  def empty?(); end

  def head(); end

  def initialize(head, tail=T.unsafe(nil)); end

  def tail(); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::LinkedList::EmptyLinkedList
  def initialize(); end
end

class Rake::LinkedList::EmptyLinkedList
end

class Rake::LinkedList
  def self.cons(head, tail); end

  def self.empty(); end

  def self.make(*args); end
end

class Rake::MultiTask
end

class Rake::MultiTask
end

class Rake::NameSpace
  def [](name); end

  def initialize(task_manager, scope_list); end

  def scope(); end

  def tasks(); end
end

class Rake::NameSpace
end

module Rake::PrivateReader
end

module Rake::PrivateReader::ClassMethods
  def private_reader(*names); end
end

module Rake::PrivateReader::ClassMethods
end

module Rake::PrivateReader
  def self.included(base); end
end

class Rake::Promise
  def initialize(args, &block); end

  def recorder(); end

  def recorder=(recorder); end

  def value(); end

  def work(); end
  NOT_SET = ::T.let(nil, ::T.untyped)
end

class Rake::Promise
end

class Rake::PseudoStatus
  def >>(n); end

  def exited?(); end

  def exitstatus(); end

  def initialize(code=T.unsafe(nil)); end

  def stopped?(); end

  def to_i(); end
end

class Rake::PseudoStatus
end

Rake::RDocTask = RDoc::Task

class Rake::RuleRecursionOverflowError
  def add_target(target); end

  def initialize(*args); end
end

class Rake::RuleRecursionOverflowError
end

class Rake::Scope
  def path(); end

  def path_with_task_name(task_name); end

  def trim(n); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::Scope::EmptyScope
  def path(); end

  def path_with_task_name(task_name); end
end

class Rake::Scope::EmptyScope
end

class Rake::Scope
end

class Rake::Task
  def actions(); end

  def add_description(description); end

  def all_prerequisite_tasks(); end

  def already_invoked(); end

  def application(); end

  def application=(application); end

  def arg_description(); end

  def arg_names(); end

  def clear(); end

  def clear_actions(); end

  def clear_args(); end

  def clear_comments(); end

  def clear_prerequisites(); end

  def collect_prerequisites(seen); end

  def comment(); end

  def comment=(comment); end

  def enhance(deps=T.unsafe(nil), &block); end

  def execute(args=T.unsafe(nil)); end

  def full_comment(); end

  def initialize(task_name, app); end

  def investigation(); end

  def invoke(*args); end

  def invoke_prerequisites(task_args, invocation_chain); end

  def invoke_prerequisites_concurrently(task_args, invocation_chain); end

  def invoke_with_call_chain(task_args, invocation_chain); end

  def locations(); end

  def name(); end

  def name_with_args(); end

  def needed?(); end

  def order_only_prerequisites(); end

  def prereqs(); end

  def prerequisite_tasks(); end

  def prerequisites(); end

  def reenable(); end

  def scope(); end

  def set_arg_names(args); end

  def source(); end

  def sources(); end

  def sources=(sources); end

  def timestamp(); end

  def |(deps); end
end

class Rake::Task
  def self.[](task_name); end

  def self.clear(); end

  def self.create_rule(*args, &block); end

  def self.define_task(*args, &block); end

  def self.format_deps(deps); end

  def self.scope_name(scope, task_name); end

  def self.task_defined?(task_name); end

  def self.tasks(); end
end

class Rake::TaskArgumentError
end

class Rake::TaskArgumentError
end

class Rake::TaskArguments
  include ::Enumerable
  def [](index); end

  def each(&block); end

  def extras(); end

  def fetch(*args, &block); end

  def has_key?(key); end

  def initialize(names, values, parent=T.unsafe(nil)); end

  def key?(key); end

  def lookup(name); end

  def method_missing(sym, *args); end

  def names(); end

  def new_scope(names); end

  def to_a(); end

  def to_hash(); end

  def values_at(*keys); end

  def with_defaults(defaults); end
end

class Rake::TaskArguments
end

class Rake::TaskLib
  include ::Rake::Cloneable
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

class Rake::TaskLib
end

module Rake::TaskManager
  def [](task_name, scopes=T.unsafe(nil)); end

  def clear(); end

  def create_rule(*args, &block); end

  def current_scope(); end

  def define_task(task_class, *args, &block); end

  def enhance_with_matching_rule(task_name, level=T.unsafe(nil)); end

  def generate_did_you_mean_suggestions(task_name); end

  def generate_message_for_undefined_task(task_name); end

  def in_namespace(name); end

  def initialize(); end

  def intern(task_class, task_name); end

  def last_description(); end

  def last_description=(last_description); end

  def lookup(task_name, initial_scope=T.unsafe(nil)); end

  def resolve_args(args); end

  def synthesize_file_task(task_name); end

  def tasks(); end

  def tasks_in_scope(scope); end
end

module Rake::TaskManager
  def self.record_task_metadata(); end

  def self.record_task_metadata=(record_task_metadata); end
end

class Rake::ThreadHistoryDisplay
  include ::Rake::PrivateReader
  def initialize(stats); end

  def show(); end
end

class Rake::ThreadHistoryDisplay
  extend ::Rake::PrivateReader::ClassMethods
end

class Rake::ThreadPool
  def future(*args, &block); end

  def gather_history(); end

  def history(); end

  def initialize(thread_count); end

  def join(); end

  def statistics(); end
end

class Rake::ThreadPool
end

module Rake::TraceOutput
  def trace_on(out, *strings); end
end

module Rake::TraceOutput
end

module Rake::Version
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  NUMBERS = ::T.let(nil, ::T.untyped)
  OTHER = ::T.let(nil, ::T.untyped)
end

module Rake::Version
end

module Rake::Win32
end

class Rake::Win32::Win32HomeError
end

class Rake::Win32::Win32HomeError
end

module Rake::Win32
  def self.normalize(path); end

  def self.win32_system_dir(); end

  def self.windows?(); end
end

module Rake
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  def self.add_rakelib(*files); end

  def self.application(); end

  def self.application=(app); end

  def self.each_dir_parent(dir); end

  def self.from_pathname(path); end

  def self.load_rakefile(path); end

  def self.original_dir(); end

  def self.suggested_thread_count(); end

  def self.with_application(block_application=T.unsafe(nil)); end
end

RakeFileUtils = Rake::FileUtilsExt

class Random
  def self.bytes(arg); end
end

class Range
  def %(arg); end

  def entries(); end

  def to_a(); end

  def to_liquid(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

module Readline
  def self.completion_quote_character(); end
end

module Reline
  def eof?(*args, &block); end
  FILENAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  HISTORY = ::T.let(nil, ::T.untyped)
  USERNAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Reline::ANSI
  RAW_KEYSTROKE_CONFIG = ::T.let(nil, ::T.untyped)
end

class Reline::ANSI
  def self.clear_screen(); end

  def self.cursor_pos(); end

  def self.deprep(otio); end

  def self.encoding(); end

  def self.erase_after_cursor(); end

  def self.get_screen_size(); end

  def self.getc(); end

  def self.input=(val); end

  def self.move_cursor_column(x); end

  def self.move_cursor_down(x); end

  def self.move_cursor_up(x); end

  def self.output=(val); end

  def self.prep(); end

  def self.retrieve_keybuffer(); end

  def self.scroll_down(x); end

  def self.set_screen_size(rows, columns); end

  def self.set_winch_handler(&handler); end

  def self.ungetc(c); end

  def self.win?(); end
end

class Reline::Config
  def add_default_key_binding(keystroke, target); end

  def bind_key(key, func_name); end

  def bind_tty_special_chars(); end

  def bind_tty_special_chars=(bind_tty_special_chars); end

  def bind_variable(name, value); end

  def blink_matching_paren(); end

  def blink_matching_paren=(blink_matching_paren); end

  def byte_oriented(); end

  def byte_oriented=(byte_oriented); end

  def completion_ignore_case(); end

  def completion_ignore_case=(completion_ignore_case); end

  def convert_meta(); end

  def convert_meta=(convert_meta); end

  def disable_completion(); end

  def disable_completion=(disable_completion); end

  def editing_mode(); end

  def editing_mode=(val); end

  def editing_mode_is?(*val); end

  def emacs_mode_string(); end

  def emacs_mode_string=(emacs_mode_string); end

  def enable_keypad(); end

  def enable_keypad=(enable_keypad); end

  def expand_tilde(); end

  def expand_tilde=(expand_tilde); end

  def handle_directive(directive, file, no); end

  def history_preserve_point(); end

  def history_preserve_point=(history_preserve_point); end

  def history_size(); end

  def history_size=(history_size); end

  def horizontal_scroll_mode(); end

  def horizontal_scroll_mode=(horizontal_scroll_mode); end

  def input_meta(); end

  def input_meta=(input_meta); end

  def inputrc_path(); end

  def key_bindings(); end

  def key_notation_to_code(notation); end

  def keymap(); end

  def keyseq_timeout(); end

  def keyseq_timeout=(keyseq_timeout); end

  def mark_directories(); end

  def mark_directories=(mark_directories); end

  def mark_modified_lines(); end

  def mark_modified_lines=(mark_modified_lines); end

  def mark_symlinked_directories(); end

  def mark_symlinked_directories=(mark_symlinked_directories); end

  def match_hidden_files(); end

  def match_hidden_files=(match_hidden_files); end

  def meta_flag(); end

  def meta_flag=(meta_flag); end

  def output_meta(); end

  def output_meta=(output_meta); end

  def page_completions(); end

  def page_completions=(page_completions); end

  def parse_keyseq(str); end

  def prefer_visible_bell(); end

  def prefer_visible_bell=(prefer_visible_bell); end

  def print_completions_horizontally(); end

  def print_completions_horizontally=(print_completions_horizontally); end

  def read(file=T.unsafe(nil)); end

  def read_lines(lines, file=T.unsafe(nil)); end

  def reset(); end

  def reset_default_key_bindings(); end

  def retrieve_string(str); end

  def show_all_if_ambiguous(); end

  def show_all_if_ambiguous=(show_all_if_ambiguous); end

  def show_all_if_unmodified(); end

  def show_all_if_unmodified=(show_all_if_unmodified); end

  def show_mode_in_prompt(); end

  def show_mode_in_prompt=(show_mode_in_prompt); end

  def test_mode(); end

  def vi_cmd_mode_icon(); end

  def vi_cmd_mode_icon=(vi_cmd_mode_icon); end

  def vi_ins_mode_icon(); end

  def vi_ins_mode_icon=(vi_ins_mode_icon); end

  def visible_stats(); end

  def visible_stats=(visible_stats); end
  KEYSEQ_PATTERN = ::T.let(nil, ::T.untyped)
  VARIABLE_NAMES = ::T.let(nil, ::T.untyped)
  VARIABLE_NAME_SYMBOLS = ::T.let(nil, ::T.untyped)
end

class Reline::Config::InvalidInputrc
  def file(); end

  def file=(file); end

  def lineno(); end

  def lineno=(lineno); end
end

class Reline::Config::InvalidInputrc
end

class Reline::Config
end

class Reline::Core
  def ambiguous_width(); end

  def ambiguous_width=(ambiguous_width); end

  def auto_indent_proc(); end

  def auto_indent_proc=(p); end

  def basic_quote_characters(); end

  def basic_quote_characters=(v); end

  def basic_word_break_characters(); end

  def basic_word_break_characters=(v); end

  def completer_quote_characters(); end

  def completer_quote_characters=(v); end

  def completer_word_break_characters(); end

  def completer_word_break_characters=(v); end

  def completion_append_character(); end

  def completion_append_character=(val); end

  def completion_case_fold(); end

  def completion_case_fold=(v); end

  def completion_proc(); end

  def completion_proc=(p); end

  def completion_quote_character(); end

  def config(); end

  def config=(config); end

  def dig_perfect_match_proc(); end

  def dig_perfect_match_proc=(p); end

  def emacs_editing_mode(); end

  def emacs_editing_mode?(); end

  def encoding(); end

  def filename_quote_characters(); end

  def filename_quote_characters=(v); end

  def get_screen_size(); end

  def input=(val); end

  def key_stroke(); end

  def key_stroke=(key_stroke); end

  def last_incremental_search(); end

  def last_incremental_search=(last_incremental_search); end

  def line_editor(); end

  def line_editor=(line_editor); end

  def output(); end

  def output=(val); end

  def output_modifier_proc(); end

  def output_modifier_proc=(p); end

  def pre_input_hook(); end

  def pre_input_hook=(p); end

  def prompt_proc(); end

  def prompt_proc=(p); end

  def readline(prompt=T.unsafe(nil), add_hist=T.unsafe(nil)); end

  def readmultiline(prompt=T.unsafe(nil), add_hist=T.unsafe(nil), &confirm_multiline_termination); end

  def special_prefixes(); end

  def special_prefixes=(v); end

  def vi_editing_mode(); end

  def vi_editing_mode?(); end
  ATTR_READER_NAMES = ::T.let(nil, ::T.untyped)
end

class Reline::Core
end

class Reline::CursorPos
  def x(); end

  def x=(_); end

  def y(); end

  def y=(_); end
end

class Reline::CursorPos
  def self.[](*arg); end

  def self.members(); end
end

class Reline::GeneralIO
  RAW_KEYSTROKE_CONFIG = ::T.let(nil, ::T.untyped)
end

class Reline::GeneralIO
  def self.clear_screen(); end

  def self.cursor_pos(); end

  def self.deprep(otio); end

  def self.encoding(); end

  def self.erase_after_cursor(); end

  def self.get_screen_size(); end

  def self.getc(); end

  def self.input=(val); end

  def self.move_cursor_column(val); end

  def self.move_cursor_down(val); end

  def self.move_cursor_up(val); end

  def self.prep(); end

  def self.scroll_down(val); end

  def self.set_screen_size(rows, columns); end

  def self.set_winch_handler(&handler); end

  def self.ungetc(c); end

  def self.win?(); end
end

class Reline::History
  def <<(val); end

  def [](index); end

  def []=(index, val); end

  def concat(*val); end

  def delete_at(index); end

  def initialize(config); end

  def push(*val); end
end

class Reline::History
end

Reline::IOGate = Reline::ANSI

Reline::Key = Struct::Key

module Reline::KeyActor
end

class Reline::KeyActor::Base
  def get_method(key); end
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::Base
end

class Reline::KeyActor::Emacs
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::Emacs
end

class Reline::KeyActor::ViCommand
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::ViCommand
end

class Reline::KeyActor::ViInsert
  MAPPING = ::T.let(nil, ::T.untyped)
end

class Reline::KeyActor::ViInsert
end

module Reline::KeyActor
end

class Reline::KeyStroke
  def expand(input); end

  def initialize(config); end

  def match_status(input); end
end

class Reline::KeyStroke
end

class Reline::KillRing
  def append(string, before_p=T.unsafe(nil)); end

  def initialize(max=T.unsafe(nil)); end

  def process(); end

  def yank(); end

  def yank_pop(); end
end

class Reline::KillRing::RingBuffer
  def <<(point); end

  def empty?(); end

  def head(); end

  def initialize(max=T.unsafe(nil)); end

  def size(); end
end

class Reline::KillRing::RingBuffer
end

class Reline::KillRing::RingPoint
  def ==(other); end

  def backward(); end

  def backward=(_); end

  def forward(); end

  def forward=(_); end

  def initialize(str); end

  def str(); end

  def str=(_); end
end

class Reline::KillRing::RingPoint
  def self.[](*arg); end

  def self.members(); end
end

module Reline::KillRing::State
  CONTINUED = ::T.let(nil, ::T.untyped)
  FRESH = ::T.let(nil, ::T.untyped)
  PROCESSED = ::T.let(nil, ::T.untyped)
  YANK = ::T.let(nil, ::T.untyped)
end

module Reline::KillRing::State
end

class Reline::KillRing
end

class Reline::LineEditor
  def auto_indent_proc(); end

  def auto_indent_proc=(auto_indent_proc); end

  def byte_pointer(); end

  def byte_pointer=(val); end

  def call_completion_proc(); end

  def completion_append_character(); end

  def completion_append_character=(completion_append_character); end

  def completion_proc(); end

  def completion_proc=(completion_proc); end

  def confirm_multiline_termination(); end

  def confirm_multiline_termination_proc(); end

  def confirm_multiline_termination_proc=(confirm_multiline_termination_proc); end

  def delete_text(start=T.unsafe(nil), length=T.unsafe(nil)); end

  def dig_perfect_match_proc(); end

  def dig_perfect_match_proc=(dig_perfect_match_proc); end

  def editing_mode(); end

  def eof?(); end

  def finalize(); end

  def finish(); end

  def finished?(); end

  def initialize(config, encoding); end

  def input_key(key); end

  def insert_text(text); end

  def line(); end

  def multiline_off(); end

  def multiline_on(); end

  def output=(output); end

  def output_modifier_proc(); end

  def output_modifier_proc=(output_modifier_proc); end

  def pre_input_hook(); end

  def pre_input_hook=(pre_input_hook); end

  def prompt_proc(); end

  def prompt_proc=(prompt_proc); end

  def rerender(); end

  def reset(prompt=T.unsafe(nil), encoding:); end

  def reset_line(); end

  def reset_variables(prompt=T.unsafe(nil), encoding:); end

  def retrieve_completion_block(set_completion_quote_character=T.unsafe(nil)); end

  def whole_buffer(); end

  def whole_lines(index: T.unsafe(nil), line: T.unsafe(nil)); end
  VI_MOTIONS = ::T.let(nil, ::T.untyped)
end

Reline::LineEditor::CompletionJourneyData = Struct::CompletionJourneyData

module Reline::LineEditor::CompletionState
  COMPLETION = ::T.let(nil, ::T.untyped)
  JOURNEY = ::T.let(nil, ::T.untyped)
  MENU = ::T.let(nil, ::T.untyped)
  MENU_WITH_PERFECT_MATCH = ::T.let(nil, ::T.untyped)
  NORMAL = ::T.let(nil, ::T.untyped)
  PERFECT_MATCH = ::T.let(nil, ::T.untyped)
end

module Reline::LineEditor::CompletionState
end

Reline::LineEditor::MenuInfo = Struct::MenuInfo

class Reline::LineEditor
end

class Reline::Unicode
  CSI_REGEXP = ::T.let(nil, ::T.untyped)
  EscapedChars = ::T.let(nil, ::T.untyped)
  EscapedPairs = ::T.let(nil, ::T.untyped)
  NON_PRINTING_END = ::T.let(nil, ::T.untyped)
  NON_PRINTING_START = ::T.let(nil, ::T.untyped)
  OSC_REGEXP = ::T.let(nil, ::T.untyped)
  WIDTH_SCANNER = ::T.let(nil, ::T.untyped)
end

class Reline::Unicode::EastAsianWidth
  TYPE_A = ::T.let(nil, ::T.untyped)
  TYPE_F = ::T.let(nil, ::T.untyped)
  TYPE_H = ::T.let(nil, ::T.untyped)
  TYPE_N = ::T.let(nil, ::T.untyped)
  TYPE_NA = ::T.let(nil, ::T.untyped)
  TYPE_W = ::T.let(nil, ::T.untyped)
end

class Reline::Unicode::EastAsianWidth
end

class Reline::Unicode
  def self.calculate_width(str, allow_escape_code=T.unsafe(nil)); end

  def self.ed_transpose_words(line, byte_pointer); end

  def self.em_backward_word(line, byte_pointer); end

  def self.em_big_backward_word(line, byte_pointer); end

  def self.em_forward_word(line, byte_pointer); end

  def self.em_forward_word_with_capitalization(line, byte_pointer); end

  def self.escape_for_print(str); end

  def self.get_mbchar_byte_size_by_first_char(c); end

  def self.get_mbchar_width(mbchar); end

  def self.get_next_mbchar_size(line, byte_pointer); end

  def self.get_prev_mbchar_size(line, byte_pointer); end

  def self.split_by_width(str, max_width, encoding=T.unsafe(nil)); end

  def self.vi_backward_word(line, byte_pointer); end

  def self.vi_big_backward_word(line, byte_pointer); end

  def self.vi_big_forward_end_word(line, byte_pointer); end

  def self.vi_big_forward_word(line, byte_pointer); end

  def self.vi_first_print(line); end

  def self.vi_forward_end_word(line, byte_pointer); end

  def self.vi_forward_word(line, byte_pointer); end
end

module Reline
  extend ::Forwardable
  extend ::SingleForwardable
  def self.ambiguous_width(*args, &block); end

  def self.auto_indent_proc(*args, &block); end

  def self.auto_indent_proc=(*args, &block); end

  def self.basic_quote_characters(*args, &block); end

  def self.basic_quote_characters=(*args, &block); end

  def self.basic_word_break_characters(*args, &block); end

  def self.basic_word_break_characters=(*args, &block); end

  def self.completer_quote_characters(*args, &block); end

  def self.completer_quote_characters=(*args, &block); end

  def self.completer_word_break_characters(*args, &block); end

  def self.completer_word_break_characters=(*args, &block); end

  def self.completion_append_character(*args, &block); end

  def self.completion_append_character=(*args, &block); end

  def self.completion_case_fold(*args, &block); end

  def self.completion_case_fold=(*args, &block); end

  def self.completion_proc(*args, &block); end

  def self.completion_proc=(*args, &block); end

  def self.completion_quote_character(*args, &block); end

  def self.core(); end

  def self.delete_text(*args, &block); end

  def self.dig_perfect_match_proc(*args, &block); end

  def self.dig_perfect_match_proc=(*args, &block); end

  def self.emacs_editing_mode(*args, &block); end

  def self.emacs_editing_mode?(*args, &block); end

  def self.encoding_system_needs(); end

  def self.eof?(*args, &block); end

  def self.filename_quote_characters(*args, &block); end

  def self.filename_quote_characters=(*args, &block); end

  def self.get_screen_size(*args, &block); end

  def self.input=(*args, &block); end

  def self.insert_text(*args, &block); end

  def self.last_incremental_search(*args, &block); end

  def self.last_incremental_search=(*args, &block); end

  def self.line_buffer(*args, &block); end

  def self.line_editor(); end

  def self.output=(*args, &block); end

  def self.output_modifier_proc(*args, &block); end

  def self.output_modifier_proc=(*args, &block); end

  def self.point(*args, &block); end

  def self.point=(*args, &block); end

  def self.pre_input_hook(*args, &block); end

  def self.pre_input_hook=(*args, &block); end

  def self.prompt_proc(*args, &block); end

  def self.prompt_proc=(*args, &block); end

  def self.readline(*args, &block); end

  def self.readmultiline(*args, &block); end

  def self.redisplay(*args, &block); end

  def self.special_prefixes(*args, &block); end

  def self.special_prefixes=(*args, &block); end

  def self.vi_editing_mode(*args, &block); end

  def self.vi_editing_mode?(*args, &block); end
end

class Ripper
  def column(); end

  def debug_output(); end

  def debug_output=(debug_output); end

  def encoding(); end

  def end_seen?(); end

  def error?(); end

  def filename(); end

  def initialize(*arg); end

  def lineno(); end

  def parse(); end

  def state(); end

  def token(); end

  def yydebug(); end

  def yydebug=(yydebug); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_ARG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_BEG_ANY = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_CMDARG = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_ENDARG = ::T.let(nil, ::T.untyped)
  EXPR_ENDFN = ::T.let(nil, ::T.untyped)
  EXPR_END_ANY = ::T.let(nil, ::T.untyped)
  EXPR_FITEM = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_LABEL = ::T.let(nil, ::T.untyped)
  EXPR_LABELED = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  EXPR_NONE = ::T.let(nil, ::T.untyped)
  EXPR_VALUE = ::T.let(nil, ::T.untyped)
  PARSER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  SCANNER_EVENT_TABLE = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Ripper::Filter
  def initialize(src, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end
end

class Ripper::Lexer
  def errors(); end

  def lex(); end

  def scan(); end

  def tokenize(); end
end

class Ripper::Lexer::Elem
  def event(); end

  def event=(_); end

  def initialize(pos, event, tok, state, message=T.unsafe(nil)); end

  def message(); end

  def message=(_); end

  def pos(); end

  def pos=(_); end

  def state(); end

  def state=(_); end

  def tok(); end

  def tok=(_); end
end

class Ripper::Lexer::Elem
  def self.[](*arg); end

  def self.members(); end
end

class Ripper::Lexer::State
  def &(i); end

  def ==(i); end

  def allbits?(i); end

  def anybits?(i); end

  def initialize(i); end

  def nobits?(i); end

  def to_i(); end

  def to_int(); end

  def to_int=(_); end

  def to_s=(_); end

  def |(i); end
end

class Ripper::Lexer::State
  def self.[](*arg); end

  def self.members(); end
end

class Ripper::Lexer
end

class Ripper::SexpBuilder
  def on_BEGIN(*args); end

  def on_CHAR(tok); end

  def on_END(*args); end

  def on___end__(tok); end

  def on_alias(*args); end

  def on_alias_error(*args); end

  def on_aref(*args); end

  def on_aref_field(*args); end

  def on_arg_ambiguous(*args); end

  def on_arg_paren(*args); end

  def on_args_add(*args); end

  def on_args_add_block(*args); end

  def on_args_add_star(*args); end

  def on_args_forward(*args); end

  def on_args_new(*args); end

  def on_array(*args); end

  def on_aryptn(*args); end

  def on_assign(*args); end

  def on_assign_error(*args); end

  def on_assoc_new(*args); end

  def on_assoc_splat(*args); end

  def on_assoclist_from_args(*args); end

  def on_backref(tok); end

  def on_backtick(tok); end

  def on_bare_assoc_hash(*args); end

  def on_begin(*args); end

  def on_binary(*args); end

  def on_block_var(*args); end

  def on_blockarg(*args); end

  def on_bodystmt(*args); end

  def on_brace_block(*args); end

  def on_break(*args); end

  def on_call(*args); end

  def on_case(*args); end

  def on_class(*args); end

  def on_class_name_error(*args); end

  def on_comma(tok); end

  def on_command(*args); end

  def on_command_call(*args); end

  def on_comment(tok); end

  def on_const(tok); end

  def on_const_path_field(*args); end

  def on_const_path_ref(*args); end

  def on_const_ref(*args); end

  def on_cvar(tok); end

  def on_def(*args); end

  def on_defined(*args); end

  def on_defs(*args); end

  def on_do_block(*args); end

  def on_dot2(*args); end

  def on_dot3(*args); end

  def on_dyna_symbol(*args); end

  def on_else(*args); end

  def on_elsif(*args); end

  def on_embdoc(tok); end

  def on_embdoc_beg(tok); end

  def on_embdoc_end(tok); end

  def on_embexpr_beg(tok); end

  def on_embexpr_end(tok); end

  def on_embvar(tok); end

  def on_ensure(*args); end

  def on_excessed_comma(*args); end

  def on_fcall(*args); end

  def on_field(*args); end

  def on_float(tok); end

  def on_for(*args); end

  def on_gvar(tok); end

  def on_hash(*args); end

  def on_heredoc_beg(tok); end

  def on_heredoc_end(tok); end

  def on_hshptn(*args); end

  def on_ident(tok); end

  def on_if(*args); end

  def on_if_mod(*args); end

  def on_ifop(*args); end

  def on_ignored_nl(tok); end

  def on_ignored_sp(tok); end

  def on_imaginary(tok); end

  def on_in(*args); end

  def on_int(tok); end

  def on_ivar(tok); end

  def on_kw(tok); end

  def on_kwrest_param(*args); end

  def on_label(tok); end

  def on_label_end(tok); end

  def on_lambda(*args); end

  def on_lbrace(tok); end

  def on_lbracket(tok); end

  def on_lparen(tok); end

  def on_magic_comment(*args); end

  def on_massign(*args); end

  def on_method_add_arg(*args); end

  def on_method_add_block(*args); end

  def on_mlhs_add(*args); end

  def on_mlhs_add_post(*args); end

  def on_mlhs_add_star(*args); end

  def on_mlhs_new(*args); end

  def on_mlhs_paren(*args); end

  def on_module(*args); end

  def on_mrhs_add(*args); end

  def on_mrhs_add_star(*args); end

  def on_mrhs_new(*args); end

  def on_mrhs_new_from_args(*args); end

  def on_next(*args); end

  def on_nl(tok); end

  def on_nokw_param(*args); end

  def on_op(tok); end

  def on_opassign(*args); end

  def on_operator_ambiguous(*args); end

  def on_param_error(*args); end

  def on_params(*args); end

  def on_paren(*args); end

  def on_parse_error(*args); end

  def on_period(tok); end

  def on_program(*args); end

  def on_qsymbols_add(*args); end

  def on_qsymbols_beg(tok); end

  def on_qsymbols_new(*args); end

  def on_qwords_add(*args); end

  def on_qwords_beg(tok); end

  def on_qwords_new(*args); end

  def on_rational(tok); end

  def on_rbrace(tok); end

  def on_rbracket(tok); end

  def on_redo(*args); end

  def on_regexp_add(*args); end

  def on_regexp_beg(tok); end

  def on_regexp_end(tok); end

  def on_regexp_literal(*args); end

  def on_regexp_new(*args); end

  def on_rescue(*args); end

  def on_rescue_mod(*args); end

  def on_rest_param(*args); end

  def on_retry(*args); end

  def on_return(*args); end

  def on_return0(*args); end

  def on_rparen(tok); end

  def on_sclass(*args); end

  def on_semicolon(tok); end

  def on_sp(tok); end

  def on_stmts_add(*args); end

  def on_stmts_new(*args); end

  def on_string_add(*args); end

  def on_string_concat(*args); end

  def on_string_content(*args); end

  def on_string_dvar(*args); end

  def on_string_embexpr(*args); end

  def on_string_literal(*args); end

  def on_super(*args); end

  def on_symbeg(tok); end

  def on_symbol(*args); end

  def on_symbol_literal(*args); end

  def on_symbols_add(*args); end

  def on_symbols_beg(tok); end

  def on_symbols_new(*args); end

  def on_tlambda(tok); end

  def on_tlambeg(tok); end

  def on_top_const_field(*args); end

  def on_top_const_ref(*args); end

  def on_tstring_beg(tok); end

  def on_tstring_content(tok); end

  def on_tstring_end(tok); end

  def on_unary(*args); end

  def on_undef(*args); end

  def on_unless(*args); end

  def on_unless_mod(*args); end

  def on_until(*args); end

  def on_until_mod(*args); end

  def on_var_alias(*args); end

  def on_var_field(*args); end

  def on_var_ref(*args); end

  def on_vcall(*args); end

  def on_void_stmt(*args); end

  def on_when(*args); end

  def on_while(*args); end

  def on_while_mod(*args); end

  def on_word_add(*args); end

  def on_word_new(*args); end

  def on_words_add(*args); end

  def on_words_beg(tok); end

  def on_words_new(*args); end

  def on_words_sep(tok); end

  def on_xstring_add(*args); end

  def on_xstring_literal(*args); end

  def on_xstring_new(*args); end

  def on_yield(*args); end

  def on_yield0(*args); end

  def on_zsuper(*args); end
end

class Ripper::TokenPattern
  def initialize(pattern); end

  def match(str); end

  def match_list(tokens); end
  MAP = ::T.let(nil, ::T.untyped)
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::CompileError
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::Error
end

class Ripper::TokenPattern::MatchData
  def initialize(tokens, match); end

  def string(n=T.unsafe(nil)); end
end

class Ripper::TokenPattern::MatchData
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern::MatchError
end

class Ripper::TokenPattern
  def self.compile(*arg); end
end

class Ripper
  def self.dedent_string(arg, arg1); end

  def self.lex_state_name(arg); end

  def self.token_match(src, pattern); end
end

class RubyLex
  def check_code_block(code); end

  def check_corresponding_token_depth(); end

  def check_newline_depth_difference(); end

  def check_state(code); end

  def check_string_literal(); end

  def each_top_level_statement(); end

  def initialize_input(); end

  def lex(); end

  def process_continue(); end

  def process_literal_type(); end

  def process_nesting_level(); end

  def prompt(); end

  def ripper_lex_without_warning(code); end

  def set_auto_indent(context); end

  def set_input(io, p=T.unsafe(nil), &block); end

  def set_prompt(p=T.unsafe(nil), &block); end
end

class RubyLex::TerminateLineInput
  def initialize(); end
end

class RubyLex::TerminateLineInput
end

class RubyLex
  def self.compile_with_errors_suppressed(code); end
end

class RubyVM::AbstractSyntaxTree::Node
  def pretty_print_children(q, names=T.unsafe(nil)); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*arg); end

  def self.resume(); end
end

ScanError = StringScanner::Error

class Script::Forms::Create
  def extension_point(); end

  def extension_point=(extension_point); end

  def language(); end

  def language=(language); end

  def name(); end

  def name=(name); end
end

class Script::Layers::Domain::ScriptProject
  include ::SmartProperties
end

class Script::Layers::Domain::ScriptProject
  extend ::SmartProperties::ClassMethods
end

class Script::Layers::Infrastructure::CommandRunner
  include ::SmartProperties
end

class Script::Layers::Infrastructure::CommandRunner
  extend ::SmartProperties::ClassMethods
end

class Script::Layers::Infrastructure::Languages::ProjectCreator
  include ::SmartProperties
end

class Script::Layers::Infrastructure::Languages::ProjectCreator
  extend ::SmartProperties::ClassMethods
end

class Script::Layers::Infrastructure::PushPackageRepository
  include ::SmartProperties
end

class Script::Layers::Infrastructure::PushPackageRepository
  extend ::SmartProperties::ClassMethods
end

class Script::Layers::Infrastructure::ScriptProjectRepository
  include ::SmartProperties
end

class Script::Layers::Infrastructure::ScriptProjectRepository::ScriptConfigRepository
  include ::SmartProperties
end

class Script::Layers::Infrastructure::ScriptProjectRepository::ScriptConfigRepository
  extend ::SmartProperties::ClassMethods
end

class Script::Layers::Infrastructure::ScriptProjectRepository
  extend ::SmartProperties::ClassMethods
end

module Semantic
  GEM_VERSION = ::T.let(nil, ::T.untyped)
end

class Semantic::Version
  include ::Comparable
  def build(); end

  def build=(b); end

  def compare_pre(prea, preb); end

  def eql?(other_version); end

  def identifiers(pre); end

  def increment!(term); end

  def initialize(version_str); end

  def major(); end

  def major!(); end

  def major=(major); end

  def minor(); end

  def minor!(); end

  def minor=(minor); end

  def patch(); end

  def patch!(); end

  def patch=(patch); end

  def pre(); end

  def pre=(pre); end

  def satisfied_by?(versions); end

  def satisfies?(other_version); end

  def to_a(); end

  def to_array(); end

  def to_h(); end

  def to_hash(); end

  def to_string(); end
  SemVerRegexp = ::T.let(nil, ::T.untyped)
end

class Semantic::Version
end

module Semantic
end

class Set
  def ==(other); end

  def ===(o); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

class ShopifyCLI::API
  include ::SmartProperties
end

class ShopifyCLI::API
  extend ::SmartProperties::ClassMethods
end

class ShopifyCLI::Command
end

class ShopifyCLI::Commands::App::Serve
  def host(); end

  def port(); end
end

class ShopifyCLI::Commands::App::Serve
  extend ::ShopifyCLI::CommandOptions::CommandServeOptions::ClassMethods
end

class ShopifyCLI::Core::Executor
end

class ShopifyCLI::Core::HelpResolver
end

class ShopifyCLI::DB
  def self.clear(*args, &block); end

  def self.del(*args, &block); end

  def self.exists?(*args, &block); end

  def self.get(*args, &block); end

  def self.keys(*args, &block); end

  def self.set(*args, &block); end
end

class ShopifyCLI::IdentityAuth
  include ::SmartProperties
end

class ShopifyCLI::IdentityAuth::LocalRequest
  def self.[](*arg); end

  def self.members(); end
end

class ShopifyCLI::IdentityAuth
  extend ::SmartProperties::ClassMethods
end

class ShopifyCLI::JsDeps
  include ::SmartProperties
end

class ShopifyCLI::JsDeps
  extend ::SmartProperties::ClassMethods
end

class ShopifyCLI::JsSystem
  include ::SmartProperties
end

class ShopifyCLI::JsSystem
  extend ::SmartProperties::ClassMethods
end

class ShopifyCLI::LazyDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class ShopifyCLI::Options
  include ::SmartProperties
end

class ShopifyCLI::Options
  extend ::SmartProperties::ClassMethods
end

class ShopifyCLI::PHPDeps
  include ::SmartProperties
end

class ShopifyCLI::PHPDeps
  extend ::SmartProperties::ClassMethods
end

class ShopifyCLI::Project
  include ::SmartProperties
end

class ShopifyCLI::Project
  extend ::SmartProperties::ClassMethods
end

class ShopifyCLI::ResolveConstant
  include ::SmartProperties
  include ::ShopifyCLI::MethodObject::AutoCreateResultObject
end

class ShopifyCLI::ResolveConstant
  extend ::SmartProperties::ClassMethods
end

class ShopifyCLI::ResolveConstantTest
end

class ShopifyCLI::Resources::EnvFile
  include ::SmartProperties
end

class ShopifyCLI::Resources::EnvFile
  extend ::SmartProperties::ClassMethods
end

class ShopifyCLI::TransformDataStructure
  include ::SmartProperties
  include ::ShopifyCLI::MethodObject::AutoCreateResultObject
end

class ShopifyCLI::TransformDataStructure
  extend ::SmartProperties::ClassMethods
end

class ShopifyCLI::Tunnel
  def self.auth(*args, &block); end

  def self.authenticated?(*args, &block); end

  def self.running_on?(*args, &block); end

  def self.start(*args, &block); end

  def self.stats(*args, &block); end

  def self.stop(*args, &block); end

  def self.urls(*args, &block); end
end

module ShopifyCLI
  extend ::CLI::Kit::Autocall
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

module SmartProperties
  def [](name); end

  def []=(name, value); end

  def initialize(*args, &block); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class SmartProperties::AssignmentError
  def initialize(sender, property, message); end

  def property(); end

  def property=(property); end

  def sender(); end

  def sender=(sender); end
end

class SmartProperties::AssignmentError
end

module SmartProperties::ClassMethods
  def properties(); end

  def property(name, options=T.unsafe(nil)); end

  def property!(name, options=T.unsafe(nil)); end
end

module SmartProperties::ClassMethods
end

class SmartProperties::ConfigurationError
end

class SmartProperties::ConfigurationError
end

class SmartProperties::ConstructorArgumentForwardingError
  def initialize(positional_arguments, keyword_arguments); end
end

class SmartProperties::ConstructorArgumentForwardingError
end

class SmartProperties::Error
end

class SmartProperties::Error
end

class SmartProperties::InitializationError
  def initialize(sender, properties); end

  def properties(); end

  def properties=(properties); end

  def sender(); end

  def sender=(sender); end

  def to_hash(); end
end

class SmartProperties::InitializationError
end

class SmartProperties::InvalidValueError
  def initialize(sender, property, value); end

  def to_hash(); end

  def value(); end

  def value=(value); end
end

class SmartProperties::InvalidValueError
end

class SmartProperties::MissingValueError
  def initialize(sender, property); end

  def to_hash(); end
end

class SmartProperties::MissingValueError
end

class SmartProperties::Property
  def accepter(); end

  def accepts?(value, scope); end

  def convert(scope, value); end

  def converter(); end

  def default(scope); end

  def define(klass); end

  def get(scope); end

  def initialize(name, attrs=T.unsafe(nil)); end

  def instance_variable_name(); end

  def missing?(scope); end

  def name(); end

  def optional?(scope); end

  def prepare(scope, value); end

  def present?(scope); end

  def reader(); end

  def required?(scope); end

  def set(scope, value); end

  def set_default(scope); end

  def to_h(); end

  def writable(); end

  def writable?(); end
  ALLOWED_DEFAULT_CLASSES = ::T.let(nil, ::T.untyped)
  MODULE_REFERENCE = ::T.let(nil, ::T.untyped)
end

class SmartProperties::Property
  def self.define(scope, name, options=T.unsafe(nil)); end
end

class SmartProperties::PropertyCollection
  include ::Enumerable
  def [](name); end

  def []=(name, value); end

  def children(); end

  def children=(children); end

  def collection(); end

  def collection=(collection); end

  def collection_with_parent_collection(); end

  def collection_with_parent_collection=(collection_with_parent_collection); end

  def each(&block); end

  def key?(name); end

  def keys(); end

  def notify_children(); end

  def parent(); end

  def refresh(parent_collection); end

  def register(child); end

  def to_hash(); end

  def values(); end
end

class SmartProperties::PropertyCollection
  def self.for(scope); end
end

module SmartProperties::Validations
end

class SmartProperties::Validations::Ancestor
  include ::SmartProperties
  def to_proc(); end

  def validate(klass); end
end

class SmartProperties::Validations::Ancestor
  extend ::SmartProperties::ClassMethods
  def self.must_be(*arg); end
end

module SmartProperties::Validations
end

module SmartProperties
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_DONTFRAG = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_DONTFRAG = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  include ::Colorize::InstanceMethods
  def black(); end

  def blink(); end

  def blue(); end

  def bold(); end

  def cyan(); end

  def ext(newext=T.unsafe(nil)); end

  def green(); end

  def hide(); end

  def italic(); end

  def light_black(); end

  def light_blue(); end

  def light_cyan(); end

  def light_green(); end

  def light_magenta(); end

  def light_red(); end

  def light_white(); end

  def light_yellow(); end

  def magenta(); end

  def on_black(); end

  def on_blue(); end

  def on_cyan(); end

  def on_green(); end

  def on_light_black(); end

  def on_light_blue(); end

  def on_light_cyan(); end

  def on_light_green(); end

  def on_light_magenta(); end

  def on_light_red(); end

  def on_light_white(); end

  def on_light_yellow(); end

  def on_magenta(); end

  def on_red(); end

  def on_white(); end

  def on_yellow(); end

  def pathmap(spec=T.unsafe(nil), &block); end

  def pathmap_explode(); end

  def pathmap_partial(n); end

  def pathmap_replace(patterns, &block); end

  def red(); end

  def shellescape(); end

  def shellsplit(); end

  def swap(); end

  def to_liquid(); end

  def underline(); end

  def white(); end

  def yellow(); end
end

class String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
  extend ::Colorize::ClassMethods
end

class StringIO
  def set_encoding_by_bom(); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class StringScanner
  def bol?(); end

  def fixed_anchor?(); end

  def initialize(*arg); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Struct
  def deconstruct(); end

  def deconstruct_keys(arg); end

  def filter(*arg); end
end

class Struct::CompletionJourneyData
  def list(); end

  def list=(_); end

  def pointer(); end

  def pointer=(_); end

  def postposing(); end

  def postposing=(_); end

  def preposing(); end

  def preposing=(_); end
end

class Struct::CompletionJourneyData
  def self.[](*arg); end

  def self.members(); end
end

Struct::Group = Etc::Group

class Struct::HTMLElementDescription
  def attrs_depr(); end

  def attrs_depr=(_); end

  def attrs_opt(); end

  def attrs_opt=(_); end

  def attrs_req(); end

  def attrs_req=(_); end

  def defaultsubelt(); end

  def defaultsubelt=(_); end

  def depr(); end

  def depr=(_); end

  def desc(); end

  def desc=(_); end

  def dtd(); end

  def dtd=(_); end

  def empty(); end

  def empty=(_); end

  def endTag(); end

  def endTag=(_); end

  def isinline(); end

  def isinline=(_); end

  def name(); end

  def name=(_); end

  def saveEndTag(); end

  def saveEndTag=(_); end

  def startTag(); end

  def startTag=(_); end

  def subelts(); end

  def subelts=(_); end
end

class Struct::HTMLElementDescription
  def self.[](*arg); end

  def self.members(); end
end

class Struct::Key
  def char(); end

  def char=(_); end

  def combined_char(); end

  def combined_char=(_); end

  def with_meta(); end

  def with_meta=(_); end
end

class Struct::Key
  def self.[](*arg); end

  def self.members(); end
end

class Struct::MenuInfo
  def list(); end

  def list=(_); end

  def target(); end

  def target=(_); end
end

class Struct::MenuInfo
  def self.[](*arg); end

  def self.members(); end
end

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class Symbol
  def to_liquid(); end
end

class Tempfile
  def _close(); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

class Theme::Forms::ConfirmStore
  def force(); end

  def force=(force); end

  def title(); end

  def title=(title); end
end

class Theme::Forms::Select
  def exclude_roles(); end

  def exclude_roles=(exclude_roles); end

  def include_foreign_developments(); end

  def include_foreign_developments=(include_foreign_developments); end

  def root(); end

  def root=(root); end

  def title(); end

  def title=(title); end
end

module ThemeCheck
  BUG_POSTAMBLE = ::T.let(nil, ::T.untyped)
  CONNECTION_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  NET_HTTP_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  SPLITTER = ::T.let(nil, ::T.untyped)
  TAG_END = ::T.let(nil, ::T.untyped)
  TAG_START = ::T.let(nil, ::T.untyped)
  TIMEOUT_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  VARIABLE_END = ::T.let(nil, ::T.untyped)
  VARIABLE_START = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::Analyzer
  def analyze_files(files); end

  def analyze_theme(); end

  def correct_offenses(); end

  def initialize(theme, checks=T.unsafe(nil), auto_correct=T.unsafe(nil)); end

  def json_file_count(); end

  def liquid_file_count(); end

  def offenses(); end

  def total_file_count(); end

  def uncorrectable_offenses(); end

  def write_corrections(); end
end

class ThemeCheck::Analyzer
end

class ThemeCheck::AppBlockValidTags
  def on_include(node); end

  def on_javascript(node); end

  def on_layout(node); end

  def on_section(node); end

  def on_stylesheet(node); end
  OFFENSE_MSG = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::AppBlockValidTags
end

class ThemeCheck::AssetFile
  def gzipped_size(); end

  def rewriter(); end

  def write(); end
end

class ThemeCheck::AssetFile
end

class ThemeCheck::AssetSizeAppBlockCSS
  def initialize(threshold_in_bytes: T.unsafe(nil)); end

  def on_schema(node); end

  def threshold_in_bytes(); end
end

class ThemeCheck::AssetSizeAppBlockCSS
end

class ThemeCheck::AssetSizeAppBlockJavaScript
  def initialize(threshold_in_bytes: T.unsafe(nil)); end

  def on_schema(node); end

  def threshold_in_bytes(); end
end

class ThemeCheck::AssetSizeAppBlockJavaScript
end

class ThemeCheck::AssetSizeCSS
  include ::ThemeCheck::RegexHelpers
  def href_to_file_size(href); end

  def initialize(threshold_in_bytes: T.unsafe(nil)); end

  def on_link(node); end

  def threshold_in_bytes(); end
end

class ThemeCheck::AssetSizeCSS
end

class ThemeCheck::AssetSizeCSSStylesheetTag
  include ::ThemeCheck::RegexHelpers
  def initialize(threshold_in_bytes: T.unsafe(nil)); end

  def on_variable(node); end

  def stylesheet_tag_pipeline_to_file_size(href); end
end

class ThemeCheck::AssetSizeCSSStylesheetTag
end

class ThemeCheck::AssetSizeJavaScript
  include ::ThemeCheck::RegexHelpers
  def initialize(threshold_in_bytes: T.unsafe(nil)); end

  def on_script(node); end

  def src_to_file_size(src); end

  def threshold_in_bytes(); end
end

class ThemeCheck::AssetSizeJavaScript
end

class ThemeCheck::AssetUrlFilters
  def on_variable(node); end
  ASSET_URL_FILTERS = ::T.let(nil, ::T.untyped)
  HTML_FILTERS = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::AssetUrlFilters
end

class ThemeCheck::Check
  include ::ThemeCheck::JsonHelpers
  def ==(other); end

  def add_offense(message, node: T.unsafe(nil), theme_file: T.unsafe(nil), markup: T.unsafe(nil), line_number: T.unsafe(nil), node_markup_offset: T.unsafe(nil), &block); end

  def can_disable?(); end

  def categories(); end

  def code_name(); end

  def doc(); end

  def eql?(other); end

  def ignore!(); end

  def ignored?(); end

  def ignored_patterns(); end

  def ignored_patterns=(ignored_patterns); end

  def offenses(); end

  def offenses=(offenses); end

  def options(); end

  def options=(options); end

  def severity(); end

  def severity=(severity); end

  def severity_value(); end

  def single_file?(); end

  def theme(); end

  def theme=(theme); end

  def whole_theme?(); end
  CATEGORIES = ::T.let(nil, ::T.untyped)
  SEVERITIES = ::T.let(nil, ::T.untyped)
  SEVERITY_VALUES = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::Check
  def self.all(); end

  def self.can_disable(disableable=T.unsafe(nil)); end

  def self.categories(*categories); end

  def self.category(*categories); end

  def self.doc(doc=T.unsafe(nil)); end

  def self.docs_url(path); end

  def self.severity(severity=T.unsafe(nil)); end

  def self.severity_value(severity); end

  def self.single_file(single_file=T.unsafe(nil)); end
end

class ThemeCheck::Checks
  def call(method, *args); end

  def disableable(); end

  def single_file(); end

  def whole_theme(); end
  CHECK_METHOD_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::Checks
end

module ThemeCheck::ChecksTracking
  def inherited(klass); end
end

module ThemeCheck::ChecksTracking
end

class ThemeCheck::Cli
  def check(out_stream=T.unsafe(nil)); end

  def help(); end

  def init(); end

  def list(); end

  def option_parser(parser=T.unsafe(nil), help: T.unsafe(nil)); end

  def parse(argv); end

  def path(); end

  def path=(path); end

  def print(); end

  def print_with_format(theme, analyzer, out_stream); end

  def profile(); end

  def run(); end

  def run!(); end

  def version(); end
  FORMATS = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::Cli::Abort
end

class ThemeCheck::Cli::Abort
end

class ThemeCheck::Cli
  def self.parse_and_run(argv); end

  def self.parse_and_run!(argv); end
end

class ThemeCheck::Config
  def [](name); end

  def auto_correct(); end

  def auto_correct=(auto_correct); end

  def check_configurations(); end

  def enabled_checks(); end

  def exclude_categories(); end

  def exclude_categories=(categories); end

  def ignored_patterns(); end

  def include_categories(); end

  def include_categories=(categories); end

  def initialize(root: T.unsafe(nil), configuration: T.unsafe(nil), should_resolve_requires: T.unsafe(nil)); end

  def root(); end

  def to_h(); end
  BOOLEAN = ::T.let(nil, ::T.untyped)
  BUNDLED_CONFIGS_DIR = ::T.let(nil, ::T.untyped)
  DOTFILE = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::Config
  def self.bundled_config_path(name); end

  def self.default(); end

  def self.find(root, needle=T.unsafe(nil)); end

  def self.from_hash(config); end

  def self.from_path(path); end

  def self.from_string(config); end

  def self.last_loaded_config(); end

  def self.load_bundled_config(name); end

  def self.load_config(path); end

  def self.load_file(absolute_path); end
end

class ThemeCheck::ContentForHeaderModification
  def after_assign(_node); end

  def after_capture(_node); end

  def on_assign(_node); end

  def on_capture(_node); end

  def on_variable(node); end
end

class ThemeCheck::ContentForHeaderModification
end

class ThemeCheck::ConvertIncludeToRender
  def on_include(node); end
end

class ThemeCheck::ConvertIncludeToRender
end

class ThemeCheck::Corrector
  include ::ThemeCheck::JsonHelpers
  def add_translation(json_file, path, value); end

  def create_file(storage, relative_path, content); end

  def initialize(theme_file:); end

  def insert_after(node, content, character_range=T.unsafe(nil)); end

  def insert_before(node, content, character_range=T.unsafe(nil)); end

  def mkdir(storage, relative_path); end

  def remove(node); end

  def remove_file(storage, relative_path); end

  def remove_translation(json_file, path); end

  def replace(node, content, character_range=T.unsafe(nil)); end

  def replace_inner_json(node, json, **pretty_json_opts); end

  def replace_inner_markup(node, content); end

  def wrap(node, insert_before, insert_after); end
end

class ThemeCheck::Corrector
end

class ThemeCheck::DefaultLocale
  def on_end(); end
end

class ThemeCheck::DefaultLocale
end

class ThemeCheck::DeprecateBgsizes
  def on_div(node); end
end

class ThemeCheck::DeprecateBgsizes
end

class ThemeCheck::DeprecateLazysizes
  def on_img(node); end
end

class ThemeCheck::DeprecateLazysizes
end

class ThemeCheck::DeprecatedFilter
  def add_default_offense(node, filter, alternatives); end

  def add_img_url_offense(node); end

  def on_variable(node); end
  MAX_SIZE = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::DeprecatedFilter
end

class ThemeCheck::DeprecatedGlobalAppBlockType
  def on_case(node); end

  def on_condition(node); end

  def on_schema(node); end

  def on_variable(node); end
  INVALID_GLOBAL_APP_BLOCK_TYPE = ::T.let(nil, ::T.untyped)
  VALID_GLOBAL_APP_BLOCK_TYPE = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::DeprecatedGlobalAppBlockType
end

class ThemeCheck::DisabledCheck
  def disabled?(index); end

  def end_index=(index); end

  def first_line(); end

  def first_line=(first_line); end

  def initialize(theme_file, name); end

  def last(); end

  def missing_end_index?(); end

  def name(); end

  def ranges(); end

  def start_index=(index); end

  def theme_file(); end
end

class ThemeCheck::DisabledCheck
end

class ThemeCheck::DisabledChecks
  def checks_missing_end_index(); end

  def disabled?(check, theme_file, check_name, index); end

  def remove_disabled_offenses(checks); end

  def update(node); end
  ACTION_DISABLE_CHECKS = ::T.let(nil, ::T.untyped)
  ACTION_ENABLE_CHECKS = ::T.let(nil, ::T.untyped)
  DISABLE_END = ::T.let(nil, ::T.untyped)
  DISABLE_PREFIX_PATTERN = ::T.let(nil, ::T.untyped)
  DISABLE_START = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::DisabledChecks
end

class ThemeCheck::FileSystemStorage
  def initialize(root, ignored_patterns: T.unsafe(nil)); end

  def mkdir(relative_path); end

  def relative_path(absolute_path); end

  def remove(relative_path); end

  def root(); end
end

class ThemeCheck::FileSystemStorage
end

class ThemeCheck::HtmlCheck
  START_OR_END_QUOTE = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::HtmlCheck
  extend ::ThemeCheck::ChecksTracking
end

class ThemeCheck::HtmlNode
  include ::ThemeCheck::RegexHelpers
  include ::ThemeCheck::PositionHelper
  def attributes(); end

  def content(); end

  def element?(); end

  def initialize(value, theme_file, placeholder_values, parseable_source, parent=T.unsafe(nil)); end

  def literal?(); end

  def name(); end

  def parseable_markup(); end
end

class ThemeCheck::HtmlNode
  extend ::Forwardable
  extend ::ThemeCheck::RegexHelpers
  def self.parse(liquid_file); end
end

class ThemeCheck::HtmlParsingError
  def on_parse_error(exception, theme_file); end
end

class ThemeCheck::HtmlParsingError
end

class ThemeCheck::HtmlVisitor
  def checks(); end

  def initialize(checks); end

  def visit_liquid_file(liquid_file); end
end

class ThemeCheck::HtmlVisitor
end

class ThemeCheck::ImgLazyLoading
  def on_img(node); end
  ACCEPTED_LOADING_VALUES = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::ImgLazyLoading
end

class ThemeCheck::ImgWidthAndHeight
  def on_img(node); end
  ENDS_IN_CSS_UNIT = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::ImgWidthAndHeight
end

class ThemeCheck::InMemoryStorage
  def initialize(files=T.unsafe(nil), root=T.unsafe(nil)); end

  def mkdir(relative_path); end

  def relative_path(absolute_path); end

  def remove(relative_path); end

  def root(); end
end

class ThemeCheck::InMemoryStorage
end

class ThemeCheck::JsonCheck
  def add_offense(message, markup: T.unsafe(nil), line_number: T.unsafe(nil), theme_file: T.unsafe(nil), &block); end
end

class ThemeCheck::JsonCheck
  extend ::ThemeCheck::ChecksTracking
end

class ThemeCheck::JsonFile
  def content(); end

  def parse_error(); end

  def update_contents(new_content=T.unsafe(nil)); end

  def write(); end
end

class ThemeCheck::JsonFile
end

module ThemeCheck::JsonHelpers
  def format_json_parse_error(error); end

  def pretty_json(hash, start_level: T.unsafe(nil), indent: T.unsafe(nil)); end
end

module ThemeCheck::JsonHelpers
end

class ThemeCheck::JsonPrinter
  def initialize(out_stream=T.unsafe(nil)); end

  def offenses_by_path(offenses); end

  def print(offenses); end
end

class ThemeCheck::JsonPrinter
end

module ThemeCheck::LanguageServer
  ASSET_INCLUDE = ::T.let(nil, ::T.untyped)
  PARTIAL_INCLUDE = ::T.let(nil, ::T.untyped)
  PARTIAL_RENDER = ::T.let(nil, ::T.untyped)
  PARTIAL_SECTION = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::LanguageServer::AssetDocumentLinkProvider
end

class ThemeCheck::LanguageServer::AssetDocumentLinkProvider
end

class ThemeCheck::LanguageServer::Bridge
  def initialize(messenger); end

  def log(message); end

  def read_message(); end

  def receive_response(id, result); end

  def send_create_work_done_progress_request(token); end

  def send_internal_error(id, e); end

  def send_message(message_hash); end

  def send_notification(method, params); end

  def send_progress(token, value); end

  def send_request(method, params=T.unsafe(nil)); end

  def send_response(id, result=T.unsafe(nil), error=T.unsafe(nil)); end

  def send_work_done_progress_begin(token, title); end

  def send_work_done_progress_end(token, message); end

  def send_work_done_progress_report(token, message, percentage); end

  def supports_work_done_progress=(supports_work_done_progress); end

  def supports_work_done_progress?(); end
end

class ThemeCheck::LanguageServer::Bridge
end

class ThemeCheck::LanguageServer::Channel
  def <<(value); end

  def close(); end

  def id(); end

  def initialize(id); end

  def pop(); end
  CHANNELS = ::T.let(nil, ::T.untyped)
  MUTEX = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::LanguageServer::Channel
  def self.by_id(id); end

  def self.close(id); end

  def self.create(); end
end

class ThemeCheck::LanguageServer::ClientCapabilities
  def initialization_option(key); end

  def initialize(capabilities); end

  def supports_work_done_progress?(); end

  def supports_workspace_configuration?(); end

  def supports_workspace_did_change_configuration_dynamic_registration?(); end
end

class ThemeCheck::LanguageServer::ClientCapabilities
end

class ThemeCheck::LanguageServer::CodeActionEngine
  include ::ThemeCheck::PositionHelper
  def code_actions(absolute_path, start_position, end_position, only_kinds=T.unsafe(nil)); end

  def initialize(storage, diagnostics_manager); end
end

class ThemeCheck::LanguageServer::CodeActionEngine
end

class ThemeCheck::LanguageServer::CodeActionProvider
  def base_kind(); end

  def code_actions(relative_path, range); end

  def diagnostics_manager(); end

  def initialize(storage, diagnostics_manager); end

  def kind(); end

  def storage(); end
end

class ThemeCheck::LanguageServer::CodeActionProvider
  def self.all(); end

  def self.inherited(subclass); end

  def self.kind(k=T.unsafe(nil)); end
end

class ThemeCheck::LanguageServer::CompletionEngine
  include ::ThemeCheck::PositionHelper
  def completions(relative_path, line, col); end

  def find_token(buffer, cursor); end

  def initialize(storage); end
end

class ThemeCheck::LanguageServer::CompletionEngine
end

module ThemeCheck::LanguageServer::CompletionHelper
  def cursor_on_first_word?(content, cursor); end

  def cursor_on_start_content?(content, cursor, regex); end

  def first_word(content); end
  WORD = ::T.let(nil, ::T.untyped)
end

module ThemeCheck::LanguageServer::CompletionHelper
end

module ThemeCheck::LanguageServer::CompletionItemKinds
  CLASS = ::T.let(nil, ::T.untyped)
  COLOR = ::T.let(nil, ::T.untyped)
  CONSTANT = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_MEMBER = ::T.let(nil, ::T.untyped)
  EVENT = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FILE = ::T.let(nil, ::T.untyped)
  FOLDER = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  MODULE = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  PROPERTY = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  SNIPPET = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TYPE_PARAMETER = ::T.let(nil, ::T.untyped)
  UNIT = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module ThemeCheck::LanguageServer::CompletionItemKinds
end

class ThemeCheck::LanguageServer::CompletionProvider
  include ::ThemeCheck::LanguageServer::CompletionHelper
  include ::ThemeCheck::RegexHelpers
  def completions(content, cursor); end

  def initialize(storage=T.unsafe(nil)); end
end

class ThemeCheck::LanguageServer::CompletionProvider
  def self.all(); end

  def self.inherited(subclass); end
end

class ThemeCheck::LanguageServer::Configuration
  def check_on_change?(); end

  def check_on_open?(); end

  def check_on_save?(); end

  def fetch(force: T.unsafe(nil)); end

  def initialize(bridge, capabilities); end

  def initialized?(); end

  def register_did_change_capability(); end
  CHECK_ON_CHANGE = ::T.let(nil, ::T.untyped)
  CHECK_ON_OPEN = ::T.let(nil, ::T.untyped)
  CHECK_ON_SAVE = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::LanguageServer::Configuration
end

class ThemeCheck::LanguageServer::CorrectionExecuteCommandProvider
  include ::ThemeCheck::LanguageServer::URIHelper
  def bridge(); end

  def diagnostics_manager(); end

  def execute(diagnostic_hashes); end

  def initialize(storage, bridge, diagnostics_manager); end

  def storage(); end
end

class ThemeCheck::LanguageServer::CorrectionExecuteCommandProvider
end

class ThemeCheck::LanguageServer::Diagnostic
  include ::ThemeCheck::LanguageServer::URIHelper
  def ==(other); end

  def absolute_path(); end

  def code(); end

  def code_description(); end

  def correctable?(); end

  def data(); end

  def end_index(); end

  def file_version(); end

  def initialize(offense); end

  def message(); end

  def offense(); end

  def range(); end

  def relative_path(); end

  def severity(); end

  def single_file?(); end

  def start_index(); end

  def to_h(); end

  def uri(); end
end

class ThemeCheck::LanguageServer::Diagnostic
end

class ThemeCheck::LanguageServer::DiagnosticsEngine
  include ::ThemeCheck::LanguageServer::URIHelper
  def analyze_and_send_offenses(absolute_path, config, force: T.unsafe(nil)); end

  def first_run?(); end

  def initialize(storage, bridge, diagnostics_manager=T.unsafe(nil)); end

  def storage(); end
end

class ThemeCheck::LanguageServer::DiagnosticsEngine
end

class ThemeCheck::LanguageServer::DiagnosticsManager
  def build_diagnostics(offenses, analyzed_files: T.unsafe(nil)); end

  def delete_applied(diagnostics); end

  def diagnostics(relative_path); end

  def first_run?(); end

  def workspace_edit(diagnostics); end
end

class ThemeCheck::LanguageServer::DiagnosticsManager
end

class ThemeCheck::LanguageServer::DocumentChangeCorrector
  include ::ThemeCheck::LanguageServer::URIHelper
  include ::ThemeCheck::JsonHelpers
  def add_translation(file, path, value); end

  def create_file(storage, relative_path, contents=T.unsafe(nil), overwrite: T.unsafe(nil)); end

  def document_changes(); end

  def insert_after(node, content, character_range=T.unsafe(nil)); end

  def insert_before(node, content, character_range=T.unsafe(nil)); end

  def mkdir(storage, relative_path); end

  def remove(node); end

  def remove_file(storage, relative_path); end

  def remove_translation(file, path); end

  def replace(node, content, character_range=T.unsafe(nil)); end

  def replace_inner_json(node, json, **pretty_json_opts); end

  def replace_inner_markup(node, content); end

  def wrap(node, insert_before, insert_after); end
end

class ThemeCheck::LanguageServer::DocumentChangeCorrector
end

class ThemeCheck::LanguageServer::DocumentLinkEngine
  def document_links(relative_path); end

  def initialize(storage); end
end

class ThemeCheck::LanguageServer::DocumentLinkEngine
end

class ThemeCheck::LanguageServer::DocumentLinkProvider
  include ::ThemeCheck::RegexHelpers
  include ::ThemeCheck::PositionHelper
  include ::ThemeCheck::LanguageServer::URIHelper
  def destination_directory(); end

  def destination_postfix(); end

  def document_links(buffer); end

  def file_link(partial); end

  def initialize(storage=T.unsafe(nil)); end

  def partial_regexp(); end
end

class ThemeCheck::LanguageServer::DocumentLinkProvider
  def self.all(); end

  def self.destination_directory(); end

  def self.destination_directory=(destination_directory); end

  def self.destination_postfix(); end

  def self.destination_postfix=(destination_postfix); end

  def self.inherited(subclass); end

  def self.partial_regexp(); end

  def self.partial_regexp=(partial_regexp); end
end

class ThemeCheck::LanguageServer::DoneStreaming
end

class ThemeCheck::LanguageServer::DoneStreaming
end

module ThemeCheck::LanguageServer::ErrorCodes
  INTERNAL_ERROR = ::T.let(nil, ::T.untyped)
end

module ThemeCheck::LanguageServer::ErrorCodes
end

class ThemeCheck::LanguageServer::ExecuteCommandEngine
  def <<(provider); end

  def execute(command, arguments); end
end

class ThemeCheck::LanguageServer::ExecuteCommandEngine
end

class ThemeCheck::LanguageServer::ExecuteCommandProvider
  def command(); end

  def execute(arguments); end
end

class ThemeCheck::LanguageServer::ExecuteCommandProvider
  def self.all(); end

  def self.command(cmd=T.unsafe(nil)); end

  def self.inherited(subclass); end
end

class ThemeCheck::LanguageServer::FilterCompletionProvider
  def can_complete?(content, cursor); end
  NAMED_FILTER = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::LanguageServer::FilterCompletionProvider
end

class ThemeCheck::LanguageServer::Handler
  include ::ThemeCheck::LanguageServer::URIHelper
  def initialize(bridge); end

  def on_exit(_id, _params); end

  def on_initialize(id, params); end

  def on_initialized(_id, _params); end

  def on_shutdown(id, _params); end

  def on_text_document_code_action(id, params); end

  def on_text_document_completion(id, params); end

  def on_text_document_did_change(_id, params); end

  def on_text_document_did_close(_id, params); end

  def on_text_document_did_open(_id, params); end

  def on_text_document_did_save(_id, params); end

  def on_text_document_document_link(id, params); end

  def on_workspace_did_change_configuration(_id, _params); end

  def on_workspace_execute_command(id, params); end
  CAPABILITIES = ::T.let(nil, ::T.untyped)
  SERVER_INFO = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::LanguageServer::Handler
end

class ThemeCheck::LanguageServer::IOMessenger
  def initialize(in_stream: T.unsafe(nil), out_stream: T.unsafe(nil), err_stream: T.unsafe(nil)); end

  def log(message); end

  def send_message(message_body); end
end

class ThemeCheck::LanguageServer::IOMessenger
  def self.err_stream(); end
end

class ThemeCheck::LanguageServer::IncludeDocumentLinkProvider
end

class ThemeCheck::LanguageServer::IncludeDocumentLinkProvider
end

class ThemeCheck::LanguageServer::IncompatibleStream
end

class ThemeCheck::LanguageServer::IncompatibleStream
end

class ThemeCheck::LanguageServer::Messenger
  def close_input(); end

  def close_output(); end

  def log(); end

  def read_message(); end

  def send_message(); end
end

class ThemeCheck::LanguageServer::Messenger
end

class ThemeCheck::LanguageServer::ObjectCompletionProvider
  def partial(variable_lookup); end

  def variable_lookup_at_cursor(content, cursor); end
end

class ThemeCheck::LanguageServer::ObjectCompletionProvider
end

class ThemeCheck::LanguageServer::QuickfixCodeActionProvider
end

class ThemeCheck::LanguageServer::QuickfixCodeActionProvider
end

class ThemeCheck::LanguageServer::RenderDocumentLinkProvider
end

class ThemeCheck::LanguageServer::RenderDocumentLinkProvider
end

class ThemeCheck::LanguageServer::RenderSnippetCompletionProvider
end

class ThemeCheck::LanguageServer::RenderSnippetCompletionProvider
end

class ThemeCheck::LanguageServer::RunChecksExecuteCommandProvider
  include ::ThemeCheck::LanguageServer::URIHelper
  def execute(_args); end

  def initialize(diagnostics_engine, root_path, root_config); end
end

class ThemeCheck::LanguageServer::RunChecksExecuteCommandProvider
end

class ThemeCheck::LanguageServer::SectionDocumentLinkProvider
end

class ThemeCheck::LanguageServer::SectionDocumentLinkProvider
end

class ThemeCheck::LanguageServer::Server
  def handler(); end

  def initialize(messenger:, should_raise_errors: T.unsafe(nil), number_of_threads: T.unsafe(nil)); end

  def listen(); end

  def should_raise_errors(); end

  def start_handler_threads(); end

  def start_json_rpc_thread(); end

  def status_code_from_error(e); end
end

class ThemeCheck::LanguageServer::Server
end

class ThemeCheck::LanguageServer::SourceFixAllCodeActionProvider
  def code_actions(relative_path, _); end
end

class ThemeCheck::LanguageServer::SourceFixAllCodeActionProvider
end

class ThemeCheck::LanguageServer::TagCompletionProvider
  def can_complete?(content, cursor); end
end

class ThemeCheck::LanguageServer::TagCompletionProvider
end

module ThemeCheck::LanguageServer::TextDocumentSyncKind
  FULL = ::T.let(nil, ::T.untyped)
  INCREMENTAL = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
end

module ThemeCheck::LanguageServer::TextDocumentSyncKind
end

module ThemeCheck::LanguageServer::URIHelper
  def file_path(uri_string); end

  def file_uri(absolute_path); end
end

module ThemeCheck::LanguageServer::URIHelper
end

module ThemeCheck::LanguageServer::VariableLookupFinder
  def lookup(content, cursor); end
  ENDS_IN_BRACKET_POSITION_THAT_CANT_BE_COMPLETED = ::T.let(nil, ::T.untyped)
  ENDS_WITH_BLANK_POTENTIAL_LOOKUP = ::T.let(nil, ::T.untyped)
  ENDS_WITH_POTENTIAL_LOOKUP = ::T.let(nil, ::T.untyped)
  SYMBOLS_PRECEDING_POTENTIAL_LOOKUPS = ::T.let(nil, ::T.untyped)
  UNCLOSED_SQUARE_BRACKET = ::T.let(nil, ::T.untyped)
  VARIABLE_LOOKUP = ::T.let(nil, ::T.untyped)
  VARIABLE_LOOKUP_CHARACTERS = ::T.let(nil, ::T.untyped)
end

module ThemeCheck::LanguageServer::VariableLookupFinder
  extend ::ThemeCheck::LanguageServer::VariableLookupFinder
end

module ThemeCheck::LanguageServer
  def self.partial_tag(tag); end

  def self.start(); end
end

class ThemeCheck::LiquidCheck
  include ::ThemeCheck::ParsingHelpers
end

class ThemeCheck::LiquidCheck
  extend ::ThemeCheck::ChecksTracking
end

class ThemeCheck::LiquidFile
  def parse(); end

  def rewriter(); end

  def root(); end

  def section?(); end

  def snippet?(); end

  def source_excerpt(line); end

  def template?(); end

  def warnings(); end

  def write(); end
end

class ThemeCheck::LiquidFile
  def self.parse(source); end
end

class ThemeCheck::LiquidNode
  def assigned_or_echoed_variable?(); end

  def block?(); end

  def block_body?(); end

  def block_end_end_index(); end

  def block_end_markup(); end

  def block_end_start_index(); end

  def block_start_end_index(); end

  def block_start_markup(); end

  def block_start_start_index(); end

  def block_tag?(); end

  def comment?(); end

  def document?(); end

  def end_token(); end

  def initialize(value, parent, theme_file); end

  def inner_json(); end

  def inner_markup(); end

  def inner_markup_end_column(); end

  def inner_markup_end_index(); end

  def inner_markup_end_row(); end

  def inner_markup_start_column(); end

  def inner_markup_start_index(); end

  def inner_markup_start_row(); end

  def inside_liquid_tag?(); end

  def literal?(); end

  def markup=(markup); end

  def outer_markup(); end

  def outer_markup_end_column(); end

  def outer_markup_end_index(); end

  def outer_markup_end_row(); end

  def outer_markup_start_column(); end

  def outer_markup_start_index(); end

  def outer_markup_start_row(); end

  def root?(); end

  def schema?(); end

  def source(); end

  def start_token(); end

  def tag?(); end

  def type_name(); end

  def variable?(); end

  def variable_lookup?(); end

  def whitespace_trimmed_end?(); end

  def whitespace_trimmed_start?(); end
  WHITESPACE = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::LiquidNode
end

class ThemeCheck::LiquidTag
  def after_document(_node); end

  def increment_consecutive_statements(node); end

  def initialize(min_consecutive_statements: T.unsafe(nil)); end

  def on_string(node); end

  def on_tag(node); end

  def reset_consecutive_statements(); end
end

class ThemeCheck::LiquidTag
end

class ThemeCheck::LiquidVisitor
  def checks(); end

  def initialize(checks, disabled_checks); end

  def visit_liquid_file(liquid_file); end
end

class ThemeCheck::LiquidVisitor
end

class ThemeCheck::LocaleDiff
  def add_as_offenses(check, key_prefix: T.unsafe(nil), node: T.unsafe(nil), theme_file: T.unsafe(nil), schema: T.unsafe(nil)); end

  def extra_keys(); end

  def initialize(default, other); end

  def missing_keys(); end
  PLURALIZATION_KEYS = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::LocaleDiff
end

class ThemeCheck::MatchingSchemaTranslations
  def on_schema(node); end
end

class ThemeCheck::MatchingSchemaTranslations
end

class ThemeCheck::MatchingTranslations
  def on_end(); end

  def on_file(file); end
end

class ThemeCheck::MatchingTranslations
end

class ThemeCheck::MissingEnableComment
  def after_document(node); end

  def on_comment(node); end

  def on_document(_node); end
end

class ThemeCheck::MissingEnableComment
end

class ThemeCheck::MissingRequiredTemplateFiles
  def on_end(); end
  REQUIRED_JSON_TEMPLATE_FILES = ::T.let(nil, ::T.untyped)
  REQUIRED_LIQUID_FILES = ::T.let(nil, ::T.untyped)
  REQUIRED_LIQUID_TEMPLATE_FILES = ::T.let(nil, ::T.untyped)
  REQUIRED_TEMPLATE_FILES = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::MissingRequiredTemplateFiles
end

class ThemeCheck::MissingTemplate
  def initialize(ignore_missing: T.unsafe(nil)); end

  def on_include(node); end

  def on_render(node); end

  def on_section(node); end
end

class ThemeCheck::MissingTemplate
end

class ThemeCheck::NestedSnippet
  def initialize(max_nesting_level: T.unsafe(nil)); end

  def on_document(node); end

  def on_end(); end

  def on_include(node); end

  def on_render(node); end
end

class ThemeCheck::NestedSnippet::TemplateInfo
  def with_deep_nested(templates, max, current_level=T.unsafe(nil)); end
end

class ThemeCheck::NestedSnippet::TemplateInfo
end

class ThemeCheck::NestedSnippet
end

class ThemeCheck::Node
  def children(); end

  def end_column(); end

  def end_index(); end

  def end_row(); end

  def line_number(); end

  def markup(); end

  def parent(); end

  def start_column(); end

  def start_index(); end

  def start_row(); end

  def theme_file(); end

  def value(); end
end

class ThemeCheck::Node
end

class ThemeCheck::Offense
  include ::ThemeCheck::PositionHelper
  def ==(other); end

  def check(); end

  def check_name(); end

  def code_name(); end

  def correct(corrector=T.unsafe(nil)); end

  def correctable?(); end

  def correction(); end

  def doc(); end

  def end_column(); end

  def end_index(); end

  def end_row(); end

  def eql?(other); end

  def in_range?(other_range); end

  def initialize(check:, message: T.unsafe(nil), theme_file: T.unsafe(nil), node: T.unsafe(nil), markup: T.unsafe(nil), line_number: T.unsafe(nil), node_markup_offset: T.unsafe(nil), correction: T.unsafe(nil)); end

  def line_number(); end

  def location(); end

  def location_range(); end

  def markup(); end

  def markup_start_in_excerpt(); end

  def message(); end

  def node(); end

  def range(); end

  def severity(); end

  def single_file?(); end

  def source_excerpt(); end

  def start_column(); end

  def start_index(); end

  def start_row(); end

  def theme_file(); end

  def to_h(); end

  def to_s_range(); end

  def version(); end

  def whole_theme?(); end
  MAX_SOURCE_EXCERPT_SIZE = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::Offense
end

class ThemeCheck::PaginationSize
  def after_document(_node); end

  def get_value(size); end

  def initialize(min_size: T.unsafe(nil), max_size: T.unsafe(nil)); end

  def max_size(); end

  def min_size(); end

  def on_document(_node); end

  def on_paginate(node); end

  def on_schema(node); end

  def size_is_a_section_setting?(size); end
end

class ThemeCheck::PaginationSize
end

class ThemeCheck::ParserBlockingJavaScript
  def on_script(node); end
end

class ThemeCheck::ParserBlockingJavaScript
end

class ThemeCheck::ParserBlockingScriptTag
  def on_variable(node); end
end

class ThemeCheck::ParserBlockingScriptTag
end

module ThemeCheck::ParsingHelpers
  def outside_of_strings(markup); end
end

module ThemeCheck::ParsingHelpers
end

class ThemeCheck::Position
  include ::ThemeCheck::PositionHelper
  def content_line_count(); end

  def end_column(); end

  def end_index(); end

  def end_row(); end

  def initialize(needle_arg, contents_arg, line_number_1_indexed: T.unsafe(nil), node_markup: T.unsafe(nil), node_markup_offset: T.unsafe(nil)); end

  def start_column(); end

  def start_index(); end

  def start_line_offset(); end

  def start_offset(); end

  def start_row(); end

  def strict_position(); end
end

class ThemeCheck::Position
end

module ThemeCheck::PositionHelper
  def bounded(a, x, b); end

  def from_index_to_row_column(content, index); end

  def from_row_column_to_index(content, row, col); end
end

module ThemeCheck::PositionHelper
end

class ThemeCheck::Printer
  def initialize(out_stream=T.unsafe(nil)); end

  def print(theme, offenses, auto_correct); end

  def print_offense(offense, auto_correct); end
end

class ThemeCheck::Printer
end

module ThemeCheck::RegexHelpers
  def matches(s, re); end
  HTML_LIQUID_PLACEHOLDER = ::T.let(nil, ::T.untyped)
  LIQUID_TAG = ::T.let(nil, ::T.untyped)
  LIQUID_TAG_OR_VARIABLE = ::T.let(nil, ::T.untyped)
  LIQUID_VARIABLE = ::T.let(nil, ::T.untyped)
  START_OR_END_QUOTE = ::T.let(nil, ::T.untyped)
end

module ThemeCheck::RegexHelpers
end

class ThemeCheck::RemoteAsset
  def on_element(node); end
  ABSOLUTE_PATH = ::T.let(nil, ::T.untyped)
  CDN_ROOT = ::T.let(nil, ::T.untyped)
  PROTOCOL = ::T.let(nil, ::T.untyped)
  RELATIVE_PATH = ::T.let(nil, ::T.untyped)
  TAGS = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::RemoteAsset
end

class ThemeCheck::RemoteAssetFile
  def content(); end

  def gzipped_size(); end

  def initialize(src); end
end

class ThemeCheck::RemoteAssetFile
  def self.cache(); end

  def self.from_src(src); end

  def self.uri(src); end
end

class ThemeCheck::RequiredDirectories
  def on_end(); end
  REQUIRED_DIRECTORIES = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::RequiredDirectories
end

class ThemeCheck::RequiredLayoutThemeObject
  def after_document(node); end

  def on_document(node); end

  def on_variable(node); end
  LAYOUT_FILENAME = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::RequiredLayoutThemeObject
end

class ThemeCheck::SchemaHelper
end

class ThemeCheck::SchemaHelper
  def self.delete(hash, path); end

  def self.schema_corrector(schema, path, value); end

  def self.set(hash, path, value); end
end

class ThemeCheck::SchemaJsonFormat
  def initialize(start_level: T.unsafe(nil), indent: T.unsafe(nil)); end

  def on_schema(node); end
end

class ThemeCheck::SchemaJsonFormat
end

module ThemeCheck::ShopifyLiquid
end

module ThemeCheck::ShopifyLiquid::DeprecatedFilter
  def alternatives(filter); end

  def labels(); end
end

module ThemeCheck::ShopifyLiquid::DeprecatedFilter
  extend ::ThemeCheck::ShopifyLiquid::DeprecatedFilter
end

module ThemeCheck::ShopifyLiquid::Filter
  def labels(); end
end

module ThemeCheck::ShopifyLiquid::Filter
  extend ::ThemeCheck::ShopifyLiquid::Filter
end

module ThemeCheck::ShopifyLiquid::Object
  def labels(); end

  def plus_labels(); end
end

module ThemeCheck::ShopifyLiquid::Object
  extend ::ThemeCheck::ShopifyLiquid::Object
end

module ThemeCheck::ShopifyLiquid::SystemTranslations
  def include?(key); end

  def translations(); end

  def translations_hash(); end
end

module ThemeCheck::ShopifyLiquid::SystemTranslations
  extend ::ThemeCheck::ShopifyLiquid::SystemTranslations
end

module ThemeCheck::ShopifyLiquid::Tag
  def end_labels(); end

  def labels(); end

  def liquid_tag_regex(tag); end

  def tag_regex(tag); end
end

module ThemeCheck::ShopifyLiquid::Tag
  extend ::ThemeCheck::ShopifyLiquid::Tag
end

module ThemeCheck::ShopifyLiquid
end

class ThemeCheck::SpaceInsideBraces
  def add_offense_for_match(message, match, node, source_offset, &block); end

  def add_space_missing_after_offense(match, node, source_offset); end

  def add_space_missing_before_offense(match, node, source_offset); end

  def add_too_many_spaces_after_offense(match, node, source_offset); end

  def add_too_many_spaces_before_offense(match, node, source_offset); end

  def on_node(node); end

  def on_tag(node); end

  def on_variable(node); end
end

class ThemeCheck::SpaceInsideBraces::BlockMarkup
  def markup(); end

  def markup=(_); end

  def node_markup_offset(); end

  def node_markup_offset=(_); end
end

class ThemeCheck::SpaceInsideBraces::BlockMarkup
  def self.[](*arg); end

  def self.members(); end
end

class ThemeCheck::SpaceInsideBraces
end

class ThemeCheck::Storage
  def directories(); end

  def files(); end

  def path(relative_path); end

  def read(relative_path); end

  def versioned?(); end

  def write(relative_path, content); end
end

class ThemeCheck::Storage
end

class ThemeCheck::StrictPosition
  include ::ThemeCheck::PositionHelper
  def contents(); end

  def end_column(); end

  def end_index(); end

  def end_row(); end

  def initialize(needle, contents, start_index); end

  def needle(); end

  def start_column(); end

  def start_index(); end

  def start_row(); end
end

class ThemeCheck::StrictPosition
end

module ThemeCheck::StringHelpers
  def demodulize(path); end

  def underscore(camel_cased_word); end
end

module ThemeCheck::StringHelpers
  extend ::ThemeCheck::StringHelpers
end

class ThemeCheck::SyntaxError
  def on_document(node); end

  def on_error(exception); end
end

class ThemeCheck::SyntaxError
end

module ThemeCheck::Tags
end

class ThemeCheck::Tags::Form
  def tag_attributes(); end

  def type_expr(); end

  def variable_name_expr(); end
  FORM_FORMAT = ::T.let(nil, ::T.untyped)
  TAG_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::Tags::Form::ParseTreeVisitor
end

class ThemeCheck::Tags::Form::ParseTreeVisitor
end

class ThemeCheck::Tags::Form
end

class ThemeCheck::Tags::Javascript
end

class ThemeCheck::Tags::Javascript
end

class ThemeCheck::Tags::Layout
  def initialize(tag_name, markup, tokens); end

  def layout_expr(); end
  NO_LAYOUT_KEYS = ::T.let(nil, ::T.untyped)
  SYNTAX = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::Tags::Layout::ParseTreeVisitor
end

class ThemeCheck::Tags::Layout::ParseTreeVisitor
end

class ThemeCheck::Tags::Layout
end

class ThemeCheck::Tags::Paginate
  def page_size(); end
  SYNTAX = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::Tags::Paginate::ParseTreeVisitor
end

class ThemeCheck::Tags::Paginate::ParseTreeVisitor
end

class ThemeCheck::Tags::Paginate
end

class ThemeCheck::Tags::Render
  include ::Liquid::Tag::Disabler
  def attributes(); end

  def initialize(tag_name, markup, options); end

  def template_name_expr(); end
  SYNTAX = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::Tags::Render::ParseTreeVisitor
end

class ThemeCheck::Tags::Render::ParseTreeVisitor
end

class ThemeCheck::Tags::Render
end

class ThemeCheck::Tags::Schema
end

class ThemeCheck::Tags::Schema
end

class ThemeCheck::Tags::Section
  def initialize(tag_name, markup, options); end

  def section_name(); end
  SYNTAX = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::Tags::Section
end

class ThemeCheck::Tags::Style
end

class ThemeCheck::Tags::Style
end

class ThemeCheck::Tags::Stylesheet
end

class ThemeCheck::Tags::Stylesheet
end

module ThemeCheck::Tags
  def self.register_tag(name, klass); end

  def self.register_tags!(); end

  def self.register_tags=(register_tags); end

  def self.register_tags?(); end
end

class ThemeCheck::TemplateLength
  def after_document(node); end

  def initialize(max_length: T.unsafe(nil), exclude_schema: T.unsafe(nil), exclude_stylesheet: T.unsafe(nil), exclude_javascript: T.unsafe(nil)); end

  def on_document(_node); end

  def on_javascript(node); end

  def on_schema(node); end

  def on_stylesheet(node); end
end

class ThemeCheck::TemplateLength
end

class ThemeCheck::Theme
  def [](name_or_relative_path); end

  def all(); end

  def assets(); end

  def default_locale(); end

  def default_locale_json(); end

  def default_locale_json=(default_locale_json); end

  def directories(); end

  def initialize(storage); end

  def json(); end

  def liquid(); end

  def sections(); end

  def snippets(); end

  def storage(); end

  def templates(); end
  DEFAULT_LOCALE_REGEXP = ::T.let(nil, ::T.untyped)
  JSON_REGEX = ::T.let(nil, ::T.untyped)
  LIQUID_REGEX = ::T.let(nil, ::T.untyped)
end

class ThemeCheck::Theme
end

class ThemeCheck::ThemeCheckError
end

class ThemeCheck::ThemeCheckError
end

class ThemeCheck::ThemeFile
  def ==(other); end

  def eql?(other); end

  def initialize(relative_path, storage); end

  def json?(); end

  def liquid?(); end

  def name(); end

  def path(); end

  def relative_path(); end

  def source(); end

  def storage(); end

  def version(); end
end

class ThemeCheck::ThemeFile
end

class ThemeCheck::ThemeFileRewriter
  def initialize(name, source); end

  def insert_after(node, content, character_range=T.unsafe(nil)); end

  def insert_before(node, content, character_range=T.unsafe(nil)); end

  def remove(node); end

  def replace(node, content, character_range=T.unsafe(nil)); end

  def replace_inner_markup(node, content); end

  def wrap(node, insert_before, insert_after); end
end

class ThemeCheck::ThemeFileRewriter
end

class ThemeCheck::Token
  def content(); end

  def content=(_); end

  def end(); end

  def end=(_); end

  def start(); end

  def start=(_); end
end

class ThemeCheck::Token
  def self.[](*arg); end

  def self.members(); end
end

class ThemeCheck::Tokens
  include ::Enumerable
  def each(&block); end

  def initialize(buffer); end
end

class ThemeCheck::Tokens
end

class ThemeCheck::TranslationKeyExists
  def on_document(node); end

  def on_end(); end

  def on_schema(node); end

  def on_variable(node); end
end

class ThemeCheck::TranslationKeyExists
end

class ThemeCheck::UndefinedObject
  def initialize(exclude_snippets: T.unsafe(nil)); end

  def on_assign(node); end

  def on_capture(node); end

  def on_document(node); end

  def on_end(); end

  def on_for(node); end

  def on_include(_node); end

  def on_render(node); end

  def on_variable_lookup(node); end
end

class ThemeCheck::UndefinedObject::TemplateInfo
  def add_render(name:, node:); end

  def add_variable_lookup(name:, node:); end

  def all_assigns(); end

  def all_captures(); end

  def all_forloops(); end

  def all_variables(); end

  def each_snippet(); end

  def each_variable_lookup(unique_keys=T.unsafe(nil)); end
end

class ThemeCheck::UndefinedObject::TemplateInfo
end

class ThemeCheck::UndefinedObject
end

class ThemeCheck::UnknownFilter
  def on_variable(node); end
end

class ThemeCheck::UnknownFilter
end

class ThemeCheck::UnusedAssign
  def on_assign(node); end

  def on_document(node); end

  def on_end(); end

  def on_include(node); end

  def on_variable_lookup(node); end
end

class ThemeCheck::UnusedAssign::TemplateInfo
  def collect_used_assigns(templates, visited=T.unsafe(nil)); end
end

class ThemeCheck::UnusedAssign::TemplateInfo
end

class ThemeCheck::UnusedAssign
end

class ThemeCheck::UnusedSnippet
  def missing_snippets(); end

  def on_end(); end

  def on_include(node); end

  def on_render(node); end
end

class ThemeCheck::UnusedSnippet
end

class ThemeCheck::ValidHTMLTranslation
  def on_file(file); end
end

class ThemeCheck::ValidHTMLTranslation
end

class ThemeCheck::ValidJson
  def on_file(file); end
end

class ThemeCheck::ValidJson
end

class ThemeCheck::ValidSchema
  def on_schema(node); end
end

class ThemeCheck::ValidSchema
end

class ThemeCheck::VersionedInMemoryStorage
  def initialize(files, root=T.unsafe(nil)); end

  def read_version(relative_path); end

  def version(relative_path); end

  def versions(); end

  def write(relative_path, content, version); end
end

class ThemeCheck::VersionedInMemoryStorage::Version
  def id(); end

  def id=(_); end

  def version(); end

  def version=(_); end
end

class ThemeCheck::VersionedInMemoryStorage::Version
  def self.[](*arg); end

  def self.members(); end
end

class ThemeCheck::VersionedInMemoryStorage
end

module ThemeCheck
  def self.bug(message); end

  def self.debug?(); end

  def self.debug_log_file(); end

  def self.with_liquid_c_disabled(); end
end

class Time
  def to_liquid(); end
end

class TracePoint
  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TracePoint
  def self.new(*events); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
  def to_liquid(); end
end

module URI
  include ::URI::RFC2396_REGEXP
end

class URI::FTP
  def buffer_open(buf, proxy, options); end
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::HTTP
  def buffer_open(buf, proxy, options); end
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end

  def self.open(name, *rest, &block); end
end

class UnboundMethod
  include ::MethodSource::SourceLocation::UnboundMethodExtensions
  include ::MethodSource::MethodExtensions
end

module UnicodeNormalize
end

module UnicodeNormalize
end

WEBrick::HTTPAuth::Authenticator::AuthException = WEBrick::HTTPStatus::Unauthorized

WEBrick::HTTPAuth::ProxyAuthenticator::AuthException = WEBrick::HTTPStatus::ProxyAuthenticationRequired

class WEBrick::HTTPRequest
  def body_reader(); end

  def readpartial(size, buf=T.unsafe(nil)); end
  MAX_HEADER_LENGTH = ::T.let(nil, ::T.untyped)
end

class WEBrick::HTTPResponse
  def make_body_tempfile(); end

  def remove_body_tempfile(); end
end

class WEBrick::HTTPResponse::ChunkedWrapper
  def <<(*buf); end

  def initialize(socket, resp); end

  def write(buf); end
end

class WEBrick::HTTPResponse::ChunkedWrapper
end

class WEBrick::HTTPServer
  def create_request(with_webrick_config); end

  def create_response(with_webrick_config); end
end

class WEBrick::HTTPServlet::CGIHandler
  CGIRunnerArray = ::T.let(nil, ::T.untyped)
end

class WEBrick::HTTPServlet::DefaultFileHandler
  def multipart_body(body, parts, boundary, mtype, filesize); end
end

class WEBrick::HTTPServlet::FileHandler
  def set_filesystem_encoding(str); end
end

module Warning
  extend ::Warning
end

class WeakRef
  def initialize(orig); end
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Zlib::Deflate
  def initialize(*arg); end
end

class Zlib::GzipReader
  def initialize(*arg); end
end

class Zlib::GzipWriter
  def initialize(*arg); end
end

class Zlib::Inflate
  def initialize(*arg); end
end
